[
["index.html", "AprendeR: Parte I Presentación", " AprendeR: Parte I The AprendeR team 2019-02-14 Presentación Esto es una edición preliminar en línea de la 1a parte del libro “AprendeR”. El libro está escrito en R Markdown, usando RStudio como editor de texto y el paquete bookdown para convertir los ficheros markdown en un libro. Este trabajo se publica bajo licencia Atribución-No Comercial-SinDerivadas 4.0 "],
["chap-0.html", "Lección 1 Logística de R 1.1 Cómo instalar R y Rstudio 1.2 Cómo guardar el trabajo realizado 1.3 Cómo trabajar con guiones y otros ficheros 1.4 Cómo obtener ayuda 1.5 Cómo instalar y cargar paquetes", " Lección 1 Logística de R R es un entorno de programación para el análisis estadístico y gráfico de datos muy popular, cada día más utilizado en empresas y universidades. Su uso tiene muchas ventajas. Para empezar, es software libre. La elección de software libre es, en general, acertada por varios motivos: por un lado, transmite valores socialmente positivos, como por ejemplo la libertad individual, el conocimiento compartido, la solidaridad y la cooperación; por otro, nos aproxima al método científico, porque permite el examen y mejora del código desarrollado por otros usuarios y la reproducibilidad de los resultados obtenidos; finalmente, pero no menos importante desde un punto de vista práctico, podemos adquirir de manera legal y gratuita copias del programa, sin necesidad de licencias personales o académicas. Aparte de su faceta de software libre, R tiene algunas ventajas específicas: por ejemplo, su sintaxis básica es sencilla e intuitiva, con la que es muy fácil familiarizarse, lo que se traduce en un aprendizaje rápido y cómodo; además, tiene una enorme comunidad de usuarios, estructurada alrededor de la Comprehensive R Archive Network, CRAN , que desarrolla cada día nuevos paquetes1 que extienden sus funcionalidades y cubren casi todas las necesidades computacionales y estadísticas de un científico o ingeniero. En fin, si necesitáis aún más razones para usar R, podéis consultar la página &lt;&lt;Why use R?&gt;&gt; de la organización inside-R, en urlhttp://www.inside-r.org/why-use-r 1.1 Cómo instalar R y Rstudio Instalar R es muy sencillo; de hecho, seguramente ya lo tenéis instalado en vuestro ordenador, pero es conveniente que dispongáis de su versión más reciente2 y que regularmente lo pongáis al día. Los pasos a realizar en Windows o Mac OS X para instalar su última versión son los siguientes: Acceded a la página web de la CRAN, http://cran.r-project.org/ y pulsad sobre el enlace correspondiente a vuestro sistema operativo: &lt;&lt;Download R for Windows&gt;&gt; o &lt;&lt;Download R for Mac OS X&gt;&gt;. Si sois usuarios de Windows, entrad en el enlace &lt;&lt;base&gt;&gt;, descargad R y seguid las instrucciones de instalación del documento &lt;&lt;Installation and other instructions&gt;&gt; que encontraréis en esa misma página. Si usáis Windows Vista, conviene que consultéis además el enlace &lt;&lt;How do I install R when using Windows Vista?&gt;&gt;. Si sois usuarios de Mac OS X, descargad el fichero .pkg correspondiente y, una vez descargado, abridlo y seguid las instrucciones del Asistente de Instalación. Si trabajáis con Ubuntu o Debian, para instalar la última versión de R basta que ejecutéis en una terminal, estando conectados a Internet, la siguiente instrucción: sudo aptitude install r-base Cuando instaláis R para Windows o Mac OS X, con él también se os instala una interfaz gráfica que se abrirá al abrir la aplicación y en la que podréis trabajar. La instalación para Linux no lleva una interfaz por defecto, así que sus usuarios tienen que trabajar con R en la terminal (ejecutando R para iniciar una sesión) o instalar aparte una interfaz. Independientemente de todas estas posibilidades, en este curso usaremos Rstudio como interfaz gráfica de usuario de R para todos los sistemas operativos. Propiamente hablando, Rstudio es mucho más que una interfaz de R: se trata de todo un entorno integrado para utilizar y programar con R, que dispone de un conjunto de herramientas que facilitan el trabajo con este lenguaje. Para instalarlo, se ha de descargar de http://www.rstudio.com/products/rstudio/download/ la versión correspondiente al sistema operativo en el que se trabaja. Una vez descargado, en el caso de Windows o Mac OS X ya se puede abrir directamente. En el caso de Linux, hay que ejecutar en una terminal la siguiente instrucción para completar su instalación:sudo dpkg -i rstudio-&lt;version&gt;-i386.deb. Donde version refiere a la versión concreta que se haya descargado. Conviene recordar que Rstudio no es R, ni tan solo lo contiene: hay que instalar ambos programas. De hecho, las instalaciones de R y Rstudio son independientes una de la otra, de manera que cuando se pone al día uno de estos programas, no se modifica el otro. Figura 1.1: Ventana de Rstudio para Mac OS X. Cuando se abre Rstudio, aparece una ventana similar a la que muestra la Figura 1.1: su apariencia exacta dependerá del sistema operativo. De momento, nos concentraremos en la ventana de la izquierda, llamada la consola de R. Observaréis que en el momento de abrir la aplicación, dicha ventana contiene una serie de información (versión, créditos, etc.) y al final una línea en blanco encabezada por el símbolo &gt;. Este símbolo es la marca de inicio e indica que R espera que escribáis alguna instrucción y la ejecutéis. Durante la mayor parte de este curso, usaremos Rstudio de manera interactiva: Escribiremos una instrucción en la consola, a la derecha de la marca de inicio de su última línea. La ejecutaremos pulsando la tecla Entrar (\\(\\hookleftarrow\\)). R la evaluará y, si corresponde, escribirá el resultado en la línea siguiente de la consola (como veremos, no todas las instrucciones hacen que R escriba algo). R abrirá una nueva línea en blanco encabezada por una marca de inicio, donde esperará una nueva instrucción. Haced una prueba: escribid 1+1 junto a la marca de inicio y pulsad Entrar; R escribirá en la línea siguiente el resultado de la suma, 2, y a continuación una nueva línea en blanco encabezada por la marca de inicio. 1+1 ## [1] 2 Ya hablaremos del [1] que precede al 2 en la Lección 4. Hasta entonces, no os preocupéis por él. Para facilitarnos el trabajo, la consola dispone de un mecanismo para acceder a las instrucciones ya ejecutadas y modificarlas si queremos. Si situamos el cursor a la derecha de la marca de inicio de la línea inferior y pulsamos la tecla de la flecha vertical ascendente \\(\\uparrow\\), iremos obteniendo de manera consecutiva, en esa línea, las instrucciones escritas hasta el momento en la misma sesión; si nos pasamos, podemos usar la tecla \\(\\downarrow\\) para retroceder dentro de esta lista; una vez alcanzada la instrucción deseada, podemos volver a ejecutarla o, con las teclas de flechas horizontales, ir al lugar de la instrucción que queramos y reescribir un trozo antes de ejecutarla. Otra posibilidad es usar la pestaña History de la ventana superior derecha de Rstudio, que contiene la lista de todas las instrucciones que se han ejecutado en la sesión actual. Si seleccionamos una instrucción de esta lista y pulsamos el botón &lt;&lt;To console&gt;&gt; del menú superior de la pestaña, la instrucción se copiará en la consola y la podremos modificar o ejecutar directamente. También podemos copiar instrucciones de otros ficheros y pegarlas a la derecha de la marca de inicio de la manera habitual en el sistema operativo de nuestro ordenador. Pero hay que ir con cuidado: las instrucciones copiadas de ficheros en formato que no sea texto simple pueden contener caracteres invisibles a simple vista que generen errores al intentar ejecutar la instrucción copiada. En particular, esto afecta a las instrucciones que podáis copiar de ficheros en formato PDF como este. Para evitaros este problema, para cada lección encontraréis, en el repositorio del curso, un fichero en formato texto simple llamado Leccion_i.R (donde la i indica el número de la lección), que contendrá la mayoría de las instrucciones que aparecen en ella. Estas instrucciones las podréis copiar y pegar en la consola, o podréis ejecutarlas directamente abriendo el guión en la ventana de ficheros (véase la Sección 1.3). Volvamos a la ventana de Rstudio de la Figura ??. Observaréis que está dividida a su vez en tres ventanas. La de la izquierda es la consola , donde trabajamos en modo interactivo. La ventana inferior derecha tiene algunas pestañas, entre las que destacamos: Files, que muestra el contenido de la carpeta de trabajo actual (véase la Sección 1.2). Al hacer clic sobre un fichero en esta lista, se abrirá en la ventana de ficheros (véase la Sección 1.3). Plots, que muestra los gráficos que hayamos producido durante la sesión. Se puede navegar entre ellos con las flechas de la barra superior de la pestaña. Packages, que muestra todos los paquetes instalados y, marcados, los que están cargados en la sesión actual (véase la Sección 1.5). Help, donde aparecerá la ayuda que pidamos (véase la Sección 1.4). Por lo que se refiere a la ventana superior izquierda, tiene dos pestañas: Environment, con la lista de los objetos actualmente definidos (véase la Lección 2). History, de la que ya hemos hablado, que contiene la lista de todas las instrucciones que hayamos ejecutado durante la sesión. Aparte de estas tres ventanas, Rstudio dispone de una cuarta ventana para ficheros, que se abre en el sector superior izquierdo, sobre la consola (véase la Sección 1.3). Para cerrar Rstudio, basta elegir &lt;&lt;Quit Rstudio&gt;&gt; del menú &lt;&lt;Rstudio&gt;&gt; o pulsar la combinación de teclas usual para cerrar un programa en vuestro sistema operativo. 1.2 Cómo guardar el trabajo realizado Antes de empezar a utilizar R en serio, lo primero que tenéis que hacer es crear en vuestro ordenador una carpeta específica que será vuestra carpeta de trabajo con R. A continuación, en las Preferencias de Rstudio, que podréis abrir desde el menú &lt;&lt;Rstudio&gt;&gt;, tenéis que declarar esta carpeta como Default working directory. A partir de este momento, por defecto, todo el trabajo que realicéis quedará guardado dentro de esta carpeta, y Rstudio buscará dentro de esta carpeta todo lo que queráis que lea. Si en un momento determinado queréis cambiar temporalmente de carpeta de trabajo, tenéis dos opciones: Podéis usar el menú &lt;&lt;Session \\(\\rightarrow\\) Set Working Directory \\(\\rightarrow\\) Choose Directory…&gt;&gt; para escoger una carpeta. Podéis abrir la pestaña Files de la ventana inferior derecha y navegar por el árbol de directorios que aparece en su barra superior hasta llegar a la carpeta deseada. Tanto de una manera como de la otra, la carpeta que especifiquéis será la carpeta de trabajo durante lo que queda de sesión o hasta que la volváis a cambiar. En cualquier momento podéis guardar la sesión en la que estéis trabajando usando el menú &lt;&lt;Session \\(\\rightarrow\\) Save Workspace as…&gt;&gt;. Además, si no habéis modificado esta opción en las Preferencias , cuando cerréis Rstudio se os pedirá si queréis guardar la sesión; si contestáis que sí, Rstudio guardará en la carpeta de trabajo dos ficheros, .RData y .RHistory, que se cargarán automáticamente al volver a abrir Rstudio y estaréis exactamente donde lo habíais dejado. Nuestro consejo es que digáis que no: normalmente, no os interesará arrastrar todo lo que hayáis hecho en sesiones anteriores. Y si queréis guardar algunas definiciones e instrucciones de una sesión, lo más práctico es guardarlas en un guión (véase la Sección 1.3). Los gráficos que generéis con Rstudio aparecerán en la ventana inferior derecha, en la pestaña Plots que se activa automáticamente cuando se crea alguno. La apariencia del gráfico dependerá de las dimensiones de esta ventana, por lo que es conveniente que sea cuadrada si queréis que el gráfico no aparezca achatado o estirado. Si modificáis la forma de la ventana, las dimensiones del gráfico que aparezca en ella se modificarán de manera automática. Para guardar un gráfico, hay que ir al menú &lt;&lt;Export&gt;&gt; de esta ventana y seleccionar cómo queréis guardarlo: como una imagen en uno los formatos estándares de imágenes (.png, .jpeg, .tiff, etc.) o en formato PDF. Entonces, se abrirá una ventana donde podéis darle nombre, modificar sus dimensiones y especificar el directorio donde queráis que se guarde, entre otras opciones. 1.3 Cómo trabajar con guiones y otros ficheros R admite la posibilidad de crear y usar ficheros de instrucciones que se pueden ejecutar y guardar llamados guiones (scripts). Estos guiones son una alternativa muy cómoda a las sesiones interactivas, porque permiten guardar las versiones finales de las instrucciones usadas, y no toda la sesión con pruebas, errores y resultados provisionales, y facilitan la ejecución de secuencias de instrucciones en un solo paso. Además, un guión se puede guardar, volver a abrir más adelante, editar, etc. El símbolo # sirve para indicar a R que omita todo lo que hay a su derecha en la misma línea, lo que permite añadir comentarios a un guión. Para crear un guión con Rstudio, tenéis que ir al menú &lt;&lt;File \\(\\rightarrow\\) New File \\(\\rightarrow\\) R Script&gt;&gt;. Veréis que os aparece una ventana nueva en el sector superior izquierdo de la ventana de Rstudio, sobre la consola: la llamaremos ventana de ficheros . En ella podéis escribir, línea a línea, las instrucciones que queráis. Para ejecutar instrucciones de esta ventana, basta que las seleccionéis y pulséis el botón &lt;&lt;Run&gt;&gt; que aparece en la barra superior de esta ventana. Para guardar un guión, basta pulsar el botón con el icono de un disquete de ordenador que aparece en la barra superior de su ventana. Otra posibilidad es usar el menú &lt;&lt;File \\(\\rightarrow\\) Save&gt;&gt;, o pulsar la combinación de teclas usual para guardar un fichero en vuestro sistema operativo, siempre y cuando la ventana activa de Rstudio (donde esté activo el cursor en ese momento) sea la del guión. Al guardar un guión por primera vez, se abre una ventana de diálogo donde Rstudio espera que le demos un nombre; la costumbre es usar para los guiones la extensión .R. Podéis abrir un guión ya preexistente con Rstudio usando el menú &lt;&lt;File \\(\\rightarrow\\) Open File&gt;&gt; de Rstudio o pulsando sobre él en la pestaña Files. También podéis arrastrar el icono del guión sobre el de Rstudio o (si habéis declarado que la aplicación por defecto para abrir ficheros con extensión .R sea Rstudio) simplemente abrir el fichero de la manera usual en vuestro sistema operativo. Además de guiones, con Rstudio también podemos crear otros tipos de ficheros que combinen instrucciones de R con instrucciones de otro lenguaje. En este curso lo usaremos para crear ficheros R Markdown, que permiten generar de manera muy cómoda informes y presentaciones que incorporen instrucciones de R (o sólo sus resultados). Para crear un fichero R Markdown, tenéis que ir al menú &lt;&lt;File \\(\\rightarrow\\) New File \\(\\rightarrow\\) R Markdown…&gt;&gt;, donde os aparecerá una ventana que os pedirá el tipo de documento (&lt;&lt;Document&gt;&gt;, &lt;&lt;Presentation&gt;&gt;…), su título y el formato de salida. Una vez completada esta información, se abrirá el fichero en la ventana superior izquierda. Por poner un ejemplo, supongamos que habéis elegido realizar un informe (&lt;&lt;Document&gt;&gt;) con formato de salida html (los formatos posibles son: pdf, html o Word); entonces, para generar un informe básico basta sustituir las palabras clave que ha generado Rstudio en esta ventana. Probadlo: cambiad el título y el texto; a continuación, guardad el fichero con el nombre que queráis y extensión .Rmd, y pulsad el botón &lt;&lt;Knit html&gt;&gt; situado en la barra superior de la ventana; se generará un fichero html en la carpeta de trabajo, con el texto del fichero R Markdown y el mismo título cambiando la extensión .Rmd por .html, y se abrirá en una ventana aparte. Aprender los primeros pasos de R Markdown es sencillo. Para ello, id al botón &lt;&lt;?&gt;&gt; situado en la barra superior de la ventana de ficheros y escoged &lt;&lt;Markdown Quick Reference&gt;&gt;; os aparecerá, en la ventana de ayuda, un manual de referencia rápida de R Markdown que se puede leer en 15 minutos y que para la mayoría de ejercicios de este curso es más que suficiente. También os puede ser útiles las chuletas de R Markdown que encontraréis en el repositorio del curso y en su url original: https://github.com/rstudio/cheatsheets/raw/master/rmarkdown-2.0.pdf https://www.rstudio.com/wp-content/uploads/2015/02/rmarkdown-cheatsheet.pdf En cualquier caso, a medida que avance el curso iremos explicando técnicas para mejorar los ficheros resultantes. 1.4 Cómo obtener ayuda Para conocer toda la información (qué hace, cuál es la sintaxis correcta, qué parámetros tiene, algunos ejemplos de uso…) sobre una función o un objeto, se puede usar el campo de búsqueda, marcado con una lupa, en la esquina superior derecha de la pestaña de Ayuda (Help), situada en el sector inferior derecho de la ventana de Rstudio. Como alternativa, se pueden usar las instrucciones help(nombre del objeto) o, equivalentemente, ?nombre del objeto. Por ejemplo, si entramos en el campo de búsqueda de la pestaña de Ayuda la palabra sum , o si entramos3 en la consola la instrucción help(sum) obtenemos en la pestaña de Ayuda toda la información sobre la función sum. Cuando hayamos avanzado un poco en este curso, la Ayuda os será muy útil. Aquí sólo veremos alguna aplicación simple de la mayoría de las funciones que estudiemos, con los parámetros más importantes y suficientes para nuestros propósitos, y necesitaréis consultar su Ayuda para conocer todos sus usos, todos sus parámetros y otra información relevante. Si queremos pedir ayuda sobre un tema concreto, pero no sabemos el nombre exacto de la función, podemos entrar una palabra clave en el campo de búsqueda de la pestaña de Ayuda, o usar las funciones help.search(&quot;palabra clave&quot;) o, equivalentemente, ??&quot;palabra clave&quot; (las comillas en el help.search son obligatorias). De esta manera, conseguiremos en la ventana de Ayuda una lista de las funciones que R entiende que están relacionadas con la palabra clave entrada. Entonces, pulsando en la función que nos interese de esta lista, aparecerá la información específica sobre ella. Como podéis imaginar, conviene que la palabra clave esté en inglés. R dispone también de una página web de ayuda en línea, que se abre en la pestaña de Ayuda entrando la instrucción help.start().4 Además de la ayuda que incorpora el mismo R, siempre podéis acudir a foros y listas de discusión para encontrar ayuda sobre cualquier duda que podáis tener. Algunos recursos que nosotros encontramos especialmente útiles son los siguientes: La sección dedicada a R del foro stackoverflow: stackoverflow El archivo de la lista de discusión R-help: R-help El grupo de Facebook &lt;&lt;R project en español&gt;&gt;: R project en español Es muy probable que alguien ya haya tenido la misma dificultad y se la hayan resuelto en alguno de estos foros. Existe también una comunidad muy activa de usuarios hispanos de R, en cuyo portal web encontraréis muchos recursos útiles para mejorar vuestro conocimiento de este lenguaje: http://r-es.org/Comunidad 1.5 Cómo instalar y cargar paquetes Muchas funciones y tablas de datos útiles no vienen con la instalación básica de R, sino que forman parte de paquetes (packages), que se tienen que instalar y cargar para poderlos usar. Por citar un par de ejemplos, el paquete magic lleva una función magic que crea cuadrados mágicos;5 para usarla, tenemos que instalar y cargar este paquete. De manera similar, el paquete ggplot2 incorpora una serie de funciones para dibujar gráficos avanzados que no podemos usar si primero no instalamos y cargamos este paquete. Podemos consultar en la pestaña Packages la lista de paquetes que tenemos instalados. Los paquetes que aparecen marcados en esta lista son los que tenemos cargados en la sesión actual. Si queremos cargar un paquete ya instalado, basta marcarlo en esta lista; podemos hacerlo también desde la consola, con la instrucción library(paquete). En caso de necesitar un paquete que no tengamos instalado, hay que instalarlo antes de poderlo cargar. La mayoría de los paquetes se pueden instalar desde el repositorio del CRAN; esto se puede hacer de dos maneras: Desde la consola, entrando la instrucción install.packages(&quot;paquete&quot;, dep=TRUE) (las comillas son obligatorias). El parámetro dep=TRUE obliga a R a instalar no sólo el paquete requerido, sino todos aquellos de los que dependa para funcionar correctamente. Pulsando el botón &lt;&lt;Install&gt;&gt; de la barra superior de la pestaña de paquetes; al hacerlo, Rstudio abre una ventana dónde se nos pide el nombre del paquete a instalar. Conviene dejar marcada la opción &lt;&lt;Install dependencies&gt;&gt;, para que se instalen también los paquetes necesarios para su funcionamiento. Así, supongamos que queremos construir cuadrados mágicos, pero aún no hemos cargado el paquete magic. &gt; magic(10) Error: could not find function &quot;magic&quot; &gt; install.packages(&quot;magic&quot;, dep=TRUE) #Instalamos el paquete magic; también lo # podéis hacer a través de la ventana de paquetes library(magic) #Cargamos el paquete; también lo podéis hacer a # través de la ventana de paquetes magic(10) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] ## [1,] 34 35 6 7 98 99 70 71 42 43 ## [2,] 36 33 8 5 100 97 72 69 44 41 ## [3,] 11 10 83 82 75 74 47 46 39 38 ## [4,] 12 9 84 81 73 76 48 45 40 37 ## [5,] 87 86 79 78 51 50 23 22 15 14 ## [6,] 85 88 77 80 52 49 21 24 13 16 ## [7,] 63 62 55 54 27 26 19 18 91 90 ## [8,] 61 64 53 56 25 28 17 20 89 92 ## [9,] 59 58 31 30 3 2 95 94 67 66 ## [10,] 57 60 29 32 1 4 93 96 65 68 Cuando cerramos Rstudio, los paquetes instalados en la sesión siguen instalados, pero cargados se pierden; por lo tanto, si queremos volver a usarlos en otra sesión, tendremos que volver a cargarlos. Hay paquetes que no se encuentran en el CRAN y que, por lo tanto, no se pueden instalar de la forma que hemos visto. Cuando sea necesario, ya explicaremos la manera de instalarlos y cargarlos en cada caso. En enero de 2016, el repositorio de paquetes de la CRAN, http://cran.r-project.org/web/packages/, superó los 7500 paquetes.↩ Las sesiones de R que aparecen en estas notas se han llevado a cabo en la versión 3.2.3.↩ Aquí entramos significa, naturalmente, escribir a la derecha de la marca de inicio y a continuación pulsar la tecla Entrar.↩ Si ejecutáis esta instrucción en otras interfaces de R, esta página de ayuda en línea se abre en un navegador, siempre y cuando estéis conectados a Internet.↩ Un cuadrado mágico es una tabla cuadrada de números naturales, diferentes dos a dos, tal que las sumas de todas sus columnas, de todas sus filas y de sus dos diagonales principales valen todas lo mismo.↩ "],
["chap-calc.html", "Lección 2 La calculadora 2.1 Números reales: operaciones y funciones básicas 2.2 Cifras significativas y redondeos 2.3 Definición de variables 2.4 Definición de funciones 2.5 Números complejos (opcional) 2.6 Guía rápida 2.7 Ejercicio", " Lección 2 La calculadora Cuando se trabaja en modo interactivo en la consola de R, hay que escribir las instrucciones a la derecha de la marca de inicio &gt; de la línea inferior. Para evaluar una instrucción al terminar de escribirla, se tiene que pulsar la tecla Entrar (\\(\\hookleftarrow\\)); así, por ejemplo, si junto a la marca de inicio escribimos 2+3 y pulsamos Entrar, R escribirá en la línea siguiente el resultado, 5, y a continuación una nueva línea en blanco encabezada por la marca de inicio, donde podremos continuar entrando instrucciones. 2+3 #Y ahora aquí pulso Entrar ## [1] 5 Bueno, hemos hecho trampa. Como ya habíamos comentado en la Sección 1.3, se pueden escribir comentarios: R ignora todo lo que se escribe en la línea después de un signo #. También podéis observar que R ha dado el resultado en una línea que empieza con [1]; ya discutiremos en la Lección 4 qué significa este [1]. Si la expresión que entramos no está completa, R no la evaluará y en la línea siguiente esperará a que la acabemos; lo indicará con la marca de continuación, por defecto un signo +.6 Además, si cometemos algún error de sintaxis, R nos avisará con un mensaje de error.7 &gt; 2*(3+5 #Pulso Entrar, pero no he acabado + ) #ahora sí [1] 16 &gt; 2*3+5) Error: unexpected &#39;)&#39; in &quot;2*3+5)&quot; Como podemos ver, al ejecutar la segunda instrucción, R nos avisa de que el paréntesis no está en su sitio. Se puede agrupar más de una instrucción en una sola línea separándolas con signos de punto y coma. Al pulsar la tecla Entrar, R las ejecutará todas, una tras otra y en el orden en el que las hayamos escrito. 2+3; 2+4; 2+5 ## [1] 5 ## [1] 6 ## [1] 7 2.1 Números reales: operaciones y funciones básicas La separación entre la parte entera y la parte decimal en los números reales se indica con un punto, no con una coma.8 &gt; 2+2.5 #¡ATENCIÓN! El separador decimal ha de ser un punto [1] 4.5 &gt; 2+2,5 #No con una coma Error: unexpected &#39;,&#39; in &quot;2+2,&quot; Las operaciones usuales se indican en R con los signos que damos en la Tabla 2.1. Por lo que se refiere a los dos últimos operadores en esta tabla, recordad que si \\(a\\) y \\(b\\) son dos números reales, con \\(b&gt;0\\), la división entera de \\(a\\) por \\(b\\) da como cociente entero el mayor número entero \\(q\\) tal que \\(q\\cdot b\\leq a\\), y como resto la diferencia \\(a-q\\cdot b\\). Por ejemplo, la división entera de 29.5 entre 6.3 es \\(29.5=4\\cdot 6.3+4.3\\), con cociente entero 4 y resto 4.3.9 Tabla 2.1: Símbolos de operaciones aritméticas. Operación Simbolos Suma + Resta - Multiplicación * División / Potencia ^ Cociente entero %/% Resto div. entera %% A continuación, damos algunos ejemplos de manejo de estas operaciones. Observad el uso natural de los paréntesis para indicar la precedencia de las operaciones. 2*3+5/2 ## [1] 8.5 2*(3+5/2) #Aquí lo único que dividimos entre 2 es 5 ## [1] 11 2*((3+5)/2) ## [1] 8 2/3+4 #Aquí el denominador de la fracción es 3 ## [1] 4.666667 2/(3+4) ## [1] 0.2857143 2^3*5 #Aquí el exponente es 3 ## [1] 40 2^(3*5) ## [1] 32768 2^-5 #En este caso no hacen falta paréntesis... ## [1] 0.03125 2^(-5) #Pero queda más claro si se usan ## [1] 0.03125 534%/%7 #¿Cuántas semanas completas caben en 534 días? ## [1] 76 534%%7 #¿Y cuántos días sobran? ## [1] 2 534-76*7 ## [1] 2 El objeto pi representa el número real \\(\\pi\\). pi ## [1] 3.141593 ¡Cuidado! No podemos omitir el signo * en las multiplicaciones. &gt; 2(3+5) Error: attempt to apply non-function &gt; 2*(3+5) [1] 16 &gt; 2pi Error: unexpected symbol in &quot;2pi&quot; &gt; 2*pi [1] 6.283185 Cuando un número es muy grande o muy pequeño, R emplea la llamada notación científica para dar una aproximación. 2^40 ## [1] 1.099512e+12 2^(-20) ## [1] 9.536743e-07 En este ejemplo, 1.099512e+12 representa el número \\(1.099512\\cdot 10^{12}\\), es decir, 1099512000000, y 9.536743e-07 representa el número \\(9.536743\\cdot 10^{-7}\\), es decir, \\(0.0000009536743\\). Como muestra el ejemplo siguiente, no es necesario que un número sea especialmente grande o pequeño para que R lo escriba en notación científica: basta que esté rodeado de otros números en esa notación. c(2^40,2^(-20),17/3) #La función c sirve para definir vectores ## [1] 1.099512e+12 9.536743e-07 5.666667e+00 Este 5.666667e+00 representa el número \\(5.666667\\cdot 10^0\\), es decir, \\(5.666667\\). R dispone, entre muchas otras, de las funciones numéricas de la Tabla 2.1. Recordad que \\(n!\\), el factorial de \\(n\\), es el producto \\[ n!=n\\cdot (n-1)\\cdot (n-2) \\cdots 3\\cdot 2 \\cdot 1 \\] (con el convenio de que \\(0!=1\\)), y es igual al número de maneras posibles de ordenar una lista de \\(n\\) objetos diferentes (su número de permutaciones ). El número combinatorio \\(\\binom{n}{m}\\), con \\(m\\leq n\\), es \\[ \\binom{n}{m}=\\frac{n!}{m!\\cdot (n-m)!}=\\frac{n(n-1)(n-2)\\cdots (n-m+1)}{m(m-1)(m-2)\\cdots 2\\cdot 1}, \\] y es igual al número de maneras posibles de escoger un subconjunto de \\(m\\) elementos de un conjunto de \\(n\\) objetos diferentes. Recordad también que el valor absoluto \\(|x|\\) de un número \\(x\\) se obtiene tomando \\(x\\) sin signo: \\(|-8|=|8|=8\\). Función \\(\\sqrt{x}\\) \\(e^x\\) \\(\\ln(x)\\) \\(\\log_{10}(x)\\) \\(\\log_a(x)\\) \\(n!\\) \\(\\binom{n}{m}\\) Signo sqrt exp log log10 log( , a) factorial choose Función \\(\\sin(x)\\) \\(\\cos(x)\\) \\(\\tan(x)\\) \\(\\arcsin(x)\\) \\(\\mathrm{arccos}(x)\\) \\(\\arctan(x)\\) |\\(x\\)| Signo sin cos tan asin acos atan abs Las funciones de R se aplican a sus argumentos introduciéndolos siempre entre paréntesis. Si la función se tiene que aplicar a más de un argumento, éstos se tienen que especificar en el orden que toque y separándolos mediante comas; R no tiene en cuenta los espacios en blanco alrededor de las comas. Veamos algunos ejemplos: sqrt(4) ## [1] 2 sqrt(8)-8^(1/2) ## [1] 0 log10(8) ## [1] 0.90309 log(8)/log(10) ## [1] 0.90309 7^log(2, 7) #7 elevado al logaritmo en base 7 de 2 da... ## [1] 2 &gt; 10! #R no entiende esta expresión Error: syntax error factorial(10) ## [1] 3628800 exp(sqrt(8)) ## [1] 16.91883 choose(5,3) #Núm. de subconjuntos de 3 elementos de un conjunto de 5 ## [1] 10 choose(3,5) #Núm. de subconjuntos de 5 elementos de un conjunto de 3 ## [1] 0 R entiende que los argumentos de las funciones sin, cos y tan están en radianes. Si queremos aplicar una de estas funciones a un número de grados, podemos traducir los grados a radianes multiplicándolos por \\(\\pi/180\\). De manera similar, los resultados de asin, acos y atan también están en radianes, y se pueden convertir a grados multiplicándolos por \\(180/\\pi\\). cos(60) #Coseno de 60 radianes ## [1] -0.952413 cos(60*pi/180) #Coseno de 60 grados ## [1] 0.5 acos(0.5) #Arcocoseno de 0.5 en radianes ## [1] 1.047198 acos(0.5)*180/pi #Arcocoseno de 0.5 en grados ## [1] 60 acos(2) ## [1] NaN Este último NaN (acrónimo de Not a Number ) significa que el resultado no existe; en efecto, \\(\\mathrm{arccos}(2)\\) no existe como número real, ya que \\(\\cos(x)\\) siempre pertenece al intervalo \\([-1,1]\\). Ya hemos visto que R dispone del signo pi para representar el número real \\(\\pi\\). En cambio, no tiene ningún signo para indicar la constante de Euler \\(e\\), y hay que emplear exp(1). 2*exp(1) #2·e ## [1] 5.436564 exp(pi)-pi^exp(1) #e^pi-pi^e ## [1] 0.6815349 Para terminar esta sección, observad el resultado siguiente: sqrt(2)^2-2 ## [1] 4.440892e-16 R opera numéricamente con \\(\\sqrt{2}\\), no formalmente, y por eso no da como resultado de \\((\\sqrt{2})^2-2\\) el valor 0 exacto, sino el número pequeñísimo \\(4.440892\\cdot 10^{-16}\\); de hecho, R trabaja internamente con una precisión de aproximadamente 16 cifras decimales, por lo que no siempre podemos esperar resultados exactos.10 2.2 Cifras significativas y redondeos En cada momento, R decide cuántas cifras muestra de un número según el contexto.11 Si queremos conocer una cantidad específica \\(n\\) de cifras significativas de un número \\(x\\), podemos emplear la función print(x, n). Por ejemplo: sqrt(2) ## [1] 1.414214 print(sqrt(2), 20) ## [1] 1.4142135623730951455 print(sqrt(2), 2) ## [1] 1.4 2^100 ## [1] 1.267651e+30 print(2^100, 15) ## [1] 1.26765060022823e+30 print(2^100, 5) ## [1] 1.2677e+30 El número máximo de cifras que podemos pedir con print es 22; si pedimos más, R nos dará un mensaje de error. print(sqrt(2), 22) ## [1] 1.414213562373095145475 &gt; print(sqrt(2), 23) Error in print.default(sqrt(2), 23) : invalid &#39;digits&#39; argument Por otro lado, hay que tener en cuenta que, como ya hemos comentado, R trabaja con una precisión de unas 16 cifras decimales y por lo tanto los dígitos más allá de esta precisión pueden ser incorrectos. Por ejemplo, si le pedimos las 22 primeras cifras de \\(\\pi\\), obtenemos el resultado siguiente: print(pi,22) ## [1] 3.141592653589793115998 En cambio, \\(\\pi\\) vale en realidad \\(3.141592653589793\\underline{238462}\\ldots\\), lo que significa que el valor que da R es erróneo a partir de la decimosexta cifra decimal. La función print permite indicar las cifras que queremos leer , pero no sirve para especificar las cifras decimales con las que queremos trabajar. Para redondear un número \\(x\\) a una cantidad específica \\(n\\) de cifras decimales, y trabajar solamente con esas cifras, hay que usar la función round(x, n). La diferencia entre los efectos de print y round consiste en que print(sqrt(2), 3) es igual a \\(\\sqrt{2}\\), pero R sólo muestra sus primeras 3 cifras, mientras que round(sqrt(2), 3) es igual a \\(1.414\\). print(sqrt(2), 3) ## [1] 1.41 print(sqrt(2), 3)^2 ## [1] 1.41 ## [1] 2 1.41^2 ## [1] 1.9881 round(sqrt(2), 3) ## [1] 1.414 round(sqrt(2), 3)^2 ## [1] 1.999396 En caso de empate, R redondea al valor que termina en cifra par.12 round(2.25, 1) ## [1] 2.2 round(2.35, 1) ## [1] 2.4 ¿Qué pasa si no se indica el número de cifras en el argumento de round? round(sqrt(2)) ## [1] 1 round(sqrt(2), 0) ## [1] 1 Al entrar round(sqrt(2)), R ha entendido que el número de cifras decimales al que queríamos redondear era 0. Esto significa que 0 es el valor por defecto de este parámetro. No es necesario especificar los valores por defecto de los parámetros de una función, y para saber cuáles son, hay que consultar su Ayuda. Así, por ejemplo, la Ayuda de round indica que su sintaxis es round(x, digits=0), donde el valor de digits ha de ser un número entero que indique el número de cifras decimales. Esta sintaxis significa que el valor por defecto del parámetro digits es 0. Escribir digits= en el argumento para especificar el número de cifras decimales es optativo, siempre que mantengamos el orden de los argumentos indicado en la Ayuda: en este caso, primero el número y luego las cifras. Este es el motivo por el que podemos escribir round(sqrt(2), 1) en lugar de round(sqrt(2), digits=1). Si cambiamos el orden de los argumentos, entonces sí que hay que especificar el nombre del parámetro, como muestra el siguiente ejemplo: round(digits=3, sqrt(2)) ## [1] 1.414 round(3, sqrt(2)) ## [1] 3 En la tabla de funciones ya vimos una función de dos argumentos que toma uno por defecto: log. Su sintaxis completa es log(x, base=...), y si no especificamos la base, toma su valor por defecto, \\(e\\), y calcula el logaritmo neperiano. La función round(x) redondea \\(x\\) al valor entero más cercano (y en caso de empate, al que termina en cifra par). R también dispone de otras funciones que permiten redondear a números enteros en otros sentidos específicos: floor(x) redondea \\(x\\) a un número entero por defecto, dando el mayor número entero menor o igual que \\(x\\), que denotamos por \\(\\lfloor x\\rfloor\\). ceiling(x) redondea \\(x\\) a un número entero por exceso, dando el menor número entero mayor o igual que \\(x\\), que denotamos por \\(\\lceil x\\rceil\\). trunc(x) da la parte entera de \\(x\\), eliminando la parte decimal. floor(8.3) #El mayor entero menor o igual que 8.3 ## [1] 8 ceiling(8.3) #El menor entero mayor o igual que 8.3 ## [1] 9 trunc(8.3) #La parte entera de 8.3 ## [1] 8 round(8.3) #El entero más cercano a 8.3 ## [1] 8 floor(-3.7) #El mayor entero menor o igual que -3.7 ## [1] -4 ceiling(-3.7) #El menor entero mayor o igual que -3.7 ## [1] -3 trunc(-3.7) #La parte entera de -3.7 ## [1] -3 round(-3.7) #El entero más cercano a -3.7 ## [1] -4 2.3 Definición de variables R funciona mediante objetos, estructuras de diferentes tipos que sirven para realizar diferentes tareas. Una variable es un tipo de objeto que sirve para guardar datos. Por ejemplo, si queremos crear una variable \\(x\\) que contenga el valor \\(\\pi^2\\), podemos escribir: x=pi^2 Al entrar esta instrucción, R creará el objeto x y le asignará el valor que hemos especificado. En general, se puede crear una variable y asignarle un valor, o asignar un nuevo valor a una variable definida anteriormente, mediante la construcción nombre_de_la_variable=valor. También se puede conectar el nombre de la variable con el valor por medio de una flecha -&gt; o &lt;-, compuesta de un guión y un signo de desigualdad, de manera que el sentido de la flecha vaya del valor a la variable; por ejemplo, las tres primeras instrucciones siguientes son equivalentes, y asignan el valor 2 a la variable \\(x\\), mientras que las dos últimas son incorrectas: x=2 x&lt;-2 2-&gt;x &gt; 2=x Error in 2 = x : invalid (do_set) left-hand side to assignment &gt; 2&lt;-x Error in 2 &lt;- x : invalid (do_set) left-hand side to assignment Nosotros usaremos sistemáticamente el signo = para hacer asignaciones. Se puede usar como nombre de una variable cualquier palabra que combine letras mayúsculas y minúsculas (R las distingue), con acentos o sin,13 dígitos (0,…, 9), puntos &lt;&lt;.&gt;&gt; y signos &lt;&lt;_&gt;&gt;, siempre que empiece con una letra o un punto. Aunque no esté prohibido, es muy mala idea redefinir nombres que ya sepáis que tienen significado para R, como por ejemplo pi o sqrt.14 Como podéis ver en las instrucciones anteriores y en las que siguen, cuando asignamos un valor a una variable, R no da ningún resultado; después podemos usar el nombre de la variable para referirnos al valor que representa. Es posible asignar varios valores a una misma variable en una misma sesión: naturalmente, en cada momento R empleará el último valor asignado. Incluso se puede redefinir el valor de una variable usando en la nueva definición su valor actual. x=5 x^2 ## [1] 25 x=x-2 #Redefinimos x como su valor actual menos 2 x ## [1] 3 x^2 ## [1] 9 x=sqrt(x) #Redefinimos x como la raíz cuadrada de su valor actual x ## [1] 1.732051 2.4 Definición de funciones A menudo querremos definir alguna función. Para ello tenemos que usar, en vez de simplemente =, una construcción especial: nombre_de_la_función=function(variable(s)){definición}. Una vez definida una función, la podemos aplicar a valores de la(s) variable(s). Veamos un ejemplo. Vamos a llamar \\(f\\) a la función \\(x^2-2^x\\), usando \\(x\\) como variable: f=function(x){x^2-2^x} f(30) #La función f aplicada a 30 ## [1] -1073740924 Conviene que os acostumbréis a escribir la fórmula que define la función entre llaves {...}. A veces es necesario y a veces no, pero no vale la pena discutir cuándo. El nombre de la variable se indica dentro de los paréntesis que siguen al function. En el ejemplo anterior, la variable era \\(x\\), y por eso hemos escrito =function(x). Si hubiéramos querido definir la función con variable \\(t\\), habríamos usado =function(t) (y, naturalmente, habríamos escrito la fórmula que define la función con la variable \\(t\\)): f=function(t){t^2-2^t} Se pueden definir funciones de dos o más variables con function, declarándolas todas. Por ejemplo, para definir la función \\(f(x,y)=e^{(2x-y)^2}\\), tenemos que entrar f=function(x, y){exp((2*x-y)^2)} y ahora ya podemos aplicar esta función a pares de valores: f(0, 1) ## [1] 2.718282 f(1, 0) ## [1] 54.59815 Las funciones no tienen por qué tener como argumentos o resultados sólo números reales: pueden involucrar vectores, matrices, tablas de datos, etc. Y se pueden definir por medio de secuencias de instrucciones, no sólo mediante fórmulas numéricas directas; en este caso, hay que separar las diferentes instrucciones con signos de punto y coma o escribir cada instrucción en una nueva línea. Ya iremos viendo ejemplos a medida que avance el curso. En cada momento se pueden saber los objetos (por ejemplo, variables y funciones) que se han definido en la sesión hasta ese momento entrando la instrucción ls() o consultando la pestaña Environment. Para borrar la definición de un objeto, hay que aplicarle la función rm. Si se quiere hacer limpieza y borrar de golpe las definiciones de todos los objetos que se han definido hasta el momento, se puede emplear la instrucción rm(list=ls()) o usar el botón &lt;&lt;Clear&gt;&gt; (icono de la escoba) de la barra superior de la pestaña Environment. rm(list=ls()) #Borramos todas las definiciones f=function(t){t^2-2^t} a=1 a ## [1] 1 ls() ## [1] &quot;a&quot; &quot;f&quot; rm(a) ls() ## [1] &quot;f&quot; &gt; a Error: object &#39;a&#39; not found 2.5 Números complejos (opcional) Hasta aquí, hemos operado con números reales. Con R también podemos operar con números complejos. Los signos para las operaciones son los mismos que en el caso real. (2+5i)*3 ## [1] 6+15i (2+5i)*(3+7i) ## [1] -29+29i (2+5i)/(3+7i) ## [1] 0.7068966+0.0172414i Fijaos en que cuando entramos en R un número complejo escrito en forma binomial \\(a+bi\\), no escribimos un * entre la i y su coeficiente; de hecho, no hay que escribirlo : &gt; 2+5*i Error: object &#39;i&#39; not found Por otro lado, si el coeficiente de \\(i\\) es 1 o \\(-1\\), hay que escribir el &lt;&lt;1&gt;&gt;: por ejemplo, \\(3-i\\) se tiene que escribir 3-1i. Si no lo hacemos, R da un mensaje de error. &gt; (3+i)*(2-i) Error: object &#39;i&#39; not found (3+1i)*(2-1i) ## [1] 7-1i Los complejos que tienen como parte imaginaria un número entero o un racional escrito en forma decimal se pueden entrar directamente en forma binomial, como lo hemos hecho hasta ahora. Para definir números complejos más &lt;&gt; se puede usar la función complex(real=..., imaginary=...). Veamos un ejemplo: 1+2/3i #Esto en realidad es 1 más 2 partido por 3i ## [1] 1-0.666667i &gt; 1+(2/3)i Error: unexpected symbol in &quot;1+(2/3)i&quot; &gt; complex(real=1,imaginary=2/3) [1] 1+0.666667i &gt; z=1+sqrt(2)i Error: unexpected symbol in &quot;z=1+sqrt(2)i&quot; z=complex(real=1, imaginary=sqrt(2)) z ## [1] 1+1.414214i Como sabéis, los números complejos se inventaron para poder trabajar con raíces cuadradas de números negativos. Ahora bien, por defecto, cuando calculamos la raíz cuadrada de un número negativo R no devuelve un número complejo, sino que se limita a avisarnos de que no existe. sqrt(-3) [1] NaN Warning message: In sqrt(-3) : NaNs produced Si queremos que R produzca un número complejo al calcular la raíz cuadrada de un número negativo, tenemos que especificar que este número negativo es un número complejo. La mejor manera de hacerlo es declarándolo como complejo aplicándole la función as.complex sqrt(as.complex(-3)) ## [1] 0+1.732051i La mayoría de las funciones que hemos dado para los números reales admiten extensiones para números complejos, y con R se calculan con la misma función. Ahora no entraremos a explicar cómo se definen estas extensiones, sólo lo comentamos por si sabéis qué hacen y os interesa calcularlas. sqrt(2+3i) ## [1] 1.674149+0.895977i exp(2+3i) ## [1] -7.31511+1.042744i sin(2+3i) ## [1] 9.154499-4.168907i acos(as.complex(2)) #El arcocoseno de 2 es un número complejo ## [1] 0+1.316958i La raíz cuadrada merece un comentario. Naturalmente, sqrt(2+3i) calcula un número complejo \\(z\\) tal que \\(z^2=2+3i\\). Como ocurre con los números reales, todo número complejo diferente de 0 tiene dos raíces cuadradas, y una se obtiene multiplicando la otra por \\(-1\\). R da como raíz cuadrada de un número real la positiva, y como raíz cuadrada de un complejo la que tiene parte real positiva, y si su parte real es 0, la que tiene parte imaginaria positiva. Figura 2.1: Interpretación geométrica de los números complejos. Un número complejo \\(z=a+bi\\) se puede representar como el punto \\((a,b)\\) del plano cartesiano \\(\\mathbb{R}^2\\). Esto permite asociarle dos magnitudes geométricas véase la Figura 2.1 El módulo de \\(z\\), que denotaremos por \\(|z|\\), es la distancia euclídea de \\((0,0)\\) a \\((a,b)\\): \\[ |z|=\\sqrt{a^2+b^2}. \\] Si \\(z\\in \\mathbb{R}\\), su módulo coincide con su valor absoluto; en particular, si \\(z=0\\), su módulo es \\(0\\), y es el único número complejo de módulo 0. El argumento de \\(z\\) (para \\(z\\neq 0\\)), que denotaremos por \\(\\theta_{z}\\), es el ángulo que forman el semieje positivo de abscisas y el vector que va de \\((0,0)\\) a \\((a,b)\\). Este ángulo está determinado por las ecuaciones \\[ \\cos (\\theta_{z})=\\frac{a}{\\sqrt{a^2+b^2}},\\qquad \\sin (\\theta_{z})=\\frac{b}{\\sqrt{a^2+b^2}}. \\] Tabla 2.2: Funciones específicas para números complejos. Operación Signo Parte real Re Parte imaginaria Im Módulo Mod Argumento Arg Conjugado Conj R sabe calcular módulos y argumentos de números complejos. Los argumentos los da en radianes y dentro del intervalo \\((-\\pi,\\pi]\\). En general, R dispone de las funciones básicas específicas para números complejos de la Tabla 2.2. Recordad que el conjugado de un número complejo \\(z=a+bi\\) es \\(\\overline{z}=a-bi\\). Veamos algunos ejemplos de uso de estas funciones: Re(4-7i) ## [1] 4 Im(4-7i) ## [1] -7 Mod(4-7i) ## [1] 8.062258 Arg(4-7i) ## [1] -1.05165 Conj(4-7i) ## [1] 4+7i El módulo y el argumento de un número complejo \\(z\\neq 0\\) lo determinan de manera única, porque \\[ z=|z|\\big(\\cos(\\theta_z)+\\sin(\\theta_z)i\\big). \\] Si queremos definir un número complejo mediante su módulo y argumento, no hace falta utilizar esta igualdad: podemos usar la instrucción complex(modulus=..., argument=...). Por ejemplo: z=complex(modulus=3, argument=pi/5) z ## [1] 2.427051+1.763356i Mod(z) ## [1] 3 Arg(z) ## [1] 0.6283185 pi/5 ## [1] 0.6283185 2.6 Guía rápida Signos de operaciones aritméticas: Tabla 2.3: Símbolos de operaciones aritméticas. Operación Simbolos Suma + Resta - Multiplicación * División / Potencia ^ Cociente entero %/% Resto div. entera %% Funciones numéricas: Función \\(\\sqrt{x}\\) \\(e^x\\) \\(\\ln(x)\\) \\(\\log_{10}(x)\\) \\(\\log_a(x)\\) \\(n!\\) \\(\\binom{n}{m}\\) Signo sqrt exp log log10 log( , a) factorial choose Función \\(\\sin(x)\\) \\(\\cos(x)\\) \\(\\tan(x)\\) \\(\\arcsin(x)\\) \\(\\mathrm{arccos}(x)\\) \\(\\arctan(x)\\) |\\(x\\)| Signo sin cos tan asin acos atan abs pi es el número \\(\\pi\\). print(x, n) muestra el valor de \\(x\\) con \\(n\\) cifras significativas. round(x, n) redondea el valor de \\(x\\) a \\(n\\) cifras decimales. floor(x) redondea \\(x\\) a un número entero por defecto. ceiling(x) redondea \\(x\\) a un número entero por exceso. trunc(x) da la parte entera de \\(x\\). variable =``valor asigna el valor a la variable . Otras construcciones equivalentes son variable &lt;-``valor y valor -&gt;``variable . funcion=function(variables){instrucciones} define la funcion (no ponemos acento en la o) de variables las especificadas entre los paréntesis mediante las instrucciones especificadas entre las llaves. ls() nos da la lista de objetos actualmente definidos. rm borra la definición del objeto u objetos a los que se aplica. rm(list=ls()) borra las definiciones de todos los objetos que hayamos definido. complex se usa para definir números complejos que no se puedan entrar directamente en forma binomial. Algunos parámetros importantes: real e imaginary: sirven para especificar su parte real y su parte imaginaria. modulus y argument: sirven para especificar su módulo y su argumento. as.complex convierte un número real en complejo. Funciones específicas para números complejos: Operación | Parte real | Parte imaginaria | Módulo | Argumento | Conjugado Signo | Re | Im | Mod | Arg | Conj 2.7 Ejercicio Si hubiéramos empezado a contar segundos a partir de las 12 campanadas que marcaron el inicio de 2015, ¿qué día de qué año llegaríamos a los 250 millones de segundos? ¡Cuidado con los años bisiestos! En estas notas, y excepto en el ejemplo que damos en esta página, no mostraremos este signo + para no confundirlo con una suma.↩ Cuando instaláis R, éste reconoce la zona donde vivís a partir de información que extrae del ordenador, y especifica el idioma de los mensajes de acuerdo con esta zona. Seguramente, por lo tanto, los mensajes de error y advertencias os aparecerán en castellano; un castellano algo chapucero, la verdad. Si los queréis en inglés, entrad la instrucción system(&quot;defaults write org.R-project.R force.LANG en_US.UTF-8&quot;) y, a continuación, cerrad Rstudio y volvedlo a abrir. Si los tenéis en inglés, o en cualquier otro idioma, y los queréis en castellano, tenéis que usar system(&quot;defaults write org.R-project.R force.LANG es_Es.UTF-8&quot;).↩ Por consistencia, en el texto también seguiremos el convenio angloamericano de usar un punto en lugar de una coma como separador decimal.↩ Cuando \\(b&lt;0\\), R da como cociente entero el menor número entero \\(q\\) tal que \\(q\\cdot b\\geq a\\), y como resto la diferencia \\(a-q\\cdot b\\), que en este caso es negativa.↩ Si necesitáis trabajar de manera exacta con más cifras significativas, os recomendamos usar las funciones del paquete Rmpfr. Podéis consultar su manual de referencia en https://cran.r-project.org/web/packages/Rmpfr/index.html .↩ También podéis especificar este número de cifras para toda una sesión, entrándolo en lugar de los puntos suspensivos en options(digits=...). Esto no cambia la precisión de los cálculos, sólo cómo se muestran los resultados.↩ No es un capricho, es la regla de redondeo en caso de empate recomendada por el estándar IEEE 754 para aritmética en coma flotante.↩ Aunque os recomendamos que no uséis letras acentuadas, ya que se pueden importar mal de un ordenador a otro. Nosotros las evitaremos.↩ En la Web se pueden encontrar muchas &lt;guías de estilo de R con recomendaciones sobre cómo construir los nombres de objetos. Un buen artículo introductorio sobre el tema se puede encontrar en http://journal.r-project.org/archive/2012-2/RJournal_2012-2_Baaaath.pdf . Al aprender un lenguaje informático es cuando es más fácil adquirir buenos hábitos.↩ "],
["chap-lm.html", "Lección 3 Un aperitivo: Introducción a la regresión lineal 3.1 Cálculo de rectas de regresión 3.2 Rectas de regresión y transformaciones logarítmicas 3.3 Guía rápida 3.4 Ejercicio", " Lección 3 Un aperitivo: Introducción a la regresión lineal En muchos libros de texto y artículos científicos encontraréis gráficos donde una línea recta o algún otro tipo de curva se ajusta a una serie de observaciones representadas por medio de puntos en el plano. La situación en general es la siguiente. Supongamos que tenemos una serie de puntos del plano cartesiano \\(\\mathbb{R}^2\\), \\[ (x_1,y_1), (x_2,y_2),\\ldots,(x_n,y_n), \\] que representan pares de observaciones de dos variables numéricas: por ejemplo, \\(x=\\) año e \\(y=\\) población, o \\(x=\\) longitud de una rama e \\(y=\\) número de hojas en la rama. Queremos describir cómo depende la variable dependiente \\(y\\) de la variable independiente \\(x\\) a partir de estas observaciones. Para ello, buscaremos una función \\(y=f(x)\\) cuya gráfica se aproxime lo máximo posible a los puntos \\((x_i,y_i)_{i=1,\\ldots,n}\\). Esta función nos dará un modelo matemático del comportamiento de las observaciones realizadas que nos permitirá entender mejor los mecanismos que relacionan las variables estudiadas o hacer predicciones sobre futuras observaciones. Una primera opción, y la más sencilla, es estudiar si los puntos \\((x_i,y_i)_{i=1,\\ldots,n}\\) satisfacen una relación lineal. En este caso, se busca la recta de ecuación \\(y=b_1x+b_0\\), con \\(b_0,b_1\\in \\mathbb{R}\\), que aproxime mejor los puntos dados, en el sentido de que la suma de los cuadrados de las diferencias entre los valores \\(y_i\\) y sus aproximaciones \\(b_1x_i+b_0\\), \\[ \\sum_{i=1}^n (y_i-(b_1x_i+b_0))^2, \\] sea mínima. A esta recta \\(y=b_1x+b_0\\) se la llama recta de regresión por mínimos cuadrados ; para abreviar, aquí la llamaremos simplemente recta de regresión, porque es la única que estudiaremos por ahora. El objetivo de esta lección es ilustrar el uso de R mediante el cálculo de esta recta de regresión. Para ello, introduciremos algunas funciones de R que ya explicaremos con más detalle en otras lecciones. Utilizaremos también transformaciones logarítmicas para tratar casos en los que los puntos dados se aproximen mejor mediante una función potencial o exponencial. Dejaremos para otro curso el estudio detallado del ajuste de funciones a familias de puntos con R. 3.1 Cálculo de rectas de regresión Consideremos la Tabla 3.1,15 que da la altura media de los niños a determinadas edades. Queremos determinar a partir de estos datos si hay una relación lineal entre la edad y la altura media de los niños. Tabla 3.1: Alturas medias de niños por edad. edad (años) altura (cm) 1 76.11 2 86.45 3 95.27 5 109.18 7 122.03 9 133.73 11 143.73 13 156.41 Cuando tenemos una serie de observaciones emparejadas como las de esta tabla, la manera natural de almacenarlas en R es mediante una tabla de datos , un data frame en el argot de R. Aunque en este ejemplo concreto no sería necesario, lo haremos así para que empecéis a acostumbraros. La ventaja de tener los datos organizados en forma de data frame es que con ellos luego se pueden hacer muchas más cosas. Estudiaremos en detalle los data frames en la Lección 6. Para crear este data frame, en primer lugar guardaremos cada fila de la Tabla 3.1 como un vector , es decir, como una lista ordenada de números, y le pondremos un nombre adecuado. Para definir un vector, podemos aplicar la función c a la secuencia ordenada de números, separados por comas. edad=c(1,2,3,5,7,9,11,13) altura=c(76.11,86.45,95.27,109.18,122.03,133.73,143.73,156.41) edad ## [1] 1 2 3 5 7 9 11 13 altura ## [1] 76.11 86.45 95.27 109.18 122.03 133.73 143.73 156.41 Ahora vamos a construir un data frame de dos columnas, una para la edad y otra para la altura, y lo llamaremos datos1. Estas columnas serán las variables de nuestra tabla de datos. Para organizar diversos vectores de la misma longitud en un data frame, podemos aplicar la función data.frame a los vectores. datos1=data.frame(edad,altura) datos1 ## edad altura ## 1 1 76.11 ## 2 2 86.45 ## 3 3 95.27 ## 4 5 109.18 ## 5 7 122.03 ## 6 9 133.73 ## 7 11 143.73 ## 8 13 156.41 Observad que las filas del data frame resultante corresponden a los pares (edad, altura) de la Tabla 3.1. Al analizar unos datos, siempre es conveniente empezar con una representación gráfica que nos permita hacernos una idea de sus características. En este caso, lo primero que haremos será dibujar los pares (edad,altura ) usando la función plot. Esta función tiene muchos parámetros que permiten mejorar el resultado, pero ya los veremos al estudiarla en detalle en la Lección 7. Por ahora nos conformamos con un gráfico básico de estos puntos que nos muestre su distribución. Dada una familia de puntos \\((x_n,y_n)_{n=1,\\ldots,k}\\), si llamamos x al vector \\((x_n)_{n=1,\\ldots,k}\\) de sus abscisas e y al vector \\((y_n)_{n=1,\\ldots,k}\\) de sus ordenadas, podemos obtener el gráfico de los puntos \\((x_n,y_n)_{n=1,\\ldots,k}\\) mediante la instrucción plot(x,y). Si los vectores x e y son, en este orden, la primera y la segunda columna de un data frame de dos variables, es suficiente aplicar la función plot al data frame. plot(datos1) Figura 3.1: Representación gráfica de la altura media de los niños a determinadas edades. Así, por ejemplo, para dibujar el gráfico de la Figura 3.1 de los puntos \\((\\mathrm{edad}_n,\\textrm{altura}_n)_{n=1,\\ldots,8}\\), basta entrar la siguiente instrucción: Al ejecutar esta instrucción en la consola de Rstudio, el gráfico resultante se abrirá en la pestaña Plots, y en él se puede observar a simple vista que nuestros puntos siguen aproximadamente una recta. Vamos a calcular ahora su recta de regresión. Dada una familia de puntos \\((x_n,y_n)_{n=1,\\ldots,k}\\), si llamamos x al vector \\((x_n)_{n=1,\\ldots,k}\\) de sus abscisas e y al vector \\((y_n)_{n=1,\\ldots,k}\\) de sus ordenadas, su recta de regresión se calcula con R por medio de la instrucción lm(y~x). Fijaos en la sintaxis: dentro del argumento de lm, primero va el vector y, seguido del vector x conectado a y por una tilde ~. Para R, esta tilde significa en función de: es decir, lm(y~x) significa la recta de regresión de \\(y\\) en función de \\(x\\). Para obtener este signo, los usuarios de Windows y Linux tienen que pulsar Ctrl+Alt+4 seguido de un espacio en blanco y los de Mac OS X con teclado español pueden pulsar Alt+Ñ seguido de un espacio en blanco. Si los vectores y y x son, en este orden , la primera y la segunda columna de un data frame de dos variables, es suficiente aplicar la función lm al data frame. Por desgracia, en nuestro data frame no aparecen en este orden. En general, si x e y son dos columnas de un data frame, para calcular la recta de regresión de \\(y\\) en función de \\(x\\) podemos usar la instrucción lm(y~x, data=data frame). Así pues, para calcular la recta de regresión de los puntos \\((\\mathrm{edad}_n,\\textrm{altura}_n)_{n=1,\\ldots,8}\\), entramos la siguiente instrucción: lm(altura~edad, data=datos1) ## ## Call: ## lm(formula = altura ~ edad, data = datos1) ## ## Coefficients: ## (Intercept) edad ## 73.968 6.493 El resultado que hemos obtenido significa que la recta de regresión tiene término independiente \\(73.968\\) (el punto donde la recta interseca al eje de las \\(y\\)) y el coeficiente de \\(x\\) es \\(6.493\\) (el coeficiente de la variable edad). Es decir, es la recta \\[ y=6.493x+73.968. \\] Ahora la podemos superponer al gráfico anterior, empleando la función abline. Esta función permite añadir una recta al gráfico activo en la pestaña Plots. Por lo tanto, si no hemos cerrado el gráfico anterior, la instrucción abline(lm(altura~edad, data=datos1)) le añade la recta de regresión, produciendo la Figura 3.2. Se ve a simple vista que, efectivamente, esta recta aproxima muy bien los datos. plot(datos1) abline(lm(altura~edad, data=datos1)) Figura 3.2: Ajuste mediante la recta de regresión de la altura media de los niños respecto de su edad. Es importante tener presente que el análisis que hemos realizado de los pares de valores \\((\\mathrm{edad}_n, \\textrm{altura}_n)_{n=1,\\ldots,8}\\) ha sido puramente descriptivo: hemos mostrado que estos datos son consistentes con una función lineal, pero no hemos demostrado que la altura media sea función aproximadamente lineal de la edad. Esto último requeriría una demostración matemática o un argumento biológico, no una simple comprobación numérica para una muestra pequeña de valores, que, al fin y al cabo, es lo único que hemos hecho. Lo que sí que podemos hacer ahora es usar la relación lineal observada para predecir la altura media de los niños de otras edades. Por ejemplo, ¿qué altura media estimamos que tienen los niños de 10 años? Si aplicamos la regla \\[ \\textrm{altura}=6.493\\cdot \\mathrm{edad}+73.968, \\] podemos predecir que la altura media a los 10 años es \\[ 6.493\\cdot 10+73.968=138.898, \\] es decir, de unos 138.9 cm. Para evaluar numéricamente si la relación lineal que hemos encontrado es significativa o no, podemos usar el coeficiente de determinación \\(R^2\\). No explicaremos aquí cómo se define, ya lo haremos en su momento. Es suficiente saber que es un valor entre 0 y 1 y que cuanto más se aproxime la recta de regresión al conjunto de puntos, más cercano será a 1. Por el momento, y como regla general, si este coeficiente de determinación \\(R^2\\) es mayor que 0.9, consideraremos que el ajuste de los puntos a la recta es bueno. Cuando R calcula la recta de regresión también obtiene este valor, pero no lo muestra si no se lo pedimos. Si queremos saber todo lo que ha calculado R con la función lm, tenemos que emplear la construcción summary(lm(...)). En general, la función summary aplicada a un objeto de R nos da un resumen de los contenidos de este objeto. Por ejemplo, como veremos en la Lección ??, summary aplicado a un vector de números produce una serie de datos estadísticos sobre dicho vector. Veamos cuál es el resultado de esta instrucción en nuestro ejemplo: summary(lm(altura~edad, data=datos1)) ## ## Call: ## lm(formula = altura ~ edad, data = datos1) ## ## Residuals: ## Min 1Q Median 3Q Max ## -4.351 -1.743 0.408 2.018 2.745 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 73.9681 1.7979 41.14 1.38e-08 *** ## edad 6.4934 0.2374 27.36 1.58e-07 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 2.746 on 6 degrees of freedom ## Multiple R-squared: 0.992, Adjusted R-squared: 0.9907 ## F-statistic: 748.4 on 1 and 6 DF, p-value: 1.577e-07 Por ahora podemos prescindir de casi toda esta información (en todo caso, observad que la columna Estimate nos da los coeficientes de la recta de regresión), y fijarnos sólo en el primer valor de la penúltima línea, Multiple R-squared. Éste es el coeficiente de determinación \\(R^2\\) que nos interesa. En este caso ha sido de \\(0.992\\), lo que confirma que la recta de regresión aproxima muy bien los datos. Podemos pedir a R que nos dé el valor Multiple R-squared sin tener que obtener todo el summary, añadiendo el sufijo $r.squared a la construcción summary(lm(...)). summary(lm(altura~edad, data=datos1))$r.squared ## [1] 0.9920466 Los sufijos que empiezan con $ suelen usarse en R para obtener componentes de un objeto. Por ejemplo, si al nombre de un data frame le añadimos el sufijo formado por $ seguido del nombre de una de sus variables, obtenemos el contenido de esta variable. datos1$edad ## [1] 1 2 3 5 7 9 11 13 Veamos otro ejemplo de cálculo de recta de regresión. Ejemplo 3.1 (Regresion Karl Pearson) Karl Pearson recopiló en 1903 las alturas de 1078 parejas formadas por un padre y un hijo. Hemos guardado en el url http://aprender.uib.es/Rdir/pearson.txt un fichero que contiene estas alturas. Si lo abrís en un navegador, veréis que es una tabla de dos columnas, etiquetadas Padres e Hijos (Figura 3.3). Cada fila contiene las alturas en pulgadas de un par Padre-Hijo. Figura 3.3: Vista en un navegador del fichero pearson.txt. Vamos a usar estos datos para estudiar si hay dependencia lineal entre la altura de un hijo y la de su padre. Para ello, lo primero que haremos será cargarlos en un data frame Esto se puede llevar a cabo de dos maneras: Usando el menú &lt;&lt;Import Dataset&gt;&gt; de la pestaña Environment de la ventana superior derecha de RStudio, sobre el que volveremos en la Lección 6. Al pulsar sobre este menú, se nos ofrece la posibilidad de importar un fichero de nuestro ordenador (From Text File...) o de Internet (From Web Url...); en este ejemplo, hemos de usar la segunda opción. Al seleccionarla, se nos pide el url del fichero; al entrarlo, se abre una ventana de diálogo donde podemos especificar el nombre del data frame que queremos crear, si el fichero tiene o no una primera fila con los nombres de las columnas, cuál es el signo usado para separar columnas, etc. En el sector &lt;&lt;Input File&gt;&gt; de esta ventana de diálogo se puede ver el aspecto del fichero original, y en el sector &lt;&lt;Data Frame&gt;&gt;, el data frame que obtendremos con las opciones seleccionadas; se trata entonces de escoger las opciones adecuadas para que se cree la versión correcta del data frame En el caso concreto de esta tabla pearson.txt, se tiene que escoger el valor &lt;&lt;Yes&gt;&gt; en &lt;&lt;Heading&gt;&gt; y el valor &lt;&lt;Whitespace&gt;&gt; en &lt;&lt;Separator&gt;&gt; (Figura 3.4). Al pulsar el botón &lt;&lt;Import&gt;&gt;, se importará el fichero en un data frame con el nombre especificado en el campo &lt;&lt;Name&gt;&gt; y se verá su contenido en la ventana de ficheros. Figura 3.4: Opciones para guardar el fichero pearson.txt en un data frame llamado df pearson usando el menú Import Dataset. Usando la instrucción read.table, de la que también hablaremos en la Lección 6; por ahora simplemente hay que saber que se ha de aplicar al nombre del fichero entre comillas, si está en el directorio de trabajo, o a su url , también escrito entre comillas. Si además el fichero contiene una primera fila con los nombres de las columnas, hay que añadir el parámetro header=TRUE. Así pues, para cargar esta tabla de datos concreta en un data frame llamado df_pearson, podemos usar el menú &lt;&lt;Import Dataset&gt;&gt;, o entrar la instrucción siguiente: df_pearson=read.table(&quot;pearson.txt&quot;, header=TRUE) En ambos casos, para comprobar que se ha cargado bien, podemos usar las funciones str, que muestra la estructura del data frame, y head, que muestra sus primeras filas. str(df_pearson) ## &#39;data.frame&#39;: 1078 obs. of 2 variables: ## $ Padres: num 65 63.3 65 65.8 61.1 ... ## $ Hijos : num 59.8 63.2 63.3 62.8 64.3 ... head(df_pearson) ## Padres Hijos ## 1 65.04851 59.77827 ## 2 63.25094 63.21404 ## 3 64.95532 63.34242 ## 4 65.75250 62.79238 ## 5 61.13723 64.28113 ## 6 63.02254 64.24221 El resultado de str(df_pearson) nos dice que este data frame está formado por 1078 observaciones (filas) de dos variables (columnas) llamadas Padres e Hijos. El resultado de head(df_pearson) nos muestra sus primeras seis filas, que podemos comprobar que coinciden con las del fichero original mostrado en la Figura 3.3. Ejecutamos ahora las siguientes instrucciones: par(mfrow=c(1,2))# dos dibujos en linea plot(df_pearson) lm(Hijos~Padres, data=df_pearson) ## ## Call: ## lm(formula = Hijos ~ Padres, data = df_pearson) ## ## Coefficients: ## (Intercept) Padres ## 33.8866 0.5141 summary(lm(Hijos~Padres, data=df_pearson))$r.squared ## [1] 0.2513401 plot(df_pearson) abline(lm(Hijos~Padres, data=df_pearson)) par(mfrow=c(1,1))# volvemos a un dibujos en linea Figura 3.5: Representación gráfica de las alturas de los hijos en función de la de sus padres, junto con su recta de regresión. La instrucción plot de la primera línea produce el gráfico de la izquierda de la Figura 3.5, y junto con la instrucción abline de la última, produce el de la derecha. Obtenemos la recta de regresión \\[ y=33.8866+0.5141x, \\] donde \\(y\\) representa la altura de un hijo y \\(x\\) la de su padre, y un coeficiente de determinación \\(R^2=0.25\\), muy bajo. La regresión no es muy buena, como se puede observar en la Figura 3.5 derecha. 3.2 Rectas de regresión y transformaciones logarítmicas La dependencia de un valor en función de otro no siempre es lineal. A veces podremos detectar otras dependencias (en concreto, exponenciales o potenciales) realizando un cambio de escala adecuado en el gráfico. Cuando dibujamos un gráfico, lo normal es marcar cada eje de manera que la misma distancia entre marcas signifique la misma diferencia entre sus valores; por ejemplo, en el gráfico de la Figura 3.10, las marcas sobre cada uno de los ejes están igualmente espaciadas, de manera que entre cada par de marcas consecutivas en el eje de abscisas hay una diferencia de 2 años y entre cada par de marcas consecutivas en el eje de ordenadas hay una diferencia de 20 cm. Decimos entonces que los ejes están en escala lineal . Pero a veces es conveniente dibujar algún eje en escala logarítmica, situando las marcas de tal manera que la misma distancia entre marcas signifique el mismo cociente entre sus valores. Como el logaritmo transforma cocientes en restas, un eje en escala logarítmica representa el logaritmo de sus valores en escala lineal. Decimos que un gráfico está en escala semilogarítmica cuando su eje de abscisas está en escala lineal y su eje de ordenadas en escala logarítmica. Salvo por los valores en las marcas sobre el eje de las \\(y\\), esto significa que dibujamos en escala lineal el gráfico de \\(\\log(y)\\) en función de \\(x\\). Así pues, si al representar unos puntos \\((x,y)\\) en escala semilogarítmica observamos que siguen aproximadamente una recta, esto querrá decir que los valores \\(\\log(y)\\) siguen una ley aproximadamente lineal en los valores \\(x\\), y, por lo tanto, que \\(y\\) sigue una ley aproximadamente exponencial en \\(x\\). En efecto, si \\(\\log(y)= ax+b\\), entonces \\[ y=10^{\\log(y)}= 10^{ax+b}=10^{ax}\\cdot 10^{b}=10^{b}\\cdot (10^{a})^{x}=\\beta\\cdot \\alpha^x, \\] donde \\(\\beta=10^b\\) y \\(\\alpha=10^a\\). De manera similar, decimos que un gráfico está en escala doble logarítmica cuando ambos ejes están en escala logarítmica. Esto es equivalente, de nuevo salvo por los valores en las marcas sobre los ejes, a dibujar en escala lineal el gráfico de \\(\\log(y)\\) en función de \\(\\log(x)\\). Por consiguiente, si al dibujar unos puntos \\((x,y)\\) en escala doble logarítmica observamos que siguen aproximadamente una recta, esto querrá decir que los valores \\(\\log(y)\\) siguen una ley aproximadamente lineal en los valores \\(\\log(x)\\), y, por lo tanto, que \\(y\\) sigue una ley aproximadamente potencial en \\(x\\). En efecto, si \\(\\log(y)= a\\log(x)+b\\), entonces \\[ y=10^{\\log(y)}= 10^{a\\log(x)+b}=10^{a\\log(x)}\\cdot 10^{b}=10^{b}\\cdot (10^{\\log(x)})^{a} =10^{b}\\cdot x^{a}=\\beta \\cdot x^{a}, \\] donde \\(\\beta=10^b\\). Veamos algunos ejemplos de regresiones lineales con cambios de escala. Ejemplo 3.2 (Serotonina) La serotonina se asocia a la estabilidad emocional en el hombre. En un cierto experimento16 se midió, para algunas cantidades de serotonina, el porcentaje de inhibición de un cierto proceso bioquímico en el que se observaba su presencia. El objetivo era estimar la cantidad de serotonina presente en un tejido a partir del porcentaje de inhibición observado. Los datos que se obtuvieron son los de la Tabla 3.2.17 Tabla 3.2: Porcentajes de inhibición de un cierto proceso bioquímico en presencia de serotonina. serotonina (ng) inhibición (%) 1.2 19 3.6 36 12.0 60 33.0 84 Como queremos predecir la cantidad de serotonina en función de la inhibición observada, consideraremos los pares (inhibición,serotonina). En esta ocasión, en vez de trabajar con un data frame, trabajaremos directamente con los vectores. Con las instrucciones inh=c(19,36,60,84) ser=c(1.2,3.6,12,33) plot(inh,ser) Figura 3.6: Representación gráfica en escala lineal del porcentaje de inhibición en función de la cantidad de serotonina. obtenemos la Figura 3.6, donde vemos claramente que la cantidad de serotonina no es función lineal de la inhibición. Vamos a dibujar ahora el gráfico semilogarítmico de estos puntos, para ver si de esta manera quedan sobre una recta. Para ello, tenemos que añadir al argumento de plot el parámetro log=&quot;y&quot;: plot(inh, ser, log=&quot;y&quot;) Figura 3.7: Representación gráfica en escala semilogarítmica del porcentaje de inhibición en función de la cantidad de serotonina. produce la Figura 3.7 (y observad las marcas en el eje de ordenadas). Los puntos en este gráfico sí que parecen seguir una recta. Por lo tanto, parece que el logaritmo de la cantidad de serotonina es una función aproximadamente lineal del porcentaje de inhibición. Para confirmarlo, calcularemos la recta de regresión de los puntos \\[ (\\textrm{inhibición}_n,\\log(\\textrm{serotonina}_n))_{n=1,\\ldots,4}. \\] Para calcular los logaritmos en base 10 de todas las cantidades de serotonina en un solo paso, podemos aplicar la función log10 directamente al vector ser. log10(ser) ## [1] 0.07918125 0.55630250 1.07918125 1.51851394 lm(log10(ser)~inh) ## ## Call: ## lm(formula = log10(ser) ~ inh) ## ## Coefficients: ## (Intercept) inh ## -0.28427 0.02196 summary(lm(log10(ser)~inh))$r.squared ## [1] 0.9921146 El resultado indica que la recta de regresión de estos puntos es \\(y= 0.02196x-0.28427\\), con un valor de \\(R^2\\) de \\(0.992\\), muy bueno. Por lo tanto, podemos afirmar que, aproximadamente, \\[ \\log(\\textrm{serotonina})= 0.02196\\cdot \\mbox{inhibición}-0.28427. \\] Elevando 10 a cada uno de los lados de esta identidad, obtenemos \\[\\begin{align*} \\textrm{serotonina} = &amp; 10^{\\log(\\textrm{serotonina})}= 10^{-0.28427}\\cdot 10^{0.02196\\cdot \\mbox{inhibición}} \\\\ = &amp; 0.52\\cdot 1.052^{\\mbox{inhibición}}. \\end{align*}\\] Es decir, los puntos de partida siguen aproximadamente la función exponencial \\[ y=0.52\\cdot 1.052^{x}. \\] Vamos ahora a dibujar en un mismo gráfico los puntos \\((\\textrm{inhibición}_n,\\textrm{serotonina}_n)\\) y esta función exponencial. Para añadir la gráfica de una función \\(y=f(x)\\) al gráfico activo en la pestaña Plots podemos emplear la función curve(f(x)$, add=TRUE). Así, plot(inh, ser) curve(0.52*1.052^x, add=TRUE) Figura 3.8: Representación gráfica en escala lineal del porcentaje de inhibición en función de la cantidad de serotonina, junto con la función \\(y=0.52\\cdot 1.052^x\\). produce la Figura 3.8; fijaos en cómo hemos especificado la función \\(y=0.52\\cdot 1.052^{x}\\) dentro del curve. Ahora podemos usar la relación observada, \\[ \\textrm{serotonina}= 0.52\\cdot 1.052^{\\textrm{inhibición}}, \\] para estimar la cantidad de serotonina presente en el tejido a partir de una inhibición concreta. Por ejemplo, si hemos observado un \\(25\\%\\) de inhibición, podemos estimar que la cantidad de serotonina será \\[ 0.52\\cdot 1.052^{25}=1.84\\cdot \\textrm{ng}. \\] Ejemplo 3.3 (SIDA en USA, 1981-1992) Consideremos ahora los datos de la Tabla 3.3. Se trata de los números acumulados de casos de SIDA en los Estados Unidos desde 1981 hasta 1992.18 Acumulados significa que, para cada año, se da el número de casos detectados hasta entonces. Tabla 3.3: Números acumulados anuales de casos de SIDA en los Estados Unidos, 1981 a 1992. año casos 1981 97 1982 709 1983 2698 1984 6928 1985 15242 1986 29944 1987 52902 1988 83903 1989 120612 1990 161711 1991 206247 1992 257085 Queremos estudiar el comportamiento de estos números acumulados de casos en función del tiempo expresado en años a partir de 1980. Lo primero que hacemos es cargar los datos en un data frame Fijaos en que la lista de años va a ser la secuencia de números consecutivos entre 1 y 12. Para definir la secuencia de números consecutivos entre \\(a\\) y \\(b\\) podemos usar la construcción a:b. Esto nos ahorra trabajo y reduce las oportunidades de cometer errores al escribir los números. tiempo=1:12 SIDA_acum=c(97,709,2698,6928,15242,29944,52902,83903,120612, 161711,206247,257085) df_SIDA=data.frame(tiempo, SIDA_acum) plot(df_SIDA) Obtenemos el gráfico de la izquierda de la Figura 3.9, y está claro que los puntos \\((x_n,y_n)\\), donde \\(x\\) representa el año e \\(y\\) el número acumulado de casos de SIDA, no se ajustan a una recta. De hecho, a simple vista se diría que el crecimiento de \\(y\\) en función de \\(x\\) es exponencial. Para confirmar este crecimiento exponencial, dibujamos el gráfico semilogarítmico: plot(df_SIDA, log=&quot;y&quot;) produce el gráfico central de la Figura 3.9, donde los puntos tampoco siguen una recta, y, por lo tanto, \\(y\\) tampoco es función exponencial de \\(x\\). Vamos a ver si el crecimiento de \\(y\\) en función de \\(x\\) es potencial. Para ello, dibujaremos un gráfico doble logarítmico de los puntos \\((x_n,y_n)\\), especificando log=&quot;xy&quot; dentro del argumento de plot. plot(df_SIDA, log=&quot;xy&quot;) Obtenemos el gráfico de la derecha de la Figura 3.9, y ahora sí que parece lineal. Figura 3.9: Representación gráfica en escala lineal (izquierda), semilogarítmica (centro) y doble logarítmica (derecha) del número acumulado de casos de SIDA en EEUU desde 1980 en función de los años transcurridos desde ese año. Lo que haremos ahora será calcular la recta de regresión del logaritmo de SIDA_acum respecto del logaritmo de tiempo y mirar el coeficiente de determinación. Recordad que podemos aplicar una función a todas las entradas de un vector en un solo paso. lm(log10(SIDA_acum)~log10(tiempo), data=df_SIDA) summary(lm(log10(SIDA_acum)~log10(tiempo), data=df_SIDA))$r.squared La regresión que obtenemos es \\(\\log(y)=1.918 + 3.274\\log(x)\\), con un valor de \\(R^2\\) de 0.998, muy alto. Elevando 10 a ambos lados de esta igualdad, obtenemos \\[\\begin{align*} y=10^{\\log(y)}= &amp; 10^{1.918}\\cdot 10^{3.274\\log(x)}=10^{1.918}\\cdot (10^{\\log(x)})^{3.274} \\\\ = &amp; 82.79422\\cdot x^{3.274}. \\end{align*}\\] Para ver si los puntos \\((\\textrm{tiempo}_n,{\\textrm{SIDA_acum}}_n)_{n=1,\\ldots,12}\\) se ajustan bien a la curva \\[ y=82.79422\\cdot x^{3.274}, \\] dibujaremos los puntos y la curva en un único gráfico (en escala lineal): plot(df_SIDA) curve(82.79422*x^3.274, add=TRUE) produce la Figura 3.10, donde vemos que la curva se ajusta bastante bien a los puntos. Figura 3.10: Representación gráfica en escala lineal de la cantidad acumulada de enfermos de SIDA en EEUU desde 1980 en función de los años transcurridos desde ese año, junto con su ajuste mediante la función potencial \\(82.79422 · x^{3.274}\\). Hay que mencionar aquí que se han propuesto modelos matemáticos19 que predicen que, cuando se inicia una epidemia de SIDA en una población, los números acumulados de casos en los primeros años son proporcionales al cubo del tiempo transcurrido desde el inicio. El resultado del análisis que hemos realizado es consistente con esta predicción teórica. 3.3 Guía rápida c sirve para definir vectores. a:b, con \\(a&lt;b\\), define un vector con la secuencia \\(a,a+1,a+2,\\ldots, b\\). data.frame, aplicada a unos vectores de la misma longitud, define un data frame (el tipo de objetos de R en los que guardamos usualmente las tablas de datos) cuyas columnas serán estos vectores. read.table define un data frame a partir de un fichero externo. También se puede usar el menú &lt;&lt;Import Dataset&gt;&gt; de la pestaña Environment en la ventana superior derecha de RStudio lm(y~x) calcula la recta de regresión del vector \\(y\\) respecto del vector \\(x\\). Si \\(x\\) e \\(y\\) son dos columnas de un data frame, éste se ha de especificar en el argumento mediante el parámetro data igualado al nombre del data frame summary sirve para obtener un resumen estadístico de un objeto. Este resumen depende del objeto. En el caso de una recta de regresión calculada con lm, muestra una serie de información estadística extra obtenida en dicho cálculo. plot(x,y) produce el gráfico de los puntos \\((x_n,y_n)\\). Si \\(x\\) e \\(y\\) son, respectivamente, la primera y la segunda columna de un data frame de dos columnas, se le puede entrar directamente el nombre del data frame como argumento. El parámetro log sirve para indicar los ejes que se desea que estén en escala logarítmica: &quot;x&quot; (abscisas), &quot;y&quot; (ordenadas) o &quot;xy&quot; (ambos). abline añade una recta al gráfico activo. curve(función, add=TRUE) añade la gráfica de la función al gráfico activo. 3.4 Ejercicio Las larvas de Lymantria dispar , conocidas como orugas peludas del alcornoque , son una plaga en bosques y huertos. En un experimento20 se quiso determinar la capacidad de atracción de una cierta feromona sobre los machos de esta especie, con el objetivo de emplearla en trampas. En la Tabla 3.4, \\(x\\) representa la cantidad de feromona empleada, en \\(\\mu\\)g,21 y \\(N\\) el número de machos atrapados en una trampa empleando esta cantidad de feromona para atraerlos. knitr::kable( df.aux, caption = &#39;Cantidades de feromona empleadas en trampas y números de machos atrapados.&#39;, booktabs = FALSE,col.names=c(&quot;$x$&quot;,&quot;$N$&quot;)) Tabla 3.4: Cantidades de feromona empleadas en trampas y números de machos atrapados. \\(x\\) \\(N\\) 0.1 3 1.0 6 5.0 9 10.0 11 100.0 20 Decidid si, en los puntos \\((x,N)\\) dados en la Tabla 3.4, el valor de \\(N\\) sigue una función aproximadamente lineal, exponencial o potencial en el valor de \\(x\\). En caso de ser una función de uno de estos tres tipos, calculadla. Representad en un gráfico los puntos \\((x,N)\\) de la Tabla 3.4 y la función que hayáis calculado en el apartado anterior, para visualizar la bondad del ajuste de la curva a los puntos. Estimad cuánta feromona tenemos que usar en una trampa para atraer a 50 machos. Los datos se han extraído de http://www.cdc.gov/growthcharts/clinical_charts.htm .↩ Véase el artículo &lt;&lt;Serotonin: Radioimmunoassay&gt;&gt; de B. Peskar y S. Spector (Science 179, 1973, pp. 1340-1341).↩ ng es la abreviatura de nanogramo , la milmillonésima parte de un gramo.↩ Datos extraídos del HIV/AIDS Surveillance Report de 1993, accesible en http://www.cdc.gov/hiv/topics/surveillance/resources/reports/index.htm .↩ Véase el artículo &lt;&gt; de S.A. Colgate, E. A. Stanley, J. M. Hyman, S. P. Layne y C. Qualls (Proc. Natl. Acad. Sci. USA 86, 1989, pp. 4793–4797).↩ Véase el artículo &lt;&gt; de M. Beroza y E. F. Knipling (Science 177, 1972, pp. 19–27).↩ \\(\\mu\\)g es la abreviatura de microgramo , la millonésima parte de un gramo.↩ "],
["chap-vect.html", "Lección 4 Vectores y otros tipos de listas 4.1 Construcción de vectores 4.2 Operaciones con vectores 4.3 Entradas y trozos de vectores 4.4 Factores 4.5 Listas heterogéneas 4.6 Guía rápida de funciones 4.7 Ejercicio", " Lección 4 Vectores y otros tipos de listas Un vector es una secuencia ordenada de datos. R dispone de muchos tipos de datos, entre los que destacamos: logical (lógicos: TRUE, verdadero, o FALSE, falso) integer (números enteros) numeric (números reales) complex (números complejos) character (palabras) Una restricción fundamental de los vectores en R es que todos sus objetos han de ser del mismo tipo: todos números, todos palabras, etc. Cuando queramos usar vectores formados por objetos de diferentes tipos, tendremos que usar listas heterogéneas, lists en el argot de R (véase la Sección 4.5). 4.1 Construcción de vectores Para definir un vector con unos elementos dados, por ejemplo 1, 5, 6, 2, 5, 7, 8, 3, 5, 2, 1, 0, podemos aplicar la función c a estos elementos separados por comas. x=c(1,5,6,2,5,7,8,3,5,2,1,0) x ## [1] 1 5 6 2 5 7 8 3 5 2 1 0 Si queremos crear un vector de palabras con la instrucción c, tenemos que entrarlas obligatoriamente entre comillas. R también nos las muestra entre comillas. nombres=c(&quot;Pep&quot;,&quot;Catalina&quot;,&quot;Joan&quot;,&quot;Pau&quot;) nombres ## [1] &quot;Pep&quot; &quot;Catalina&quot; &quot;Joan&quot; &quot;Pau&quot; &gt; nombres=c(Pep,Catalina,Joan,Pau) #Si nos olvidamos de las comillas... Error: objeto &#39;Pep&#39; no encontrado Hemos mencionado que todos los elementos de un vector han de ser del mismo tipo. Por este motivo, si concatenamos datos de diferentes tipos en un vector, R automáticamente los convertirá a un tipo que pueda ser común a todos ellos. El orden de conversión entre los tipos que hemos explicado al principio de la lección es: character gana a complex, que gana a numeric, que gana a integer, que gana a logical. Así, cuando alguna entrada de un vector es de tipo palabra, R considera el resto de sus entradas como palabras (y las muestra entre comillas), como se puede ver en el siguiente ejemplo: c(2,3.5,TRUE,&quot;casa&quot;) ## [1] &quot;2&quot; &quot;3.5&quot; &quot;TRUE&quot; &quot;casa&quot; Otra posibilidad para crear un vector es usar la función scan. Si ejecutamos la instrucción scan() (así, con el argumento vacío), R abre en la consola un entorno de diálogo donde podemos ir entrando datos separados por espacios en blanco; cada vez que pulsemos la tecla Entrar, R importará los datos que hayamos escrito desde la vez anterior en que la pulsamos y abrirá una nueva línea donde esperará más datos; cuando hayamos acabado, dejamos la última línea en blanco (pulsando por última vez la tecla Entrar) y R cerrará el vector. Por ejemplo, para crear un vector x_scan que contenga dos copias de 1 5 6 2 5 7 8 3 5 2 1 0, podemos hacer lo siguiente:22 &gt; x_scan=scan() #Y pulsamos Entrar 1: 1 5 6 2 5 7 8 3 5 2 1 0 13: 1 5 6 2 5 7 8 3 5 2 1 0 25: Read 24 items x_scan ## [1] 1 5 6 2 5 7 8 3 5 2 1 0 1 5 6 2 5 7 8 3 5 2 1 0 La función scan también se puede usar para copiar en un vector el contenido de un fichero de texto situado en el directorio de trabajo, o del que conozcamos su dirección en Internet. La manera de hacerlo es aplicando scan al nombre del fichero o a su url, entrados en ambos casos entre comillas. Por ejemplo, para definir un vector llamado notas con las notas de un examen que tenemos guardadas en el fichero http://aprender.uib.es/Rdir/notas.txt , sólo tenemos que entrar: notas=scan(&quot;http://aprender.uib.es/Rdir/notas.txt&quot;) notas ## [1] 4.1 7.8 5.8 6.5 4.8 6.9 1.3 6.4 4.6 6.9 9.4 3.0 6.8 4.8 ## [15] 5.6 7.7 10.0 4.4 1.7 8.0 6.3 3.0 7.5 3.8 7.2 5.7 7.3 6.0 ## [29] 5.7 4.7 5.1 1.5 7.0 7.0 6.0 6.6 7.2 5.0 3.5 3.3 4.7 5.4 ## [43] 7.1 8.2 6.7 0.1 5.1 6.8 6.9 8.8 4.5 6.6 2.0 3.0 6.7 7.9 ## [57] 7.7 6.4 3.0 5.3 5.1 5.3 5.1 5.4 3.0 Si primero descargamos este fichero, sin cambiarle el nombre, en el directorio de trabajo de R, para definir el vector anterior bastará entrar: notas2=scan(&quot;notas.txt&quot;) notas2 ## [1] 4.1 7.8 5.8 6.5 4.8 6.9 1.3 6.4 4.6 6.9 9.4 3.0 6.8 4.8 ## [15] 5.6 7.7 10.0 4.4 1.7 8.0 6.3 3.0 7.5 3.8 7.2 5.7 7.3 6.0 ## [29] 5.7 4.7 5.1 1.5 7.0 7.0 6.0 6.6 7.2 5.0 3.5 3.3 4.7 5.4 ## [43] 7.1 8.2 6.7 0.1 5.1 6.8 6.9 8.8 4.5 6.6 2.0 3.0 6.7 7.9 ## [57] 7.7 6.4 3.0 5.3 5.1 5.3 5.1 5.4 3.0 Si usamos el menú &lt;&lt;Import Dataset&gt;&gt; de la pestaña Environment para importar un vector contenido en un fichero externo (véase la página de la Lección 3), obtendremos en realidad un data frame de una sola columna, llamada V1. Para construir un vector con esta columna, podemos usar luego la instrucción nombre_del_vector=nombre_del_dataframe$V1. Véase la Lección 6 para más detalles. La función scan dispone de muchos parámetros, que podéis consultar en su Ayuda. Los más útiles en este momento son los siguientes: sep: sirve para indicar el signo usado para separar entradas consecutivas si no son espacios en blanco. Para ello se ha de igualar sep a este signo, entrecomillado. Por ejemplo, si vamos a entrar las entradas separadas por comas (o si están así en el fichero que vamos a importar), tenemos que especificar sep=&quot;,&quot;. &gt; x_scan2=scan() 1: 1,5,6,2,5,7,8,3,5 1: Error in scan(file, what, nmax, sep, dec, quote, skip, nlines, na.strings, : scan() expected &#39;a real&#39;, got &#39;1,5,6,2,5,7,8,3,5&#39; &gt; x_scan2=scan(sep=&quot;,&quot;) 1: 1,2,3,4 5: Read 4 items &gt; x_scan2 [1] 1 2 3 4 &gt; dec: sirve para indicar el separador decimal cuando no es un punto. Para ello hemos de igualar dec al separador decimal entre comillas. Por ejemplo, si queremos crear con scan un vector formado por los dos números reales 4,5 y 6,2 escritos exactamente de esta manera, tenemos que especificar dec=&quot;,&quot;. &gt; x_scan3=scan() 1: 4,5 6,2 Error in scan(file, what, nmax, sep, dec, quote, skip, nlines, na.strings, : scan() expected &#39;a real&#39;, got &#39;4,5&#39; x_scan3=scan(dec=&quot;,&quot;) 1: 4,5 6,2 3: Read 2 items &gt; x_scan3 [1] 4.5 6.2 what: sirve para indicar a R de qué tipo tiene que considerar los datos que se le entren. En particular, what=&quot;{character“} especifica que los valores que se van a entrar en la consola o el fichero son palabras, aunque no estén entre comillas (si se entran entre comillas, no hace falta especificarlo). &gt; x_scan4=scan(sep=&quot;,&quot;) 1: Pep, Catalina, Joan, Pau Error in scan(sep = &quot;,&quot;) : scan() esperaba &#39;a real&#39;, obtuvo &#39;Pep&#39; &gt; x_scan4=scan(what=&quot;character&quot;, sep=&quot;,&quot;) 1: &quot;Pep&quot;,&quot;Catalina&quot;,&quot;Joan&quot; 4: Read 3 items &gt; x_scan4 [1] &quot;Pep&quot; &quot;Catalina&quot; &quot;Joan&quot; &gt; encoding: sirve para indicar la codificación de alfabeto del fichero externo que se va a importar. Sólo es necesario especificarlo si dicho fichero contiene caracteres que no sean de 7 bits; o sea, letras acentuadas o caracteres especiales. En este caso, si su codificación no es la que espera nuestro ordenador y no la especificamos con este parámetro, estos caracteres se importarán mal. Los dos valores posibles que podemos darle son &quot;latin1&quot; y &quot;UTF-8&quot;. Por ejemplo, si sois usuarios de Windows, seguramente vuestro ordenador espere que el fichero a importar esté codificado en latin1; entonces, si está codificado en utf8 y contiene letras acentuadas, no las entenderá a no ser que especifiquéis encoding=&quot;UTF-8&quot;. Los ficheros que usaremos en este curso estarán codificados en utf8, pero no contendrán letras acentuadas ni caracteres especiales, por lo que no será necesario usar este parámetro. Veamos un ejemplo en sentido contrario: en http://aprender.uib.es/Rdir/enlatin1.txt hemos guardado algunos nombres con acentos y hemos codificado el fichero en latin1. En la sesión siguiente se puede ver cómo si lo importamos desde un ordenador Mac sin avisar de la codificación, los acentos se traducen mal. x_scan5=scan(&quot;http://aprender.uib.es/Rdir/enlatin1.txt&quot;, what=&quot;character&quot;) head(x_scan5, 20) ## [1] &quot;estudio&quot; &quot;bebe&quot; &quot;sexo&quot; &quot;1&quot; ## [5] &quot;Inform\\xe1tica&quot; &quot;No&quot; &quot;Mujer&quot; &quot;2&quot; ## [9] &quot;Matem\\xe1ticas&quot; &quot;No&quot; &quot;Hombre&quot; &quot;3&quot; ## [13] &quot;Ing.Industrial&quot; &quot;S\\xed&quot; &quot;Mujer&quot; &quot;4&quot; ## [17] &quot;Inform\\xe1tica&quot; &quot;S\\xed&quot; &quot;Hombre&quot; &quot;5&quot; x_scan6=scan(&quot;http://aprender.uib.es/Rdir/enlatin1.txt&quot;, what=&quot;character&quot;, encoding=&quot;latin1&quot;) head(x_scan6, 20) ## [1] &quot;estudio&quot; &quot;bebe&quot; &quot;sexo&quot; &quot;1&quot; ## [5] &quot;Informática&quot; &quot;No&quot; &quot;Mujer&quot; &quot;2&quot; ## [9] &quot;Matemáticas&quot; &quot;No&quot; &quot;Hombre&quot; &quot;3&quot; ## [13] &quot;Ing.Industrial&quot; &quot;Sí&quot; &quot;Mujer&quot; &quot;4&quot; ## [17] &quot;Informática&quot; &quot;Sí&quot; &quot;Hombre&quot; &quot;5&quot; Para definir un vector constante podemos usar la función rep(a, n), que genera un vector que contiene el valor \\(a\\) repetido \\(n\\) veces. rep(1, 6) ## [1] 1 1 1 1 1 1 rep(&quot;Palma&quot;, 5) #Las palabras, siempre entre comillas ## [1] &quot;Palma&quot; &quot;Palma&quot; &quot;Palma&quot; &quot;Palma&quot; &quot;Palma&quot; La función rep también se puede usar para repetir vectores. Ahora bien, cuando decimos que queremos repetir cinco veces los valores 1, 2, 3, podemos referirnos a una de las dos construcciones siguientes: \\[ 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3 \\qquad\\mbox{ o }\\qquad 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3. \\] Para especificar el tipo de repetición tenemos que usar el parámetro adecuado en el argumento de rep: si añadimos times=5, repetiremos el vector en bloque cinco veces (en el primer sentido), y si en cambio añadimos each=5, repetiremos cada valor cinco veces (en el segundo sentido). rep(c(1,2,3), times=5) ## [1] 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 rep(c(1,2,3), each=5) ## [1] 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3 Si queremos repetir cada elemento de un vector un número diferente de veces, podemos especificarlo igualando el parámetro times al vector de estas multiplicidades. rep(c(1,2,3,4), times=c(2,3,4,5)) ## [1] 1 1 2 2 2 3 3 3 3 4 4 4 4 4 Las progresiones aritméticas se pueden especificar de manera compacta usando la función seq. Una primera manera de hacerlo es mediante la instrucción seq(a, b, by=p), que especifica la progresión aritmética de paso \\(p\\) que empieza en \\(a\\), \\[ a, a+p, a+2p, \\ldots, \\] hasta llegar a \\(b\\). En concreto, si \\(a&lt;b\\) y \\(p&gt;0\\), la función seq(a, b, by=p) genera un vector con la secuencia creciente $a, a+p, a+2p, , $ hasta llegar al último valor de esta sucesión menor o igual que \\(b\\). seq(3, 150, by=4.5) ## [1] 3.0 7.5 12.0 16.5 21.0 25.5 30.0 34.5 39.0 43.5 48.0 ## [12] 52.5 57.0 61.5 66.0 70.5 75.0 79.5 84.0 88.5 93.0 97.5 ## [23] 102.0 106.5 111.0 115.5 120.0 124.5 129.0 133.5 138.0 142.5 147.0 Si \\(a&gt;b\\) y \\(p&lt;0\\), entonces seq(a, b, by=p) genera un vector con la secuencia decreciente $a, a+p, a+2p, , $ hasta parar en el último valor de esta sucesión mayor o igual que~\\(b\\). seq(80, 4, by=-3.5) ## [1] 80.0 76.5 73.0 69.5 66.0 62.5 59.0 55.5 52.0 48.5 45.0 41.5 38.0 34.5 ## [15] 31.0 27.5 24.0 20.5 17.0 13.5 10.0 6.5 Si el signo de \\(p\\) no es el correcto, obtenemos un mensaje de error. &gt; seq(80, 4, by=3.5) Error in seq.default(80, 4, by = 3.5) : wrong sign in &#39;by&#39; argument Como vimos en la lección anterior, la instrucción seq con paso \\(\\pm 1\\) se puede abreviar con el signo &lt;&lt;:&gt;&gt;. La instrucción a:b define la secuencia de números consecutivos entre dos números \\(a\\) y \\(b\\), es decir, la secuencia \\(a, a+1, a+2, \\ldots\\) hasta llegar a \\(b\\) (si \\(a&lt; b\\)), o \\(a, a-1, a-2, \\ldots\\) hasta llegar a \\(b\\) (si \\(a&gt; b\\)). 1:15 ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 2.3:12.5 ## [1] 2.3 3.3 4.3 5.3 6.3 7.3 8.3 9.3 10.3 11.3 12.3 34:-5 ## [1] 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 ## [24] 11 10 9 8 7 6 5 4 3 2 1 0 -1 -2 -3 -4 -5 -3:5 #Cuidado con los paréntesis ## [1] -3 -2 -1 0 1 2 3 4 5 -(3:5) ## [1] -3 -4 -5 La función seq también se puede usar para definir progresiones aritméticas de otras dos maneras: seq(a, b, length.out=n) define la progresión aritmética de longitud \\(n\\) que va de \\(a\\) a \\(b\\); su paso es, por lo tanto, \\(p=(b-a)/(n-1)\\) si \\(n&gt;1\\); si \\(n=1\\) sólo produce el valor \\(a\\). seq(a, by=p, length.out=n) define la progresión aritmética \\[ a, a+p, a+2p, \\ldots, a+(n-1)p \\] de longitud \\(n\\) y paso \\(p\\) que empieza en \\(a\\). seq(2, 10, length.out=10) ## [1] 2.000000 2.888889 3.777778 4.666667 5.555556 6.444444 7.333333 ## [8] 8.222222 9.111111 10.000000 seq(2, by=0.5, length.out=10) ## [1] 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 A estas alturas habréis observado que cuando el resultado de una instrucción es un vector, R comienza cada línea del resultado con un número entre corchetes [ ]. Este número indica la posición dentro del vector de la primera entrada de la línea correspondiente. De esta manera, en el resultado de seq(2, 10, length.out=10), R nos indica que 2.000000 es el primer elemento de este vector y 6.444444 su sexto elemento. La función c que hemos usado para crear vectores en realidad concatena sus argumentos en un vector (de ahí viene la c). Si la aplicamos a vectores, crea un nuevo vector concatenando sus elementos. Podemos mezclar vectores y datos en su argumento. x=c(rep(1, 10), 2:10) x ## [1] 1 1 1 1 1 1 1 1 1 1 2 3 4 5 6 7 8 9 10 x=c(0,x,20,30) x ## [1] 0 1 1 1 1 1 1 1 1 1 1 2 3 4 5 6 7 8 9 10 20 30 Esta última construcción, x=c(0,x,20,30), muestra que la función c se puede usar para añadir valores al principio o al final de un vector sin cambiarle el nombre: en este caso, hemos redefinido x añadiéndole un 0 al principio y 20, 30 al final. Un vector se puede modificar fácilmente usando el editor de datos que incorpora Rstudio. Para hacerlo, se aplica la función fix al vector que queremos editar. R abre entonces el vector en una nueva ventana de edición. Mientras esta ventana esté abierta, será la ventana activa de R y no podremos volver a nuestra sesión de R hasta que la cerremos. Los cambios que hagamos en el vector con el editor de datos se guardarán cuando cerremos esta ventana. Probadlo. Cread un vector con R y abridlo en el editor. Por ejemplo: &gt; x=c(rep(1, 10), 2:10) &gt; fix(x) Se abrirá entonces una ventana como la que mostramos en la Figura 4.1. Ahora, en esta ventana, podéis añadir, borrar y cambiar los datos que queráis. Por ejemplo, añadid un 0 al principio y 20, 30 al final y guardad el resultado (pulsando &lt;&gt; en la ventana del editor). El valor de \\(x\\) se habrá modificado, como podréis comprobar entrando x en la consola. knitr::include_graphics(&quot;images/finestres0.jpg&quot;) Figura 4.1: Ventana del editor de vectores de RStudio para Mac OS X. 4.2 Operaciones con vectores El manejo de vectores con R tiene una propiedad muy útil: podemos aplicar una función a todos los elementos de un vector en un solo paso. x=seq(2, 30, by=3) x ## [1] 2 5 8 11 14 17 20 23 26 29 x+2.5 ## [1] 4.5 7.5 10.5 13.5 16.5 19.5 22.5 25.5 28.5 31.5 2.5*x ## [1] 5.0 12.5 20.0 27.5 35.0 42.5 50.0 57.5 65.0 72.5 sqrt(x) ## [1] 1.414214 2.236068 2.828427 3.316625 3.741657 4.123106 4.472136 ## [8] 4.795832 5.099020 5.385165 2^x ## [1] 4 32 256 2048 16384 131072 1048576 ## [8] 8388608 67108864 536870912 x^2 ## [1] 4 25 64 121 196 289 400 529 676 841 (1:4)^2 ## [1] 1 4 9 16 1:4^2 #Cuidado con los paréntesis ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 A veces no es posible aplicar una función concreta a todo un vector entrándolo dentro del argumento de la función, como hemos hecho en los ejemplos anteriores. En estos casos, podemos usar la instrucción sapply(vector, FUN=función). Por ejemplo, dentro de un rato veremos que la función mean calcula la media aritmética de un vector. Supongamos que definimos una función F que, aplicada a un número natural \\(x\\), calcula la media de los números \\[ 1,2,\\ldots,x. \\] F=function(x){mean(1:x)} F(20) ## [1] 10.5 F(30) ## [1] 15.5 Resulta que no podemos aplicar esta función a todas las entradas de un vector \\(x\\) entrando simplemente F(x). F(20:30) ## [1] 10.5 En casos como este, siempre podemos recurrir a la función sapply. sapply(20:30, FUN=F) ## [1] 10.5 11.0 11.5 12.0 12.5 13.0 13.5 14.0 14.5 15.0 15.5 También podemos operar término a término las entradas de dos vectores de la misma longitud. 1:5+1:5 #Suma entrada a entrada ## [1] 2 4 6 8 10 (1:5)*(1:5) #Producto entrada a entrada ## [1] 1 4 9 16 25 (1:5)^(1:5) #Potencia entrada a entrada ## [1] 1 4 27 256 3125 Esto nos permite calcular fácilmente vectores de la forma \\((x_n)_{n=p, \\ldots, q}\\), formados por los términos \\(x_p, x_{p+1}, \\ldots, x_q\\) de una sucesión \\((x_n)_n\\), a partir de la fórmula explícita de \\(x_n\\) como función del índice \\(n\\): basta aplicar esta fórmula a p:q. Por ejemplo, para definir el vector \\[ x=(3\\cdot 2^n-20)_{n=1, \\ldots, 20}, \\] podemos entrar lo siguiente: n=1:20 #Secuencia 1,...,20, y la llamamos n por comodidad x=3*2^n-20 #Aplicamos la fórmula a n=1,...,20 x ## [1] -14 -8 4 28 76 172 364 748 ## [9] 1516 3052 6124 12268 24556 49132 98284 196588 ## [17] 393196 786412 1572844 3145708 De manera similar, para definir el vector \\[ y=\\Big(\\dfrac{n}{n^2+1}\\Big)_{n=0, \\ldots, 20}, \\] podemos usar lo siguiente: n=0:20 y=n/(n^2+1) y ## [1] 0.00000000 0.50000000 0.40000000 0.30000000 0.23529412 0.19230769 ## [7] 0.16216216 0.14000000 0.12307692 0.10975610 0.09900990 0.09016393 ## [13] 0.08275862 0.07647059 0.07106599 0.06637168 0.06225681 0.05862069 ## [19] 0.05538462 0.05248619 0.04987531 En ambos casos, y para facilitar la visualización de la construcción, hemos creado el vector \\(n\\) con los índices de los términos de la sucesión, y después hemos obtenido el trozo de sucesión deseado aplicando la función que la define a \\(n\\). También habríamos podido generar estos vectores escribiendo directamente la sucesión de índices en la fórmula que los define. Por ejemplo: (0:20)/((0:20)^2+1) ## [1] 0.00000000 0.50000000 0.40000000 0.30000000 0.23529412 0.19230769 ## [7] 0.16216216 0.14000000 0.12307692 0.10975610 0.09900990 0.09016393 ## [13] 0.08275862 0.07647059 0.07106599 0.06637168 0.06225681 0.05862069 ## [19] 0.05538462 0.05248619 0.04987531 R dispone de muchas funciones para aplicar a vectores, relacionadas principalmente con la estadística. Veamos algunas que nos pueden ser útiles por el momento, y ya iremos viendo otras a medida que avance el curso: length calcula la longitud del vector. max y min calculan sus valores máximo y mínimo, respectivamente. sum calcula la suma de sus entradas. prod calcula el producto de sus entradas. mean calcula la media aritmética de sus entradas. diff calcula el vector formado por las diferencias sucesivas entre entradas del vector original. cumsum calcula el vector formado por las sumas acumuladas de las entradas del vector original: cada entrada de cumsum(x) es la suma de las entradas de x hasta su posición. sort ordena los elementos del vector en el orden natural creciente del tipo de datos que lo forman: el orden numérico, el orden alfabético, etc. Si lo queremos ordenar en orden decreciente, podemos incluir en su argumento el parámetro dec=TRUE. rev invierte el orden de los elementos del vector; por lo tanto, rev(sort(...)) es otra opción para ordenar en orden decreciente. x=c(1,5,6,2,5,7,8,3,5,2,1,0) length(x) ## [1] 12 max(x) ## [1] 8 min(x) ## [1] 0 sum(x) ## [1] 45 prod(x) ## [1] 0 mean(x) ## [1] 3.75 cumsum(x) ## [1] 1 6 12 14 19 26 34 37 42 44 45 45 diff(x) ## [1] 4 1 -4 3 2 1 -5 2 -3 -1 -1 sort(x) ## [1] 0 1 1 2 2 3 5 5 5 6 7 8 sort(x, dec=TRUE) ## [1] 8 7 6 5 5 5 3 2 2 1 1 0 rev(x) ## [1] 0 1 2 5 3 8 7 5 2 6 5 1 La función sum es útil para evaluar sumatorios; por ejemplo, si queremos calcular \\[\\displaystyle\\sum_{n=0}^{200} \\frac{1}{n^2+1}, \\] sólo tenemos que entrar: n=0:200 sum(1/(n^2+1)) ## [1] 2.071687 La función cumsum permite definir sucesiones descritas mediante sumatorios; a modo de ejemplo, para definir el vector \\[ y=\\Big(\\sum_{i=0}^n 2^{-i}\\Big)_{n=0, \\ldots, 20}, \\] basta aplicar cumsum al vector \\(x=(2^{-i})_{i=0, \\ldots, 20}\\) de la manera siguiente: i=0:20 x=2^(-i) y=cumsum(x) y ## [1] 1.000000 1.500000 1.750000 1.875000 1.937500 1.968750 1.984375 ## [8] 1.992188 1.996094 1.998047 1.999023 1.999512 1.999756 1.999878 ## [15] 1.999939 1.999969 1.999985 1.999992 1.999996 1.999998 1.999999 Observamos que esta sucesión tiende a 2, lo que corresponde a la igualdad \\[ \\sum_{k=0}^\\infty \\frac{1}{2^k}=\\frac{1}{1-\\frac{1}{2}}=2. \\] 4.3 Entradas y trozos de vectores Si queremos extraer el valor de una entrada concreta de un vector, o si queremos referirnos a esta entrada para usarla en un cálculo, podemos emplear la construcción vector[i], que indica la \\(i\\)-ésima entrada del vector. En particular, vector[length(vector)-i] es la \\((i+1)\\)-ésima entrada del vector empezando por el final: su última entrada es vector[length(vector)], la penúltima es vector[length(vector)-1] y así sucesivamente. Observad que para referirnos a elementos de un vector, empleamos corchetes [ ], y no los paréntesis redondos usuales. x=seq(2, 50, by=1.5) x ## [1] 2.0 3.5 5.0 6.5 8.0 9.5 11.0 12.5 14.0 15.5 17.0 18.5 20.0 21.5 ## [15] 23.0 24.5 26.0 27.5 29.0 30.5 32.0 33.5 35.0 36.5 38.0 39.5 41.0 42.5 ## [29] 44.0 45.5 47.0 48.5 50.0 x(3) #¿La tercera entrada del vector? Error: could not find function &quot;x&quot; x[3] #La tercera entrada del vector, ahora sí ## [1] 5 x[length(x)] #La última entrada del vector ## [1] 50 x[length(x)-5] #La sexta entrada del vector empezando por el final ## [1] 42.5 También podemos extraer subvectores de un vector. Una primera manera de obtener un subvector es especificando los índices de las entradas que lo han de formar: vector[y], donde y es un vector (de índices), crea un nuevo vector con las entradas del vector original cuyos índices pertenecen a y. En particular, si \\(a\\) y \\(b\\) son dos números naturales, vector[a:b] crea un nuevo vector con las entradas del vector original que van de la \\(a\\)-ésima a la \\(b\\)-ésima. vector[-y], donde y es un vector (de índices), es el complementario de vector[y]: sus entradas son las del vector original cuyos índices no pertenecen a y. En particular, vector[-i] borra la entrada \\(i\\)-ésima del vector original. Veamos algunos ejemplos: n=1:10 x=2*3^n-5*n^3*2^n x ## [1] -4 -142 -1026 -4958 -19514 -67662 -215146 ## [8] -642238 -1826874 -5001902 x[-3] #x sin la tercera entrada ## [1] -4 -142 -4958 -19514 -67662 -215146 -642238 -1826874 ## [9] -5001902 x[3:7] #Los elementos tercero a séptimo de x ## [1] -1026 -4958 -19514 -67662 -215146 x[7:3] #Los elementos séptimo a tercero de x ## [1] -215146 -67662 -19514 -4958 -1026 x[seq(1, length(x), by=2)] #Los elementos de índice impar de x ## [1] -4 -1026 -19514 -215146 -1826874 x[seq(2, length(x), by=2)] #Los elementos de índice par ## [1] -142 -4958 -67662 -642238 -5001902 x[-seq(1, length(x), by=2)] #Si borramos los elementos de índice impar, quedan los de índice par ## [1] -142 -4958 -67662 -642238 -5001902 x[(length(x)-5):length(x)] #Los últimos 6 elementos de x ## [1] -19514 -67662 -215146 -642238 -1826874 -5001902 x[length(x)-5:length(x)] #No os dejéis los paréntesis ... ## [1] -19514 -4958 -1026 -142 -4 Fijaos en las dos últimas instrucciones: si \\(n=\\texttt{length(x)}\\), \\(\\texttt{(length(x)-5):length(x)}\\) es la secuencia de índices \\[ n-5, n-4, n-3, n-2, n-1, n; \\] en cambio, \\(\\texttt{length(x)-5:length(x)}\\) es la secuencia \\[ n-(5, 6, 7, \\ldots, n)=n-5, n-6, n-7, \\ldots, 1, 0. \\] Tabla 4.1: Operadores lógicos Operador \\(=\\) \\(\\neq\\) \\(&lt;\\) \\(&gt;\\) \\(\\leq\\) \\(\\geq\\) negación conjunción disjunción Signo == != &lt; &gt; &lt;= &gt;= ! &amp; | También podemos extraer las entradas de un vector (o sus índices) que satisfagan alguna condición. Los operadores lógicos que podemos usar para definir estas condiciones son los que damos en la Tabla 4.1. Veamos algunos ejemplos (y observad su sintaxis): x=c(1,5,6,2,5,7,8,3,5,2,1,0) x[x&gt;3] #Elementos mayores que 3 ## [1] 5 6 5 7 8 5 x[x&gt;2 &amp; x&lt;=5] #Elementos mayores que 2 y menores o iguales que 5 ## [1] 5 5 3 5 x[x!=2 &amp; x!=5] #Elementos diferentes de 2 y de 5 ## [1] 1 6 7 8 3 1 0 x[x&gt;5 | x&lt;=2] #Elementos mayores que 5 o menores o iguales que 2 ## [1] 1 6 2 7 8 2 1 0 x[x&gt;=4] #Elementos mayores o iguales que 4 ## [1] 5 6 5 7 8 5 x[!x&lt;4] #Elementos que NO son menores que 4; es equivalente a la anterior ## [1] 5 6 5 7 8 5 x[x%%4==0] #Elementos múltiplos de 4 ## [1] 8 0 Analicemos la segunda instrucción, x[x&gt;3]. La construcción x&gt;3 define un vector que, en cada posición, contiene un TRUE si el elemento correspondiente del vector x es mayor que 3 y un FALSE si no lo es. x&gt;3 ## [1] FALSE TRUE TRUE FALSE TRUE TRUE TRUE FALSE TRUE FALSE FALSE ## [12] FALSE Entonces x[x&gt;3] lo que nos da son las entradas del vector x correspondientes a los TRUE de este vector de valores lógicos. x[x&gt;3] ## [1] 5 6 5 7 8 5 Esta construcción también permite extraer las entradas de un vector cuyos índices sean los de las entradas de otro vector que satisfagan una condición lógica. Por ejemplo: x=c(1,5,6,2,5,7,8,3,5,2,1,0) y=c(2,-3,0,1,2,-1,4,-1,-2,3,5,1) x[y&gt;0] #Entradas de x correspondientes a entradas positivas de y ## [1] 1 2 5 8 2 1 0 Para obtener los índices de las entradas del vector que satisfacen una condición dada, podemos usar la función which. Esta función, aplicada a un vector de valores lógicos, da los índices de las posiciones de los TRUE. Así, para saber los índices de las entradas de x que son mayores que 3, usamos which(x&gt;3), que nos dará los índices de las entradas TRUE del vector x&gt;3. x=c(1,5,6,2,5,7,8,3,5,2,1) x ## [1] 1 5 6 2 5 7 8 3 5 2 1 x[x&gt;3] #Elementos mayores que 3 ## [1] 5 6 5 7 8 5 which(x&gt;3) #Índices de los elementos mayores que 3 ## [1] 2 3 5 6 7 9 which(x&gt;2 &amp; x&lt;=5) #Índices de los elementos &gt; 2 y &lt;= 5 ## [1] 2 5 8 9 which(x!=2 &amp; x!=5) #Índices de los elementos diferentes de 2 y 5 ## [1] 1 3 6 7 8 11 which(x&gt;5 | x&lt;=2) #Índices de los elementos &gt; 5 o &lt;= 2 ## [1] 1 3 4 6 7 10 11 which(x%%2==0) #Índices de los elementos pares del vector ## [1] 3 4 7 10 La instrucción which.min(x) nos da la primera posición en la que el vector toma su valor mínimo; which.max(x) hace lo mismo, pero para el máximo. En cambio, con which(x==min(x)) obtenemos todas las posiciones en las que el vector toma su valor mínimo y, con which(x==max(x)), aquellas en las que toma su valor máximo. x ## [1] 1 5 6 2 5 7 8 3 5 2 1 which.min(x) ## [1] 1 which(x==min(x)) ## [1] 1 11 Si un vector no contiene ningún término que satisfaga la condición que imponemos, obtenemos como respuesta un vector vacío. R lo indica con numeric(0) si es de números, character(0) si es de palabras, o integer(0) si es de índices de entradas de un vector. Estos vectores vacíos tienen longitud, naturalmente, 0. x=2^(0:10) x ## [1] 1 2 4 8 16 32 64 128 256 512 1024 x[20&lt;x &amp; x&lt;30] #Elementos de x estrictamente entre 20 y 30 ## numeric(0) length(x[20&lt;x &amp; x&lt;30]) #¿Cuántas entradas hay entre 20 y 30? ## [1] 0 which(x&gt;1500) #Índices de elementos mayores que 1500 ## integer(0) Si R no sabe de qué tipo son los datos que faltan en un vector vacío, lo indica con NULL. También podemos usar este valor para definir un vector vacío. x=c() x ## NULL z=NULL z ## NULL y=c(x, 2, z) y ## [1] 2 Los operadores lógicos que hemos explicado también se pueden usar para pedir si una condición sobre unos números concretos se satisface o no. Por ejemplo: exp(pi)&gt;pi^(exp(1)) #¿Es mayor e^pi que pi^e? ## [1] TRUE 1234567%%9==0 #¿Es 1234567 múltiplo de 9? ## [1] FALSE Podemos modificar algunas entradas de un vector simplemente declarando sus nuevos valores. Esto se puede hacer entrada a entrada, o para todo un subvector de golpe. x=1:10 x ## [1] 1 2 3 4 5 6 7 8 9 10 x[3]=15 #En la posición 3 escribimos 15 x[11]=25 #Añadimos en la posición 11 un 25 x ## [1] 1 2 15 4 5 6 7 8 9 10 25 x[c(2, 3, 4)]=x[c(2, 3, 4)]+10 #Sumamos 10 a las entradas en las posiciones 2, 3 y 4 x ## [1] 1 12 25 14 5 6 7 8 9 10 25 x[(length(x)-2):length(x)]=0 #Igualamos las últimas tres entradas a 0 x ## [1] 1 12 25 14 5 6 7 8 0 0 0 x[length(x)+3]=2 x ## [1] 1 12 25 14 5 6 7 8 0 0 0 NA NA 2 Fijaos en la última instrucción. Hemos añadido al vector x el valor 2 tres posiciones más allá de su última entrada. Entonces, en las posiciones 12 y 13 ha escrito NA antes de añadir en la 14 el 2. Estos NA, de Not Available , indican que las entradas correspondientes del vector no existen. Los NA serán muy importantes cuando usemos vectores en estadística descriptiva, donde podrán representar valores desconocidos, errores, etc. Serán importantes porque son molestos, puesto que, por norma general, una función aplicada a un vector que contenga algún NA da NA. sum(x) ## [1] NA mean(x) ## [1] NA Afortunadamente, muchas de las funciones para vectores admiten un parámetro na.rm que, igualado a TRUE, hace que la función sólo tenga en cuenta las entradas definidas.} sum(x, na.rm=TRUE) ## [1] 80 mean(x, na.rm=TRUE) ## [1] 6.666667 Para extraer las entradas no definidas de un vector \\(x\\) no podemos usar la condición lógica x==NA, sino la función is.na(x). x ## [1] 1 12 25 14 5 6 7 8 0 0 0 NA NA 2 which(x==NA) #¿Índices de entradas NA? ## integer(0) is.na(x) ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [12] TRUE TRUE FALSE which(is.na(x)) #Índices de entradas NA ## [1] 12 13 y=x #Creamos una copia de x y la llamamos y y[is.na(y)]=mean(y, na.rm=TRUE) #Cambiamos los NA de y por la media del resto de entradas y ## [1] 1.000000 12.000000 25.000000 14.000000 5.000000 6.000000 7.000000 ## [8] 8.000000 0.000000 0.000000 0.000000 6.666667 6.666667 2.000000 Naturalmente, podemos usar la negación de is.na(x) para obtener las entradas definidas de un vector x: formarán el vector x[!is.na(x)]. x ## [1] 1 12 25 14 5 6 7 8 0 0 0 NA NA 2 x[!is.na(x)] ## [1] 1 12 25 14 5 6 7 8 0 0 0 2 sum(x[!is.na(x)]) ## [1] 80 cumsum(x) ## [1] 1 13 38 52 57 63 70 78 78 78 78 NA NA NA cumsum(x, na.rm=TRUE) #cumsum no admite na.rm Error in cumsum(x, na.rm = TRUE) : 2 arguments passed to &#39;cumsum&#39; which requires 1 cumsum(x[!is.na(x)]) ## [1] 1 13 38 52 57 63 70 78 78 78 78 80 Las entradas no definidas de un vector también se pueden borrar aplicándole la función na.omit. na.omit(x) ## [1] 1 12 25 14 5 6 7 8 0 0 0 2 ## attr(,&quot;na.action&quot;) ## [1] 12 13 ## attr(,&quot;class&quot;) ## [1] &quot;omit&quot; sum(na.omit(x)) ## [1] 80 cumsum(na.omit(x)) ## [1] 1 13 38 52 57 63 70 78 78 78 78 80 Observad el resultado de na.omit(x). Contiene un primer vector formado por las entradas del vector original que no son NA, y luego una serie de información extra llamados atributos , e indicados por R con attr: los índices de las entradas que ha eliminado y el tipo de acción que ha llevado a cabo. Como podéis ver, estos atributos no interfieren para nada en las operaciones que se realicen con el primer vector, pero si os molestan, se pueden eliminar: la instrucción attr(objeto , atributo)=NULL borra el atributo del objeto . x_sinNA=na.omit(x) x_sinNA ## [1] 1 12 25 14 5 6 7 8 0 0 0 2 ## attr(,&quot;na.action&quot;) ## [1] 12 13 ## attr(,&quot;class&quot;) ## [1] &quot;omit&quot; attr(x_sinNA, &quot;na.action&quot;)=NULL attr(x_sinNA, &quot;class&quot;)=NULL x_sinNA ## [1] 1 12 25 14 5 6 7 8 0 0 0 2 4.4 Factores Un factores como un vector, pero con una estructura interna más rica que permite usarlo para clasificar observaciones. Para ilustrar la diferencia entre vectores y factores, vamos a crear un vector Ciudades con los nombres de algunas ciudades, y a continuación un factor Ciudades.factor con el mismo contenido, aplicando a este vector la función factor. Ciudades=c(&quot;Madrid&quot;,&quot;Palma&quot;,&quot;Madrid&quot;,&quot;Madrid&quot;,&quot;Barcelona&quot;, &quot;Palma&quot;,&quot;Madrid&quot;,&quot;Madrid&quot;) Ciudades ## [1] &quot;Madrid&quot; &quot;Palma&quot; &quot;Madrid&quot; &quot;Madrid&quot; &quot;Barcelona&quot; &quot;Palma&quot; ## [7] &quot;Madrid&quot; &quot;Madrid&quot; Ciudades.factor=factor(Ciudades) Ciudades.factor ## [1] Madrid Palma Madrid Madrid Barcelona Palma Madrid ## [8] Madrid ## Levels: Barcelona Madrid Palma Observad la diferencia. El factor dispone de un atributo especial llamado niveles (levels), y cada elemento del factor es igual a un nivel; de esta manera, los niveles &lt;&gt; las entradas del factor. Podríamos decir, en resumen, que un factor es una lista formada por copias de etiquetas (los niveles), como podrían ser el sexo o la especie de unos individuos. Cuando tengamos un vector que queramos usar para clasificar datos, conviene definirlo como un factor y así podremos hacer más cosas con él. Para crear un factor, hemos de definir un vector y transformarlo en factor por medio de una de las funciones factor o as.factor. La diferencia entre estas funciones es que as.factor &lt;&gt; el vector en un factor, y toma como sus niveles los diferentes valores que aparecen en el vector, mientras que factor &lt;&gt; un factor a partir del vector, y dispone de algunos parámetros que permiten modificar el factor que se crea, tales como: levels, que permite especificar los niveles e incluso añadir niveles que no aparecen en el vector. labels, que permite cambiar los nombres de los niveles. De esta manera, con as.factor o con factor sin especificar levels, el factor tendrá como niveles los diferentes valores que toman las entradas del vector, y además aparecerán en su lista de niveles, Levels, ordenados en orden alfabético. Si especificamos el parámetro levels en la función factor, los niveles aparecerán en dicha lista en el orden en el que los entremos en él. S=c(&quot;M&quot;,&quot;M&quot;,&quot;F&quot;,&quot;M&quot;,&quot;F&quot;,&quot;F&quot;,&quot;F&quot;,&quot;M&quot;,&quot;M&quot;,&quot;F&quot;) Sex=as.factor(S) Sex ## [1] M M F M F F F M M F ## Levels: F M Sex2=factor(S) #Esto definirá el mismo factor Sex2 ## [1] M M F M F F F M M F ## Levels: F M Sex3=factor(S, levels=c(&quot;M&quot;,&quot;F&quot;,&quot;B&quot;)) #Si queremos añadir un nuevo nivel &quot;B&quot; y cambiar el orden de los niveles Sex3 ## [1] M M F M F F F M M F ## Levels: M F B Sex4=factor(S, levels=c(&quot;M&quot;,&quot;F&quot;,&quot;B&quot;), labels=c(&quot;Masc&quot;,&quot;Fem&quot;,&quot;Bisex&quot;)) #Si queremos cambiar los nombres Sex4 ## [1] Masc Masc Fem Masc Fem Fem Fem Masc Masc Fem ## Levels: Masc Fem Bisex Para obtener los niveles de un factor, podemos emplear la función levels. levels(Sex) ## [1] &quot;F&quot; &quot;M&quot; levels(Sex4) ## [1] &quot;Masc&quot; &quot;Fem&quot; &quot;Bisex&quot; Esta función levels también permite cambiar los nombres de los niveles de un factor. Notas=as.factor(c(1,2,2,3,1,3,2,4,2,3,4,2)) Notas ## [1] 1 2 2 3 1 3 2 4 2 3 4 2 ## Levels: 1 2 3 4 levels(Notas)=c(&quot;Muy.mal&quot;,&quot;Mal&quot;,&quot;Bien&quot;,&quot;Muy.bien&quot;) Notas ## [1] Muy.mal Mal Mal Bien Muy.mal Bien Mal ## [8] Muy.bien Mal Bien Muy.bien Mal ## Levels: Muy.mal Mal Bien Muy.bien Observad que los niveles han heredado el orden del factor original. Con la función levels también podemos agrupar varios niveles de un factor en uno solo, simplemente repitiendo nombres al especificarlos; por ejemplo, en el factor de notas anterior, vamos a agrupar los niveles &lt;&gt; y &lt;&gt; en uno solo, y lo mismo con los niveles &lt;&gt; y &lt;&gt;: Notas_2niv=Notas levels(Notas_2niv)=c(&quot;Mal&quot;,&quot;Mal&quot;,&quot;Bien&quot;,&quot;Bien&quot;) Notas_2niv ## [1] Mal Mal Mal Bien Mal Bien Mal Bien Mal Bien Bien Mal ## Levels: Mal Bien Nos hemos referido varias veces al orden de los niveles. En realidad, hay dos tipos de factores: simples y ordenados. Hasta ahora sólo hemos considerado los factores simples, en los que el orden de los niveles realmente no importa, y si lo modificamos es sólo por razones estéticas o de comprensión de los datos; en este caso, la manera más sencilla de hacerlo es redefiniendo el factor con factor y modificando en el parámetro levels el orden de los niveles. Pero si el orden de los niveles es relevante para analizar los datos, entonces es conveniente definir el factor como ordenado . Esto se lleva a cabo con la función ordered, que dispone de los mismos parámetros que factor. Así, si queremos que nuestro factor Notas sea un factor ordenado, con sus niveles ordenados de &lt;&gt; a &lt;&gt;, hay que entrar lo siguiente: Notas=ordered(Notas, levels=c(&quot;Muy.mal&quot;,&quot;Mal&quot;,&quot;Bien&quot;,&quot;Muy.bien&quot;)) Notas ## [1] Muy.mal Mal Mal Bien Muy.mal Bien Mal ## [8] Muy.bien Mal Bien Muy.bien Mal ## Levels: Muy.mal &lt; Mal &lt; Bien &lt; Muy.bien Observad que R indica el orden de los niveles de un factor ordenado mediante el signo &lt;. Aunque en la instrucción anterior hemos aplicado la función ordered a un factor, también se puede aplicar a un vector, como si usáramos factor. 4.5 Listas heterogéneas Los vectores que hemos estudiado hasta el momento sólo pueden contener datos, y estos datos han de ser de un solo tipo. Por ejemplo, no podemos construir un vector que contenga simultáneamente palabras y números, o cuyas entradas sean a su vez vectores. Este problema se resuelve con las listas heterogéneas ; para abreviar, las llamaremos por su nombre en R: list. Una list es una lista formada por objetos que pueden ser de clases diferentes. Así, en una misma list podemos combinar números, palabras, vectores, otras list, etc. En la Lección 3 ya aparecieron dos objetos de clase list: los resultados de lm(...) y summary(lm(...)). Supongamos por ejemplo que queremos guardar en una lista un vector, su nombre, su media, y su vector de sumas acumuladas. En este caso, tendríamos que hacerlo en forma de lista heterogénea usando la función list. x=c(1,2,-3,-4,5,6) L=list(nombre=&quot;x&quot;,vector=x,media=mean(x),sumas=cumsum(x)) L ## $nombre ## [1] &quot;x&quot; ## ## $vector ## [1] 1 2 -3 -4 5 6 ## ## $media ## [1] 1.166667 ## ## $sumas ## [1] 1 3 0 -4 1 7 Observad la sintaxis de la función list: le hemos entrado como argumento los diferentes objetos que van a formar la lista heterogénea, poniendo a cada uno un nombre adecuado. Este nombre es &lt;&gt; de la list: por ejemplo, pese a que dentro de la lista hemos definido un objeto llamado sumas, en el entorno de trabajo de R no tenemos definida ninguna variable con ese nombre (a no ser que la hayamos definido previamente durante la sesión). &gt; sumas Error: object &#39;sumas&#39; not found Para obtener una componente concreta de una list, tenemos que añadir al nombre de la list el sufijo formado por un signo $ y el nombre de la componente; recordad cómo extraíamos el valor de \\(R^2\\) de un summary(lm(\\ldots)) o (en el contexto de los data frame) cómo extraíamos una columna de un data frame en la página . L$nombre ## [1] &quot;x&quot; L$vector ## [1] 1 2 -3 -4 5 6 L$media ## [1] 1.166667 También podemos indicar el objeto por su posición en la list usando un par de dobles corchetes [[ ]]. Si usamos sólo un par de corchetes, como en los vectores, lo que obtenemos es una list formada por esa única componente, no el objeto que forma la componente. L[[1]] ## [1] &quot;x&quot; L[[4]] #Esto es un vector ## [1] 1 3 0 -4 1 7 3*L[[4]] #Y podemos operar con él ## [1] 3 9 0 -12 3 21 L[4] #Esto es una list, no un vector ## $sumas ## [1] 1 3 0 -4 1 7 &gt; 3*L[4] #Y NO podemos operar con él Error in 3 * L[4] : non-numeric argument to binary operator Para conocer la estructura interna de una list, es decir, los nombres de los objetos que la forman y su naturaleza, podemos usar la función str. Si sólo queremos saber sus nombres, podemos usar la función names. Si la list se obtiene con una función de R cuyo resultado sea una estructura de este tipo, como, por ejemplo, lm, es recomendable consultar la Ayuda de la función, ya que probablemente explique el significado de los objetos que la forman. str(L) ## List of 4 ## $ nombre: chr &quot;x&quot; ## $ vector: num [1:6] 1 2 -3 -4 5 6 ## $ media : num 1.17 ## $ sumas : num [1:6] 1 3 0 -4 1 7 names(L) ## [1] &quot;nombre&quot; &quot;vector&quot; &quot;media&quot; &quot;sumas&quot; 4.6 Guía rápida de funciones c sirve para definir un vector concatenando elementos o vectores. scan crea un vector importando datos que se entren en la consola o contenidos en un fichero. Algunos parámetros importantes: dec: indica el separador decimal. sep: indica el signo usado para separar las entradas. what: indica el tipo de datos que se importan. encoding: indica la codificación de alfabeto del fichero externo; sus dos valores posibles son &quot;latin1&quot; y &quot;UTF-8&quot;. rep sirve para definir un vector repitiendo un valor o las entradas de otro vector. Algunos parámetros importantes: each: cuando aplicamos la función a un vector, sirve para indicar cuántas veces queremos repetir cada entrada del vector. times: cuando aplicamos la función a un vector, sirve para indicar cuántas veces queremos repetir todo el vector en bloque. seq se puede usar para definir progresiones aritméticas. Algunos parámetros importantes: by: el paso de la progresión. length.out: la longitud de la progresión. Estos parámetros se pueden usar de las maneras siguientes: seq(a, b, by=p) define la progresión \\[ a, a+p, a+2p, \\ldots, b \\] (o parándose en el término inmediatamente anterior a \\(b\\), si \\(b\\) no pertenece a la progresión). seq(a, b, length.out=n) define la progresión \\[ a, a+p, a+2p, \\ldots, b \\] tomando como paso \\(p=(b-a)/(n-1)\\). seq(a, by=p, length.out=n) define la progresión \\[ a, a+p, a+2p, \\ldots, a+(n-1)p. \\] a:b es sinónimo de seq(a, b, by=1) (si \\(a&lt;b\\)) o seq(a, b, by=-1) (si \\(a&gt;b\\)). NULL indica un vector vacío. fix abre un vector (o, en general, un objeto de datos: una matriz, un data frame ) en el editor de datos. Funciones para vectores: Función longitud máximo mínimo suma producto Signo length max min sum prod Función media sumas acumuladas diferencias ordenar invertir el orden Signo media cumsum diff sort rev Las funciones max, min, sum, prod y mean admiten el parámetro siguiente: +na.rm: igualado a TRUE, impone que no se tengan en cuenta los valores NA del vector al calcularla. sapply(``vector , FUN=``función ) aplica la función a todas las entradas del vector . vector[...] se usa para especificar un elemento o un subvector del vector . Las entradas que formarán el subvector pueden especificarse mediante el vector de sus índices o mediante una condición lógica sobre las entradas. Los signos de operadores lógicos que se pueden usar para definir condiciones lógicas son los siguientes: Operador \\(=\\) \\(\\neq\\) \\(&lt;\\) \\(&gt;\\) \\(\\leq\\) \\(\\geq\\) negación conjunción disjunción Signo == != &lt; &gt; &lt;= &gt;= ! &amp; | which sirve para obtener los índices de las entradas de un vector que satisfacen una condición lógica. which.min y which.max dan la primera posición en la que el vector toma su valor mínimo o máximo, respectivamente. is.na es la alternativa correcta a la condición ==NA. na.omit elimina las entradas NA de un vector. as.factor transforma un vector en un factor. factor crea un factor a partir de un vector. Algunos parámetros importantes: +levels: sirve para especificar los niveles. +labels: sirve para cambiar los nombres de los niveles. ordered crea un factor ordenado a partir de un vector o un factor; sus parámetros son los mismos que los de factor. levels sirve para obtener los niveles de un factor, y también para cambiar sus nombres. list construye listas heterogéneas. str sirve para obtener la estructura de una list. names sirve para conocer los nombres de las componentes de una list. list$componente sirve para referirnos al objeto que forma la componente de la list. list[[i]] sirve para referirnos al objeto que forma la \\(i\\)-ésima componente de la list. 4.7 Ejercicio Tenemos las siguientes notas obtenidas por unos estudiantes en un examen: 7.9, 4.3, 5.5, 7.9, 9.8, 2.7, 4.7, 2.4, 8.3, 7.3, 6.8, 6.3, 4.8, 5.7, 3.8, 6.3, 5.4, 5.4, 80, 4.2, 8.3, 4.7, 6.0, 6.8, 5.7, 6.5, 4.6, 5.4, 3.7, 7.1, 5.5, 6.0, 6.7, 7.0, 7.3, 3.0, 6.6, 6.1, 2.4, 7.1, 9.4, 3.7, 4.5, 5.1, 5.9, 4.7, 5.5, 8.9, 8.1, 8.3, 4.3, 7.1, 9.3, 5.1, 6.1, 3.0, 5.7, 6.8, 3.1, 7.7, 7.3 , 7.0, 6.2, 8.8, 5.3, 4.0. Cread un vector con estas notas (podéis copiarlas de este documento y pegarlas) y ponedle un nombre adecuado. ¿Cuántas notas contiene este vector? ¿Cuál es su valor medio? ¡Vaya! El 80 ha sido un error, tenía que ser un 8.0. Cambiad el 80 del vector anterior por un 8.0, sin volver a entrar el resto de notas. Volved a calcular la media de las notas tras haber corregido este error. ¿Cuál es la nota mínima obtenida por estos estudiantes? ¿Cuántos estudiantes la han sacado? ¿Cuántos estudiantes han logrado un notable (entre 7 y 8.9)? ¿Qué porcentaje del total de estudiantes representan? ¿Qué grupo es más numeroso: el de los estudiantes que han sacado entre 4 y 4.9, o el de los que han sacado entre 5 y 5.9? Ordenad en orden creciente estas notas y obtened su mediana : una vez ordenado el vector, si tiene un número impar de entradas, su mediana es el valor central, y si tiene un número par de entradas, su mediana es la media aritmética de los dos valores centrales. La mediana de un vector se puede calcular directamente con la función median. Calculad la del vector anterior con esta función. ¿Da lo mismo que el valor obtenido en el punto anterior? ¿Cuántos notas diferentes hay en esta muestra? (Podéis emplear astutamente algunas funciones explicadas en esta lección, o podéis consultar help.search(&quot;duplicated&quot;) a ver si encontráis una función que elimine las entradas duplicadas de un vector.) Con el editor de textos hemos copiado la secuencia, y hemos pulsado Entrar después de cada pegado. Probadlo vosotros.↩ "],
["chap-matrix.html", "Lección 5 Matrices 5.1 Construcción de matrices 5.2 Acceso a entradas y submatrices 5.3 Algunas funciones para matrices 5.4 Cálculo matricial (opcional) 5.5 Valores y vectores propios (opcional) 5.6 Matrices complejas (opcional) 5.7 Guía rápida de funciones 5.8 Ejercicio (opcional)", " Lección 5 Matrices Una matriz de orden \\(n\\times m\\) es una tabla rectangular de números (o, en algunas situaciones específicas, algún otro tipo de datos: valores lógicos, etiquetas…) formada por \\(n\\) filas y \\(m\\) columnas. Una matriz es cuadrada cuando tiene el mismo número de filas que de columnas, es decir, cuando \\(n=m\\); en este caso, decimos que la matriz es de orden \\(n\\). En matemáticas, es costumbre escribir las matrices rodeadas por paréntesis para marcar con claridad sus límites. Por ejemplo, \\[ A = \\left(\\begin{matrix} 2 &amp; 1 &amp; -3\\\\ -4 &amp; 3 &amp; \\sqrt{3}\\end{matrix} \\right) \\] es una matriz \\(2\\times 3\\). 5.1 Construcción de matrices Disponemos de dos maneras básicas de definir una matriz en R. En primer lugar, la instrucción matrix(vector , nrow=n, byrow=valor_lógico) define una matriz de \\(n\\) filas (rows) formada por las entradas del vector . Si se entra byrow=TRUE, la matriz se construye por filas, mientras que con byrow=FALSE se construye por columnas; este último es el valor por defecto, por lo que no hace falta especificarlo. En vez de emplear nrow, se puede indicar el número de columnas con ncol. Veamos algunos ejemplos: matrix(1:6, nrow=2) ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 matrix(1:6, nrow=3) ## [,1] [,2] ## [1,] 1 4 ## [2,] 2 5 ## [3,] 3 6 matrix(1:6, nrow=2, byrow=TRUE) ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 matrix(1:6, nrow=3, byrow=TRUE) ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 ## [3,] 5 6 Observad cómo muestra R las matrices: indica las filas con [i,], donde \\(i\\) es el índice de la fila, y las columnas con [,j], donde \\(j\\) es el índice de la columna. Para construir una matriz de \\(n\\) filas o \\(n\\) columnas, es conveniente que la longitud del vector al que se aplica matrix sea múltiplo de \\(n\\). Si no es así, R rellena la última fila o columna con entradas del principio del vector y emite un mensaje de advertencia. &gt; matrix(1:6, nrow=4) #6 no es múltiplo de 4 [,1] [,2] [1,] 1 5 [2,] 2 6 [3,] 3 1 [4,] 4 2 Warning message: In matrix(1:6, nrow = 4) : data length [6] is not a sub-multiple or multiple of the number of rows [4] En particular, se puede definir una matriz constante aplicando la función matrix a un número. En este caso, se han de usar los parámetros nrow y ncol para especificar el orden de la matriz. matrix(1, nrow=2, ncol=3) #Matriz constante 1 de orden 2x3 ## [,1] [,2] [,3] ## [1,] 1 1 1 ## [2,] 1 1 1 Otra posible manera de definir matrices es combinando filas o columnas. La instrucción rbind(vector1, vector2, ....) construye la matriz de filas vector1, vector2,… (que han de tener la misma longitud) en este orden. Si en lugar de rbind se usa cbind, se obtiene la matriz cuyas columnas son los vectores a los que se aplica. rbind(c(1,0,2),c(2,3,6),c(1,2,0)) ## [,1] [,2] [,3] ## [1,] 1 0 2 ## [2,] 2 3 6 ## [3,] 1 2 0 cbind(c(1,0,2),c(2,3,6),c(1,2,0)) ## [,1] [,2] [,3] ## [1,] 1 2 1 ## [2,] 0 3 2 ## [3,] 2 6 0 Con las funciones cbind o rbind también podemos añadir columnas, o filas, a una matriz; en concreto, si \\(A\\) es una matriz de orden \\(n\\times m\\) y \\(v\\) es un vector de longitud \\(n\\), la instrucción cbind(A, v) define la matriz de orden \\(n\\times(m+1)\\) que tiene como primeras \\(m\\) columnas las de \\(A\\) y como columna \\(m+1\\) el vector \\(v\\); de manera similar, cbind(v, A) define la matriz de orden \\(n\\times(m+1)\\) que tiene como primera columna el vector \\(v\\) y después las columnas de \\(A\\). Con cbind también podemos concatenar por columnas dos matrices con el mismo número de filas. La instrucción rbind es similar a cbind, pero actúa por filas en vez de por columnas: permite añadir filas arriba o abajo de una matriz ya existente, y, en general, concatenar por filas dos matrices con el mismo número de columnas. A=matrix(c(1,2,3,4), nrow=2) A ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 cbind(c(7,8),c(5,6),A) ## [,1] [,2] [,3] [,4] ## [1,] 7 5 1 3 ## [2,] 8 6 2 4 cbind(A,A) ## [,1] [,2] [,3] [,4] ## [1,] 1 3 1 3 ## [2,] 2 4 2 4 rbind(A,c(10,12)) ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 ## [3,] 10 12 rbind(A,A) ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 ## [3,] 1 3 ## [4,] 2 4 Como pasaba con los vectores, todas las entradas de una matriz en R han de ser del mismo tipo de datos, y si una matriz contiene datos de diferentes tipos, automáticamente los convierte a un tipo que pueda ser común a todos ellos. Si los vectores que concatenamos con rbind o cbind tienen nombres, las filas o columnas correspondientes de la matriz los heredan. x=c(1,2,3) y=c(0,1,-1) rbind(x,y) ## [,1] [,2] [,3] ## x 1 2 3 ## y 0 1 -1 cbind(x,y) ## x y ## [1,] 1 0 ## [2,] 2 1 ## [3,] 3 -1 Se puede también poner nombres a las filas y las columnas de una matriz con la instrucción dimnames(``matriz )=list(``vector de nombres de filas ,``vector de nombres de columnas ). Si las filas o las columnas no han de tener nombres, se declara su vector de nombres como NULL en esta list. A=matrix(1:6,nrow=3) A ## [,1] [,2] ## [1,] 1 4 ## [2,] 2 5 ## [3,] 3 6 dimnames(A)=list(c(&quot;X1&quot;,&quot;X2&quot;,&quot;X3&quot;),c(&quot;Y1&quot;,&quot;Y2&quot;)) A ## Y1 Y2 ## X1 1 4 ## X2 2 5 ## X3 3 6 dimnames(A)=list(NULL,c(&quot;Palma&quot;,&quot;Barcelona&quot;)) A ## Palma Barcelona ## [1,] 1 4 ## [2,] 2 5 ## [3,] 3 6 Los nombres de las filas y columnas de una matriz pueden servir para hacer más clara la información contenida en la misma. 5.2 Acceso a entradas y submatrices La entrada $(i, j)$ de una matriz es el elemento situado en su fila \\(i\\) y su columna \\(j\\). Por ejemplo, las entradas \\((1,2)\\) y \\((2,1)\\) de la matriz \\[ A = \\left(\\begin{matrix} 2 &amp; 1 &amp; -3\\\\ -4 &amp; 3 &amp; \\sqrt{3}\\end{matrix} \\right) \\] son, respectivamente, \\(1\\) y \\(-4\\). El acceso a las entradas de una matriz se realiza como en los vectores, sólo que ahora en las matrices podemos especificar la fila y la columna: M[i, j] indica la entrada \\((i, j)\\) de la matriz M. M[i, ] indica la fila \\(i\\)-ésima de M. M[ ,j] indica la columna \\(j\\)-ésima de M. En los dos últimos casos, el resultado es un vector. Si queremos que el resultado sea una matriz de una sola fila o de una sola columna, respectivamente, tenemos que añadir el parámetro drop=FALSE dentro de los corchetes. M=matrix(c(1,3,5,2,3,6,2,9,8,4,2,5), nrow=3, byrow=TRUE) M ## [,1] [,2] [,3] [,4] ## [1,] 1 3 5 2 ## [2,] 3 6 2 9 ## [3,] 8 4 2 5 M[2,4] #Entrada (2,4) ## [1] 9 M[3,1] #Entrada (3,1) ## [1] 8 M[1, ] #Fila 1 ## [1] 1 3 5 2 M[1, , drop=FALSE] #ATENCIÓN: fijaos en las dos comas ## [,1] [,2] [,3] [,4] ## [1,] 1 3 5 2 M[ ,3] #Columna 3 ## [1] 5 2 2 M[ ,3, drop=FALSE] ## [,1] ## [1,] 5 ## [2,] 2 ## [3,] 2 Estas construcciones sirven también para definir submatrices, y no sólo entradas, filas o columnas. Naturalmente, para indicar más de una fila o más de una columna tenemos que usar vectores de índices. M[c(1,2),c(1,3)] #Submatriz de filas 1, 2 y columnas 1, 3 ## [,1] [,2] ## [1,] 1 5 ## [2,] 3 2 M[c(1,3), ] #Submatriz de filas 1, 3 y todas las columnas ## [,1] [,2] [,3] [,4] ## [1,] 1 3 5 2 ## [2,] 8 4 2 5 M[ ,c(2,3,4)] #Submatriz de columnas 2, 3, 4 y todas las filas ## [,1] [,2] [,3] ## [1,] 3 5 2 ## [2,] 6 2 9 ## [3,] 4 2 5 Si las filas o las columnas de una matriz tienen nombres, se pueden usar para especificar trozos de la misma. A=matrix(1:9,nrow=3) dimnames(A)=list(c(&quot;X1&quot;,&quot;X2&quot;,&quot;X3&quot;),c(&quot;Y1&quot;,&quot;Y2&quot;,&quot;Y3&quot;)) A ## Y1 Y2 Y3 ## X1 1 4 7 ## X2 2 5 8 ## X3 3 6 9 A[c(1,3),2] ## X1 X3 ## 4 6 A[c(&quot;X1&quot;,&quot;X3&quot;),&quot;Y2&quot;] ## X1 X3 ## 4 6 A[c(&quot;X1&quot;,&quot;X3&quot;),c(&quot;Y1&quot;,&quot;Y2&quot;)] ## Y1 Y2 ## X1 1 4 ## X3 3 6 La diagonal principal de una matriz cuadrada (la que va de la esquina superior izquierda a la esquina inferior derecha) se obtiene con la función diag. Si la matriz no es cuadrada, diag produce el vector de entradas \\((1, 1), (2, 2), \\ldots\\) hasta que se para en la última fila o la última columna. A=matrix(1:9, nrow=3, byrow=TRUE) A ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 diag(A) ## [1] 1 5 9 B=matrix(1:10, nrow=2, byrow=TRUE) B ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 2 3 4 5 ## [2,] 6 7 8 9 10 diag(B) ## [1] 1 7 5.3 Algunas funciones para matrices Las dimensiones de una matriz, es decir, sus números de filas y de columnas, se obtienen con las funciones nrow y ncol, respectivamente. Si queremos un vector formado por las dos dimensiones, podemos emplear la función dim. X=matrix(c(1,2,4,3,5,1,4,6,7,1,6,4), byrow=TRUE, nrow=2) X ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] 1 2 4 3 5 1 ## [2,] 4 6 7 1 6 4 nrow(X) ## [1] 2 ncol(X) ## [1] 6 dim(X) ## [1] 2 6 La mayoría de las funciones numéricas para vectores se pueden aplicar a matrices. Por ejemplo, podemos usar las funciones sum, prod o mean para obtener la suma, el producto o la media, respectivamente, de todas las entradas de una matriz. A=matrix(c(1,2,1,3,-1,3), nrow=2, byrow=TRUE) A ## [,1] [,2] [,3] ## [1,] 1 2 1 ## [2,] 3 -1 3 sum(A) ## [1] 9 mean(A) ## [1] 1.5 En estadística a veces es necesario calcular la suma o la media por filas o por columnas de una matriz. Esto se puede llevar a cabo con las instrucciones siguientes: colSums produce un vector con las sumas de las columnas. rowSums produce un vector con las sumas de las filas. colMeans produce un vector con las medias de las columnas. rowMeans produce un vector con las medias de las filas. A=rbind(c(1,2,3,2),c(2,5,3,1),c(4,1,2,4)) A ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 2 ## [2,] 2 5 3 1 ## [3,] 4 1 2 4 colSums(A) #Sumas de columnas ## [1] 7 8 8 7 rowSums(A) #Sumas de filas ## [1] 8 11 11 colMeans(A) #Medias de columnas ## [1] 2.333333 2.666667 2.666667 2.333333 rowMeans(A) #Medias de filas ## [1] 2.00 2.75 2.75 Si queremos aplicar otras funciones a las filas o las columnas de una matriz, podemos emplear la función apply. Su estructura básica es apply(A, MARGIN=\\ldots, FUN=``función ), donde A es una matriz, la función es la que queremos aplicar, y el valor de MARGIN ha de ser 1 si la queremos aplicar por filas, 2 si la queremos aplicar por columnas, o c(1, 2) si la queremos aplicar entrada a entrada; como pasaba con los vectores, en muchas ocasiones podemos aplicar una función a todas las entradas de una matriz entrando la matriz en su argumento, pero a veces es necesario usar apply con MARGIN=c(1,2). Por ejemplo, para calcular la norma euclídea de las filas de la matriz \\(A\\) anterior (la raíz cuadrada de la suma de los cuadrados de sus entradas), para ordenar cada una de sus columnas, y para calcular la matriz de raíces cuadradas de las entradas de \\(A\\), haríamos lo siguiente: f=function(x){sqrt(sum(x^2))} apply(A, MARGIN=1, FUN=f) #Normas euclídeas de filas ## [1] 4.242641 6.244998 6.082763 A_ord=apply(A, MARGIN=2, FUN=sort) #Matriz con cada columna de A ordenada A_ord ## [,1] [,2] [,3] [,4] ## [1,] 1 1 2 1 ## [2,] 2 2 3 2 ## [3,] 4 5 3 4 sqrt(A) #Matriz de raíces cuadradas ## [,1] [,2] [,3] [,4] ## [1,] 1.000000 1.414214 1.732051 1.414214 ## [2,] 1.414214 2.236068 1.732051 1.000000 ## [3,] 2.000000 1.000000 1.414214 2.000000 apply(A, MARGIN=c(1,2), FUN=sqrt) #La anterior, usando apply ## [,1] [,2] [,3] [,4] ## [1,] 1.000000 1.414214 1.732051 1.414214 ## [2,] 1.414214 2.236068 1.732051 1.000000 ## [3,] 2.000000 1.000000 1.414214 2.000000 5.4 Cálculo matricial (opcional) Las operaciones algebraicas usuales con matrices numéricas se indican de la manera siguiente:23 La traspuesta se obtiene con la función t. La suma de matrices se indica con el signo usual +. El producto de un escalar por una matriz se indica con el signo usual *. El producto de matrices se indica con %*%. ¡Atención! Si &lt;&gt; dos matrices con el signo *, no obtenéis el producto de las dos matrices, sino la matriz que tiene en cada entrada \\((i, j)\\) el producto de las entradas \\((i, j)\\) de cada una de las dos matrices. Esto a veces es útil, pero no es el producto de matrices. De manera similar, si \\(M\\) es una matriz y entráis M^n, el resultado no es la potencia \\(n\\)-ésima de \\(M\\), sino la matriz que tiene en cada entrada la potencia \\(n\\)-ésima de la entrada correspondiente de \\(M\\). De nuevo, esto a veces es útil, pero muy pocas veces coincide con la potencia \\(n\\)-ésima de \\(M\\). A=matrix(c(1,2,1,3), nrow=2, byrow=TRUE) A ## [,1] [,2] ## [1,] 1 2 ## [2,] 1 3 B=matrix(c(-2,4,3,1,0,2), nrow=3, byrow=TRUE) B ## [,1] [,2] ## [1,] -2 4 ## [2,] 3 1 ## [3,] 0 2 C=matrix(c(1,0,1,2,1,0), nrow=2, byrow=TRUE) C ## [,1] [,2] [,3] ## [1,] 1 0 1 ## [2,] 2 1 0 t(B) #Traspuesta ## [,1] [,2] [,3] ## [1,] -2 3 0 ## [2,] 4 1 2 t(B)+C #Suma ## [,1] [,2] [,3] ## [1,] -1 3 1 ## [2,] 6 2 2 5*A #Producto por escalar ## [,1] [,2] ## [1,] 5 10 ## [2,] 5 15 C%*%B #Producto ## [,1] [,2] ## [1,] -2 6 ## [2,] -1 9 (C%*%B)%*%A #Producto ## [,1] [,2] ## [1,] 4 14 ## [2,] 8 25 A^2 #Esto no es elevar al cuadrado ## [,1] [,2] ## [1,] 1 4 ## [2,] 1 9 A%*%A #Esto sí ## [,1] [,2] ## [1,] 3 8 ## [2,] 4 11 Al multiplicar matrices por vectores, R trata por defecto estos últimos como vectores columna, pero si en alguna situación concreta la manera natural de entender un vector es como vector fila, lo hace sin ningún reparo. Veamos algunos ejemplos: A=rbind(c(1,2),c(3,4)) A ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 v=c(5,6) El producto \\[ \\left(\\begin{array}{cc} 1 &amp; 2 \\\\ 3 &amp; 4\\end{array} \\right)\\cdot \\left(\\begin{array}{c} 5\\\\ 6\\end{array} \\right) \\] se obtiene mediante A%*%v ## [,1] ## [1,] 17 ## [2,] 39 El producto \\[ \\left(\\begin{array}{cc} 5 &amp; 6\\end{array}\\right)\\cdot\\left(\\begin{array}{cc} 1 &amp; 2 \\\\ 3 &amp; 4\\end{array} \\right) \\] se obtiene mediante v%*%A ## [,1] [,2] ## [1,] 23 34 El producto \\[ \\left(\\begin{array}{cc} 5 &amp; 6\\end{array}\\right)\\cdot \\left(\\begin{array}{c} 5\\\\ 6\\end{array} \\right) \\] se obtiene mediante v%*%v ## [,1] ## [1,] 61 El producto \\[ \\left(\\begin{array}{c} 5\\\\ 6\\end{array} \\right)\\cdot \\left(\\begin{array}{cc} 5 &amp; 6\\end{array}\\right) \\] se obtiene mediante v%*%t(v) ## [,1] [,2] ## [1,] 25 30 ## [2,] 30 36 La versión básica de R no lleva ninguna función para calcular potencias de matrices, y hay que cargar algún paquete adecuado para disponer de ella.24 Por ejemplo, el paquete Biodem dispone de la función mtx.exp, y el paquete expm dispone de la operación %^%. No obstante, hay que tener en cuenta que estas funciones no calculan las potencias de manera exacta, sino que emplean algoritmos de cálculo numérico para aproximarlas a cambio de calcularlas rápido, y por lo tanto no siempre dan el resultado exacto. A=matrix(c(1,2,1,3), nrow=2, byrow=TRUE) # Instalamos y cargamos el paquete &quot;Biodem&quot; # ... library(Biodem) mtx.exp(A, 20) #A^20 ## [,1] [,2] ## [1,] 58063278153 158631825968 ## [2,] 79315912984 216695104121 #Instalamos y cargamos el paquete &quot;expm&quot; #... library(expm) A%^%20 #A^20 ## [,1] [,2] ## [1,] 58063278153 158631825968 ## [2,] 79315912984 216695104121 El determinante de una matriz cuadrada se calcula con la función det. Y=rbind(c(1,3,2),c(2,3,5),c(-1,3,2)) Y ## [,1] [,2] [,3] ## [1,] 1 3 2 ## [2,] 2 3 5 ## [3,] -1 3 2 det(Y) ## [1] -18 Para ganar en rapidez, R calcula los determinantes usando un método numérico que a veces produce efectos no deseados como el siguiente: A=matrix(c(3,10,30,100), nrow=2) A ## [,1] [,2] ## [1,] 3 30 ## [2,] 10 100 det(A) ## [1] 3.552714e-14 Pero, de hecho, \\[ \\left|\\begin{array}{cc} 3 &amp; 30\\\\ 10 &amp;100 \\end{array}\\right|= 3\\cdot 100-30\\cdot 10=0. \\] Por lo tanto, este determinante \\(3.552714\\cdot 10^{-14}\\) es en realidad \\(0\\). El rango de una matriz \\(A\\) se puede calcular mediante la instrucción qr(A)\\$rank. X=matrix(c(0,1,0,-7,3,-1,16,-3,4), nrow=3, byrow=TRUE) X ## [,1] [,2] [,3] ## [1,] 0 1 0 ## [2,] -7 3 -1 ## [3,] 16 -3 4 det(X) ## [1] 12 qr(X)$rank ## [1] 3 Y=rbind(rep(0,3),rep(1,3)) Y ## [,1] [,2] [,3] ## [1,] 0 0 0 ## [2,] 1 1 1 qr(Y)$rank ## [1] 1 Podemos calcular la inversa de una matriz invertible con la instrucción solve. Por ejemplo, para calcular la inversa \\(A^{-1}\\) de la matriz \\[ A=\\left(\\begin{array}{ccc} 1 &amp; 3 &amp; 4 \\\\ 0 &amp; 2 &amp; -1 \\\\ 2 &amp; 1 &amp; 2\\end{array} \\right) \\] podemos entrar lo siguiente: A=matrix(c(1,3,4,0,2,-1,2,1,2), nrow=3, byrow=TRUE) solve(A) ## [,1] [,2] [,3] ## [1,] -0.2941176 0.1176471 0.64705882 ## [2,] 0.1176471 0.3529412 -0.05882353 ## [3,] 0.2352941 -0.2941176 -0.11764706 Obtenemos \\[ A^{-1}=\\left(\\begin{array}{ccc} -0.2941176 &amp; 0.1176471 &amp; 0.64705882\\\\ 0.1176471 &amp; 0.3529412 &amp; -0.05882353\\\\ 0.2352941 &amp; -0.2941176 &amp; -0.11764706 \\end{array} \\right). \\] Comprobemos si esta matriz es realmente la inversa de \\(A\\): A%*%solve(A) ## [,1] [,2] [,3] ## [1,] 1.000000e+00 0 0.000000e+00 ## [2,] 5.551115e-17 1 -2.775558e-17 ## [3,] 0.000000e+00 0 1.000000e+00 solve(A)%*%A ## [,1] [,2] [,3] ## [1,] 1 0.000000e+00 0.000000e+00 ## [2,] 0 1.000000e+00 1.110223e-16 ## [3,] 0 2.775558e-17 1.000000e+00 Los productosA%*%solve(A) y solve(A)%*%A no han dado exactamente la matriz identidad, como deberían, pero la diferencia está en la decimosexta cifra decimal. Recordad que R no trabaja con precisión infinita, a veces los errores de redondeo son inevitables. La función solve también sirve para resolver sistemas de ecuaciones lineales \\[ \\left.\\begin{array}{c} a_{1,1} x_1+\\cdots +a_{1,n}x_n = b_1 \\\\ a_{2,1} x_1+\\cdots +a_{2,n}x_n = b_2 \\\\ \\vdots\\qquad\\ \\\\ a_{n,1} x_1+\\cdots +a_{n,n}x_n = b_n \\end{array} \\right\\} \\] cuya matriz del sistema \\[ A=\\left(\\begin{array}{ccc} a_{1,1} &amp; \\cdots &amp; a_{1,n} \\\\ \\vdots &amp; \\ddots &amp; \\vdots\\\\ a_{n,1} &amp; \\cdots &amp; a_{n,n} \\end{array} \\right) \\] sea cuadrada e invertible. Para ello, se usaría la instrucción solve(A, b), donde A es la matriz \\(A\\) del sistema y b es el vector de términos independientes \\[ b=(b_1, \\ldots, b_{n}). \\] Por ejemplo, para resolver el sistema \\[ \\left.\\begin{array}{r} x+6y-3z = 7 \\\\ 2x-y+z = 2\\\\ x+y-z = 3 \\end{array} \\right\\}, \\] que escrito en forma matricial es \\[ \\left(\\begin{array}{ccc} 1 &amp; 6 &amp; -3 \\\\ 2 &amp; -1 &amp; 1 \\\\ 1 &amp; 1 &amp; -1\\end{array} \\right)\\cdot \\left(\\begin{array}{c} x \\\\ y \\\\ z \\end{array} \\right)= \\left(\\begin{array}{c} 7 \\\\ 2 \\\\ 3 \\end{array} \\right), \\] podemos entrar A=matrix(c(1,6,-3,2,-1,1,1,1,-1), nrow=3, byrow=TRUE) A ## [,1] [,2] [,3] ## [1,] 1 6 -3 ## [2,] 2 -1 1 ## [3,] 1 1 -1 b=c(7,2,3) solve(A, b) ## [1] 1.6666667 0.4444444 -0.8888889 y obtenemos que la solución del sistema (redondeada a 7 cifras decimales) es \\[ x=1.6666667, \\ y=0.4444444, \\ z=-0.8888889. \\] 5.5 Valores y vectores propios (opcional) La función básica para calcular valores y vectores propios25 es eigen (en inglés, los valores y vectores propios se llaman eigenvalues y eigenvectors , respectivamente). Supongamos, por ejemplo, que queremos calcular los valores propios de la matriz \\[ A=\\left(\\begin{array}{ccc}2 &amp; 6 &amp; -8 \\\\ 0 &amp; 6 &amp; -3 \\\\ 0 &amp; 2 &amp; 1\\end{array} \\right). \\] A=matrix(c(2,6,-8,0,6,-3,0,2,1), nrow=3, byrow=TRUE) A ## [,1] [,2] [,3] ## [1,] 2 6 -8 ## [2,] 0 6 -3 ## [3,] 0 2 1 eigen(A) ## eigen() decomposition ## $values ## [1] 4 3 2 ## ## $vectors ## [,1] [,2] [,3] ## [1,] 0.2672612 -0.8164966 1 ## [2,] 0.8017837 0.4082483 0 ## [3,] 0.5345225 0.4082483 0 El resultado de eigen es una list con dos objetos: values y vectors. str(eigen(A)) ## List of 2 ## $ values : num [1:3] 4 3 2 ## $ vectors: num [1:3, 1:3] 0.267 0.802 0.535 -0.816 0.408 ... ## - attr(*, &quot;class&quot;)= chr &quot;eigen&quot; eigen(A)$values ## [1] 4 3 2 eigen(A)$vectors ## [,1] [,2] [,3] ## [1,] 0.2672612 -0.8164966 1 ## [2,] 0.8017837 0.4082483 0 ## [3,] 0.5345225 0.4082483 0 El objeto values es un vector con los valores propios, y el objeto vectors es una matriz cuyas columnas son vectores propios: la primera columna es un vector propio del primer valor propio del vector values, la segunda lo es del segundo, y así sucesivamente. De este modo, del resultado anterior deducimos que los valores propios de \\(A\\) son 2, 3 y 4 y que \\[ \\left(\\begin{array}{c} 1 \\\\ 0 \\\\ 0\\end{array}\\right), \\left(\\begin{array}{c} -0.8164966 \\\\ 0.4082483 \\\\ 0.4082483\\end{array}\\right), \\left(\\begin{array}{c} 0.2672612 \\\\ 0.8017837 \\\\ 0.5345225\\end{array}\\right) \\] son vectores propios de \\(A\\) de valores propios 2, 3 y 4, respectivamente (o, para ser precisos, los dos últimos son vectores propios de valor propio 3 y 4 redondeados a 7 cifras decimales). Es importante tener en cuenta algunas propiedades de la función eigen: Da los valores propios en orden decreciente de su valor absoluto (o de su módulo, si hay valores propios complejos) y repetidos tantas veces como su multiplicidad. Si hay algún valor propio con multiplicidad mayor que 1, da tantos vectores de este valor propio como su multiplicidad. Además, en este caso procura que estos vectores propios sean linealmente independientes. Por lo tanto, cuando da vectores propios repetidos de algún valor propio es porque para este valor propio no existen tantos vectores propios linealmente independientes como su multiplicidad y, por consiguiente, la matriz no es diagonalizable. Del resultado de eigen(A) se puede obtener una descomposición canónica \\[ A= P\\cdot D\\cdot P^{-1} \\] de una matriz diagonalizable \\(A\\): basta tomar como \\(D\\) la matriz diagonal que tiene como diagonal principal el vector eigen(A)$values y como \\(P\\) la matriz eigen(A)$vectors. Para construir una matriz diagonal cuya diagonal principal sea un vector dado, podemos usar la instrucción diag(``vector ). Si aplicamos diag a un número \\(n\\), produce la matriz identidad de orden \\(n\\). diag(c(2,5,-1)) ## [,1] [,2] [,3] ## [1,] 2 0 0 ## [2,] 0 5 0 ## [3,] 0 0 -1 diag(3) ## [,1] [,2] [,3] ## [1,] 1 0 0 ## [2,] 0 1 0 ## [3,] 0 0 1 La función diag ya había salido en la Sección ??: si se aplica a una matriz, se obtiene el vector formado por sus entradas \\((1,1), (2,2),\\ldots\\); ahora vemos que si se aplica a un vector, produce una matriz diagonal. B=matrix(1:10, nrow=2, byrow=TRUE) B ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 2 3 4 5 ## [2,] 6 7 8 9 10 diag(B) ## [1] 1 7 diag(diag(B)) ## [,1] [,2] ## [1,] 1 0 ## [2,] 0 7 Veamos un ejemplo de uso de eigen para calcular una descomposición canónica. Como hemos visto, la matriz \\[ A=\\left(\\begin{array}{ccc}2 &amp; 6 &amp; -8 \\\\ 0 &amp; 6 &amp; -3 \\\\ 0 &amp; 2 &amp; 1\\end{array} \\right) \\] es de orden 3 y tiene sus tres valores propios diferentes. Por lo tanto, es diagonalizable y las matrices de una descomposición canónica serían las siguientes: D=diag(eigen(A)$values) #Matriz diagonal D de valores propios D ## [,1] [,2] [,3] ## [1,] 4 0 0 ## [2,] 0 3 0 ## [3,] 0 0 2 P=eigen(A)$vectors #Matriz P de vectores propios P ## [,1] [,2] [,3] ## [1,] 0.2672612 -0.8164966 1 ## [2,] 0.8017837 0.4082483 0 ## [3,] 0.5345225 0.4082483 0 Comprobemos que, efectivamente, \\(A=P\\cdot D\\cdot P^{-1}\\): P%*%D%*%solve(P) ## [,1] [,2] [,3] ## [1,] 2 6 -8 ## [2,] 0 6 -3 ## [3,] 0 2 1 A ## [,1] [,2] [,3] ## [1,] 2 6 -8 ## [2,] 0 6 -3 ## [3,] 0 2 1 Por consiguiente, una descomposición canónica de \\(A\\) es (salvo redondeos) \\[ A=\\left(\\begin{array}{ccc} 0.2672612 &amp; -0.8164966 &amp; 1\\\\ 0.8017837 &amp; 0.4082483 &amp; 0\\\\ 0.5345225 &amp; 0.4082483 &amp; 0 \\end{array} \\right)\\!\\cdot\\! \\left(\\begin{array}{ccc} 4 &amp; 0 &amp; 0 \\\\ 0 &amp; 3 &amp; 0\\\\ 0 &amp; 0 &amp; 2 \\end{array} \\right)\\!\\cdot\\! \\left(\\begin{array}{ccc} 0.2672612 &amp; -0.8164966 &amp; 1\\\\ 0.8017837 &amp; 0.4082483 &amp; 0\\\\ 0.5345225 &amp; 0.4082483 &amp; 0 \\end{array} \\right)^{-1}. \\] Veamos otro ejemplo. Queremos decidir si la matriz \\[ B=\\left(\\begin{array}{ccc}0 &amp; 1 &amp; 0 \\\\ -7 &amp; 3 &amp; -1 \\\\ 16 &amp; -3 &amp; 4\\end{array} \\right) \\] es diagonalizable y, en caso afirmativo, obtener una descomposición canónica. B=matrix(c(0,1,0,-7,3,-1,16,-3,4), nrow=3, byrow=TRUE) eigen(B) ## eigen() decomposition ## $values ## [1] 3 2 2 ## ## $vectors ## [,1] [,2] [,3] ## [1,] -0.1301889 -0.1825742 -0.1825742 ## [2,] -0.3905667 -0.3651484 -0.3651484 ## [3,] 0.9113224 0.9128709 0.9128709 Da dos veces el mismo vector propio de valor propio 2. Esto significa que \\(B\\) no tiene dos vectores propios linealmente independientes de este valor propio, y, por lo tanto, no es diagonalizable. 5.6 Matrices complejas (opcional) La mayoría de las instrucciones explicadas en esta lección para operar con matrices numéricas sirven sin ningún cambio para operar con matrices de entradas números complejos. Por ejemplo, para elevar al cuadrado la matriz \\[ \\left( \\begin{array}{cc} 3-2i &amp; 5+3\\\\ 1+2i &amp; 2-i \\end{array} \\right), \\] podemos entrar: A=matrix(c(3-2i,5+3i,1+2i,2-1i), nrow=2, byrow=TRUE) A ## [,1] [,2] ## [1,] 3-2i 5+3i ## [2,] 1+2i 2-1i A%*%A ## [,1] [,2] ## [1,] 4+1i 34+0i ## [2,] 11+7i 2+9i Para calcular sus valores y vectores propios, podemos entrar: eigen(A) ## eigen() decomposition ## $values ## [1] 4.902076+1.101916i 0.097924-4.101916i ## ## $vectors ## [,1] [,2] ## [1,] 0.8483705+0.000000i 0.8519823+0.000000i ## [2,] 0.4695014+0.244614i -0.5216168-0.045189i Y para resolver el sistema de ecuaciones \\[ \\left. \\begin{array}{rl} (3-2i)x+(5+3i)y &amp; = 2-i\\\\ (1+2i)x+(2-i)y &amp; = 3 \\end{array} \\right\\} \\] podemos entrar: A=matrix(c(3-2i,5+3i,1+2i,2-1i), nrow=2, byrow=TRUE) b=c(2-1i,3) solve(A, b) ## [1] 0.4705882-0.7176471i 0.4823529+0.1294118i La excepción más importante son los determinantes. &gt; det(A) Error in determinant.matrix(x, logarithm = TRUE, ...) : &#39;determinant&#39; not currently defined for complex matrices Pero resulta que el determinante de una matriz es igual al producto de sus valores propios, incluyendo repeticiones. Por lo tanto, para calcular el determinante de una matriz compleja \\(A\\) podemos usar prod(eigen(A)$values). A=matrix(c(3-2i, 5+3i, 1+2i, 2-1i), nrow=2, byrow=TRUE) prod(eigen(A)$values) ## [1] 5-20i 5.7 Guía rápida de funciones matrix sirve para construir una matriz a partir de un vector. Algunos parámetros importantes: byrow: un parámetro lógico para indicar si la matriz se construye por filas (igualado a TRUE) o por columnas (valor por defecto). nrow: el número de filas. ncol: el número de columnas. cbind concatena vectores y matrices por columnas. rbind concatena vectores y matrices por filas. dimnames permite poner nombres a las filas y las columnas de una matriz. matriz [..., ...] se usa para especificar un elemento, una fila, una columna o una submatriz de la matriz. Si extraemos una fila o una columna con el parámetro drop=FALSE, el resultado es una matriz y no un vector. diag tiene dos significados: aplicada a un vector, construye una matriz diagonal, y aplicada a una matriz, extrae su diagonal principal. nrow da el número de filas de una matriz. ncol da el número de columnas de una matriz. dim da un vector con las dimensiones de una matriz. sum, prod y mean calculan, respectivamente, la suma, el producto y la media de las entradas de una matriz. colSums y rowSums calculan, respectivamente, las sumas de las entradas de cada una de las columnas y de cada una de las filas de una matriz. colMeans y rowMeans calculan, respectivamente, las medias de cada una de las columnas y de cada una de las filas de una matriz. apply(``matriz , MARGIN=\\ldots, FUN=``función ) aplica la función a las filas (MARGIN=1), a las columnas (MARGIN=2) o a todas las entradas (MARGIN=c(1, 2)) de la matriz . Signos de operaciones con matrices: Función Suma Producto por escalar Producto Producto Potencia (paquete expm) Signo * * %*% %^% t calcula la traspuesta de una matriz. det calcula el determinante de una matriz. qr(``matriz )\\$rank calcula el rango de la matriz . solve, aplicada a una matriz invertible \\(A\\), calcula su inversa \\(A^{-1}\\), y aplicada a una matriz invertible \\(A\\) y un vector \\(b\\), calcula \\(A^{-1}\\cdot b\\). eigen calcula los valores y vectores propios de una matriz. El resultado es una list con dos componentes: values: un vector con los valores propios. vectors: una matriz cuyas columnas son vectores propios de los correspondientes valores propios. 5.8 Ejercicio (opcional) Sean \\(x\\) e \\(y\\) dos cantidades de las cuales efectuamos una serie de \\(k\\) observaciones conjuntas, de forma que obtenemos una secuencia de pares de valores \\[ (x_{1}, y_{1}), (x_{2}, y_{2}), \\ldots, (x_{k}, y_{k}). \\] Como veíamos en la Lección 3, si queremos encontrar la recta \\(y=ax+b\\) que aproxime mejor estas observaciones, una posibilidad es calcular los valores \\(a, b\\in \\mathbb{R}\\) tales que \\[ \\sum_{i=1}^k (ax_{i}+b-y_{i})^2 \\] sea mínimo. De este modo encontraríamos la recta de regresión por mínimos cuadrados . Resulta (no lo demostraremos aquí) que los coeficientes \\(a\\) y \\(b\\) de esta recta de regresión se obtienen por medio de la fórmula \\[ \\left(\\begin{matrix} b\\\\ a \\end{matrix} \\right)= (D_{2}\\cdot D_{2}^t)^{-1}\\cdot D_{2}\\cdot w, \\] donde \\[ w=\\left(\\begin{matrix}y_{1}\\\\ \\vdots\\\\ y_{k}\\end{matrix} \\right), \\quad D_{2}=\\left(\\begin{matrix} 1 &amp; 1 &amp; \\ldots &amp; 1 \\\\ x_{1} &amp; x_{2} &amp; \\ldots &amp; x_{k} \\end{matrix} \\right). \\] Calculad de este modo los valores de \\(a\\) y \\(b\\) cuando las observaciones son las de la Tabla 5.1 (es la Tabla ?? de la Lección 3), y comprobad que obtenéis el mismo resultado que obteníamos en su momento con la función lm. Tabla 5.1: Alturas medias de niños por edad. x: (edad, en años) 1.00 2.00 3.00 5.00 7.00 9.00 11.00 13.00 y: (altura, en cm) 76.11 86.45 95.27 109.18 122.03 133.73 143.73 156.41 De manera similar, si queremos obtener una función cuadrática \\(y=a x^2+b x+c\\) que aproxime los pares \\((x_i, y_i)_{y=1, \\ldots, k}\\), podemos buscar los coeficientes \\(a, b, c\\) que minimicen el valor de \\[ \\sum_{i=1}^k (ax_{i}^2+bx_{i}+c-y_{i})^2. \\] Estos coeficientes se obtienen de manera similar, por medio de la fórmula \\[ \\left(\\begin{matrix} c\\\\ b\\\\ a \\end{matrix} \\right)= (D_{3}\\cdot D_{3}^t)^{-1}\\cdot D_{3}\\cdot w, \\] donde \\(w\\) es como antes y ahora \\[ D_{3}=\\left(\\begin{matrix} 1 &amp; 1 &amp; \\ldots &amp; 1 \\\\ x_{1} &amp; x_{2} &amp; \\ldots &amp; x_{k}\\\\[0.5ex] x_{1}^2 &amp; x_{2}^2 &amp; \\ldots &amp; x_{k}^2 \\end{matrix} \\right). \\] Calculad los valores de \\(a, b, c\\) para los pares \\((x,y)\\) de la Tabla @ref(tab:Ex5.1). Con R, podemos calcular estos coeficientes de la manera siguiente: si definimos un nuevo vector \\(z\\) con los cuadrados de los valores de \\(x\\), y aplicamos la función lm(y~x+z) obtenemos los coeficientes de la función lineal \\(y=c+bx+az\\) que mejor se ajusta a las ternas \\((x_i,z_i,y_i)\\), en el sentido de que minimiza la suma de las diferencias al cuadrado entre los valores \\(y_i\\) y los correspondientes \\(c+bx_i+az_i\\); substituyendo entonces \\(z\\) por \\(x^2\\) en esta relación, obtenemos la función \\(y=c+bx+ax^2\\) que buscábamos. Comprobad que, efectivamente, coincide con la calculada en el apartado anterior. Si necesitáis repasar los conceptos básicos sobre operaciones de matrices que aparecen en esta sección, podéis consultar la entrada sobre matrices en la Wikipedia, http://es.wikipedia.org/wiki/Matriz_(matemáticas) .↩ Explicamos el manejo de paquetes en la Sección 1.5↩ Si necesitáis repasar las definiciones de vector y valor propio de una matriz y de descomposición canónica de una matriz diagonalizable, y por qué son importantes, podéis consultar las entradas correspondientes de la Wikipedia: http://es.wikipedia.org/wiki/Vector_propio_y_valor_propio y http://es.wikipedia.org/wiki/Matriz_diagonalizable .↩ "],
["chap-df.html", "Lección 6 Data frames 6.1 Estructura de un data frame 6.2 Cómo importar y exportar data frames 6.3 Cómo crear data frames 6.4 Cómo modificar un data frame 6.5 Cómo añadir filas y columnas a un data frame 6.6 Cómo seleccionar trozos de un data frame 6.7 Cómo aplicar una función a las variables de un data frame 6.8 Cómo añadir las variables de un data frame al entorno global 6.9 &lt;&lt;Big data&gt;&gt; frames con data.table (opcional). 6.10 Guía rápida de funciones 6.11 Ejercicio", " Lección 6 Data frames Habitualmente, dispondremos de una serie de datos que describirán algunos aspectos de un conjunto de individuos, y querremos analizarlos. El análisis estadístico de estos datos puede ser de dos tipos básicos: Análisis exploratorio , o descriptivo , cuando nuestro objetivo sea resumir, representar y explicar los datos concretos de los que disponemos. La estadística descriptiva es el conjunto de técnicas que se usan con este fin. Análisis inferencial , si nuestro objetivo es deducir (inferir), a partir de estos datos, información significativa sobre el total de la población o las poblaciones de interés. Las técnicas que se usan en este caso forman la estadística inferencial. En las próximas lecciones explicaremos algunas técnicas básicas de estadística descriptiva orientadas al análisis de datos. Estas técnicas consistirán en una serie de medidas, gráficos y modelos descriptivos que nos permitirán resumir y explorar un conjunto de datos, con el objetivo final de entenderlos lo mejor posible. De todas formas, ambos tipos de análisis estadístico están relacionados. Así, por un lado, cualquier análisis inferencial se suele empezar explorando los datos que se usarán, y por otro, muchas técnicas descriptivas permiten estimar propiedades de la población de la que se ha extraído la muestra. Por citar un ejemplo, la media aritmética de las alturas de una muestra de individuos nos da un valor representativo de esta muestra, pero también estima la media de las alturas del total de la población, si la muestra es aleatoria. Los datos de los que disponemos para su análisis suelen ser multidimensionales, en el sentido de que observamos varias características de una serie de individuos. Estos datos se tienen que registrar de alguna manera. Normalmente, los guardaremos en un archivo de ordenador con un formato preestablecido. Los formatos de almacenamiento de datos en un ordenador son diversos: texto simple (codificado en diferentes formatos: ASCII, isolatin, utf8…), hojas de cálculo(archivos de Open Office o Excel), bases de datos, etc. Una de las maneras básicas de almacenar datos es en forma de tablas de datos , pequeñas bases de datos donde se han anotado los valores de algunas variables para una serie de observaciones. Como ya comentamos en la Lección 3, la manera más conveniente de guardar en R una tabla de datos es en forma de data frame. En concreto, un data frame es una tabla de doble entrada, formada por variables en las columnas y observaciones de estas variables en las filas, de manera que cada fila contiene los valores de las variables para un mismo caso o individuo. En este sentido, un data frame tiene la apariencia de una matriz, pero con la diferencia de que cada columna de un data frame puede contener datos de un tipo diferente, siempre que todos los datos de una misma columna sean del mismo tipo, porque corresponden a observaciones de una misma propiedad: así, una columna puede estar formada por números, por ejemplo, alguna medida; otra, por palabras, por ejemplo, la especie del individuo; otra, por valores lógicos, por ejemplo, que describan si una cierta propiedad está presente o ausente en el individuo; etc. De esta manera, las columnas de un data frame son vectores o factores, mientras que las filas son lists. Los tipos de datos que consideramos en este curso son los siguientes: Datos de tipo atributo , o cualitativos. Son los que expresan una cualidad del individuo, tales como el sexo, el DNI, la especie… . En R, guardaremos las listas de datos cualitativos en vectores (habitualmente, de palabras), o en factores si vamos a usarlos para clasificar individuos. Datos ordinales. Son datos similares a los cualitativos, con la única diferencia de que se pueden ordenar de manera natural. Por ejemplo, los niveles de calidad ambiental de un ecosistema (malo, regular, normal, bueno, muy bueno) o las calificaciones en un examen (suspenso, aprobado, notable,sobresaliente) son datos ordinales. En cambio, no se pueden ordenar de manera significativa los sexos o las especies de los individuos. En R, guardaremos las listas de datos ordinales en factores ordenados. Datos cuantitativos. Son datos que se refieren a medidas, tales como edades, longitudes, pesos, tiempos, números de individuos, etc. En R, guardaremos las listas de datos cuantitativos en vectores de números. El análisis, tanto descriptivo como inferencial, de un conjunto de datos es diferente según su tipo. Así, para datos cualitativos sólo tiene interés estudiar y representar las frecuencias con que aparecen sus diferentes valores, mientras que el análisis de datos cuantitativos suele involucrar el cálculo de medidas estadísticas que evalúen numéricamente sus propiedades. 6.1 Estructura de un data frame La instalación básica de R lleva predefinidos algunos objetos de datos. Podemos echarles un vistazo entrando la instrucción data(), que abrirá una ventana con la lista de los objetos de datos a los que tenemos acceso en la sesión actual de R (los que lleva la instalación básica de R y los que aportan los paquetes que tengamos cargados). Estos objetos no aparecen cuando hacemos ls() ni se borran con rm(list=ls()), y podemos pedir información sobre cada uno de ellos en la ventana de Ayuda. Al final de la lista que obtenemos con data() se nos indica que si entramos data(package=.packages(all.available=TRUE)), obtendremos la lista de todos los objetos de datos a los que tenemos acceso, incluyendo los de los paquetes instalados pero no cargados en la sesión actual. Una de las tablas de datos más populares que lleva R es el llamado iris data set, que contiene la longitud y la anchura de los pétalos y sépalos y la especie de 150 flores iris. El famoso estadístico Sir R. A. Fisher usó este conjunto de datos en su artículo &lt;&gt; (Annals of Eugenics 7 (1936), pp. 179–188).26 En R, este conjunto de datos de flores iris está recogido en el data frame iris. Para más información sobre estos datos, podéis leer su entrada en la Wikipedia,27 y para más información específica sobre la tabla iris de R, podéis consultar la Ayuda de iris. En esta sección vamos a trabajar con esta tabla de datos, así que lo primero que haremos será copiarla en un nuevo data frame que llamaremos d.f; de este modo trabajaremos sobre la copia d.f y tendremos acceso al data frame iris original si necesitamos volver a él. De todas formas, si trabajamos directamente sobre iris y lo echamos a perder, lo podemos recuperar ejecutando la instrucción data(iris), que devolverá a este data frame su contenido original. d.f=iris Si pidiéramos ahora a R que nos mostrase el objeto d.f, &gt; d.f obtendríamos el contenido del data frame en la consola: una larga lista de datos formada por las 150 filas de la tabla; naturalmente, no vamos a copiar aquí esta salida. Para echarle un vistazo al data frame, y así poder entender su estructura y conocer los nombres de sus variables, os recomendamos usar la instrucción &gt; View(d.f) que lo mostrará en la ventana superior izquierda de RStudio. Véase la Figura 6.1. knitr::include_graphics(&quot;images/View.jpg&quot;) Figura 6.1: Vista de un data frame con View. También podemos consultar en la consola las primeras filas del data frame, aplicando la función head al data frame y al número de filas que queremos que muestre; su valor por defecto es 6. head(d.f,5) #Las primeras 5 filas ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa La función tail, con una estructura similar a head, nos muestra la &lt;&gt; de la tabla. tail(d.f,5) #Las últimas 5 filas ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 146 6.7 3.0 5.2 2.3 virginica ## 147 6.3 2.5 5.0 1.9 virginica ## 148 6.5 3.0 5.2 2.0 virginica ## 149 6.2 3.4 5.4 2.3 virginica ## 150 5.9 3.0 5.1 1.8 virginica Observad que las columnas del data frame tienen nombres (R los llama names) y las filas, que corresponden a individuos, tienen como identificador (R llama a estos identificadores rownames) un número natural correlativo que va del 1 al 150. Podemos comprobar también que, en cada fila, la columna Species contiene una palabra que describe la especie de la flor, mientras que las otras cuatro columnas contienen números que corresponden a medidas. Como veremos, la columna Species no es un vector, sino un factor (con niveles las tres especies de iris: setosa, versicolor y virginica), lo que nos facilita el uso de esta variable para clasificar las flores. Si queremos conocer la estructura global de un data frame, podemos usar la función str. str(d.f) ## &#39;data.frame&#39;: 150 obs. of 5 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... El resultado de esta instrucción nos muestra la estructura del objeto d.f. Nos dice que es un data frame formado por 150 observaciones (filas) de 5 variables (columnas), y de cada variable nos da su nombre (precedido de un signo $) y su tipo de datos: las cuatro primeras son variables cuantitativas, formadas por vectores numéricos (num), y la quinta es una variable cualitativa, un factor con (w, de with) 3 niveles que corresponden a las especies. Además, nos muestra los primeros valores de cada variable: en el caso del factor, los unos significan &lt;&gt;, su primer nivel. Las funciones siguientes nos permiten obtener los nombres de las variables, los identificadores de las filas y las dimensiones de un data frame: names: Produce un vector con los nombres de las columnas. rownames: Produce un vector con los identificadores de las filas. dimnames: Produce una list formada por dos vectores: el de los identificadores de las filas y el de los nombres de las columnas. dim: Produce un vector con el número de filas y el número de columnas. Veamos sus valores sobre nuestro data frame: names(d.f) ## [1] &quot;Sepal.Length&quot; &quot;Sepal.Width&quot; &quot;Petal.Length&quot; &quot;Petal.Width&quot; ## [5] &quot;Species&quot; rownames(d.f) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; &quot;11&quot; ## [12] &quot;12&quot; &quot;13&quot; &quot;14&quot; &quot;15&quot; &quot;16&quot; &quot;17&quot; &quot;18&quot; &quot;19&quot; &quot;20&quot; &quot;21&quot; &quot;22&quot; ## [23] &quot;23&quot; &quot;24&quot; &quot;25&quot; &quot;26&quot; &quot;27&quot; &quot;28&quot; &quot;29&quot; &quot;30&quot; &quot;31&quot; &quot;32&quot; &quot;33&quot; ## [34] &quot;34&quot; &quot;35&quot; &quot;36&quot; &quot;37&quot; &quot;38&quot; &quot;39&quot; &quot;40&quot; &quot;41&quot; &quot;42&quot; &quot;43&quot; &quot;44&quot; ## [45] &quot;45&quot; &quot;46&quot; &quot;47&quot; &quot;48&quot; &quot;49&quot; &quot;50&quot; &quot;51&quot; &quot;52&quot; &quot;53&quot; &quot;54&quot; &quot;55&quot; ## [56] &quot;56&quot; &quot;57&quot; &quot;58&quot; &quot;59&quot; &quot;60&quot; &quot;61&quot; &quot;62&quot; &quot;63&quot; &quot;64&quot; &quot;65&quot; &quot;66&quot; ## [67] &quot;67&quot; &quot;68&quot; &quot;69&quot; &quot;70&quot; &quot;71&quot; &quot;72&quot; &quot;73&quot; &quot;74&quot; &quot;75&quot; &quot;76&quot; &quot;77&quot; ## [78] &quot;78&quot; &quot;79&quot; &quot;80&quot; &quot;81&quot; &quot;82&quot; &quot;83&quot; &quot;84&quot; &quot;85&quot; &quot;86&quot; &quot;87&quot; &quot;88&quot; ## [89] &quot;89&quot; &quot;90&quot; &quot;91&quot; &quot;92&quot; &quot;93&quot; &quot;94&quot; &quot;95&quot; &quot;96&quot; &quot;97&quot; &quot;98&quot; &quot;99&quot; ## [100] &quot;100&quot; &quot;101&quot; &quot;102&quot; &quot;103&quot; &quot;104&quot; &quot;105&quot; &quot;106&quot; &quot;107&quot; &quot;108&quot; &quot;109&quot; &quot;110&quot; ## [111] &quot;111&quot; &quot;112&quot; &quot;113&quot; &quot;114&quot; &quot;115&quot; &quot;116&quot; &quot;117&quot; &quot;118&quot; &quot;119&quot; &quot;120&quot; &quot;121&quot; ## [122] &quot;122&quot; &quot;123&quot; &quot;124&quot; &quot;125&quot; &quot;126&quot; &quot;127&quot; &quot;128&quot; &quot;129&quot; &quot;130&quot; &quot;131&quot; &quot;132&quot; ## [133] &quot;133&quot; &quot;134&quot; &quot;135&quot; &quot;136&quot; &quot;137&quot; &quot;138&quot; &quot;139&quot; &quot;140&quot; &quot;141&quot; &quot;142&quot; &quot;143&quot; ## [144] &quot;144&quot; &quot;145&quot; &quot;146&quot; &quot;147&quot; &quot;148&quot; &quot;149&quot; &quot;150&quot; dimnames(d.f) ## [[1]] ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; &quot;11&quot; ## [12] &quot;12&quot; &quot;13&quot; &quot;14&quot; &quot;15&quot; &quot;16&quot; &quot;17&quot; &quot;18&quot; &quot;19&quot; &quot;20&quot; &quot;21&quot; &quot;22&quot; ## [23] &quot;23&quot; &quot;24&quot; &quot;25&quot; &quot;26&quot; &quot;27&quot; &quot;28&quot; &quot;29&quot; &quot;30&quot; &quot;31&quot; &quot;32&quot; &quot;33&quot; ## [34] &quot;34&quot; &quot;35&quot; &quot;36&quot; &quot;37&quot; &quot;38&quot; &quot;39&quot; &quot;40&quot; &quot;41&quot; &quot;42&quot; &quot;43&quot; &quot;44&quot; ## [45] &quot;45&quot; &quot;46&quot; &quot;47&quot; &quot;48&quot; &quot;49&quot; &quot;50&quot; &quot;51&quot; &quot;52&quot; &quot;53&quot; &quot;54&quot; &quot;55&quot; ## [56] &quot;56&quot; &quot;57&quot; &quot;58&quot; &quot;59&quot; &quot;60&quot; &quot;61&quot; &quot;62&quot; &quot;63&quot; &quot;64&quot; &quot;65&quot; &quot;66&quot; ## [67] &quot;67&quot; &quot;68&quot; &quot;69&quot; &quot;70&quot; &quot;71&quot; &quot;72&quot; &quot;73&quot; &quot;74&quot; &quot;75&quot; &quot;76&quot; &quot;77&quot; ## [78] &quot;78&quot; &quot;79&quot; &quot;80&quot; &quot;81&quot; &quot;82&quot; &quot;83&quot; &quot;84&quot; &quot;85&quot; &quot;86&quot; &quot;87&quot; &quot;88&quot; ## [89] &quot;89&quot; &quot;90&quot; &quot;91&quot; &quot;92&quot; &quot;93&quot; &quot;94&quot; &quot;95&quot; &quot;96&quot; &quot;97&quot; &quot;98&quot; &quot;99&quot; ## [100] &quot;100&quot; &quot;101&quot; &quot;102&quot; &quot;103&quot; &quot;104&quot; &quot;105&quot; &quot;106&quot; &quot;107&quot; &quot;108&quot; &quot;109&quot; &quot;110&quot; ## [111] &quot;111&quot; &quot;112&quot; &quot;113&quot; &quot;114&quot; &quot;115&quot; &quot;116&quot; &quot;117&quot; &quot;118&quot; &quot;119&quot; &quot;120&quot; &quot;121&quot; ## [122] &quot;122&quot; &quot;123&quot; &quot;124&quot; &quot;125&quot; &quot;126&quot; &quot;127&quot; &quot;128&quot; &quot;129&quot; &quot;130&quot; &quot;131&quot; &quot;132&quot; ## [133] &quot;133&quot; &quot;134&quot; &quot;135&quot; &quot;136&quot; &quot;137&quot; &quot;138&quot; &quot;139&quot; &quot;140&quot; &quot;141&quot; &quot;142&quot; &quot;143&quot; ## [144] &quot;144&quot; &quot;145&quot; &quot;146&quot; &quot;147&quot; &quot;148&quot; &quot;149&quot; &quot;150&quot; ## ## [[2]] ## [1] &quot;Sepal.Length&quot; &quot;Sepal.Width&quot; &quot;Petal.Length&quot; &quot;Petal.Width&quot; ## [5] &quot;Species&quot; dim(d.f) ## [1] 150 5 Fijaos en que el resultado de rownames son los identificadores de las filas entre comillas, es decir, considerados como palabras; R entiende siempre que estos identificadores son palabras, aunque, como en este caso, sean números. Recordaréis que se puede obtener el valor de una componente de una list añadiendo al nombre de esta última un sufijo formado por el signo $ seguido del nombre de la componente. De manera similar, para obtener una columna concreta de un data frame basta añadir a su nombre un sufijo formado por el signo$seguido del nombre de la variable; el resultado será un vector o un factor, según cómo esté definida la columna dentro del data frame d.f$Sepal.Length[1:30] ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 ## [18] 5.1 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 d.f$Species[1:30] ## [1] setosa setosa setosa setosa setosa setosa setosa setosa setosa setosa ## [11] setosa setosa setosa setosa setosa setosa setosa setosa setosa setosa ## [21] setosa setosa setosa setosa setosa setosa setosa setosa setosa setosa ## Levels: setosa versicolor virginica Como también pasaba con las componentes de las list, las variables de un data frame son internas, no están definidas en el entorno global de trabajo de R. &gt; Sepal.Length Error: object &#39;Sepal.Length&#39; not found En la Sección 6.8 explicaremos cómo podemos declarar las variables internas de un data frame como variables globales, y así poder usarlas directamente por su nombre, sin tener que añadirles delante el nombre del data frame y el \\$. Los data frames comparten con las matrices el uso de los corchetes para extraer trozos por filas y columnas. Los resultados que se obtienen son de nuevo data frames, y tanto los nombres de las columnas como los identificadores de las filas se heredan del data frame original; podemos comprobarlo en los siguientes ejemplos: d.f[1:5, ] #La subtabla de las 5 primeras filas ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa d.f[1:5, 1:3] #La subtabla de las 5 primeras filas y las 3 primeras columnas ## Sepal.Length Sepal.Width Petal.Length ## 1 5.1 3.5 1.4 ## 2 4.9 3.0 1.4 ## 3 4.7 3.2 1.3 ## 4 4.6 3.1 1.5 ## 5 5.0 3.6 1.4 d.f[d.f$Species==&quot;virginica&quot; &amp; d.f$Sepal.Length&gt;7, ] #La subtabla de filas con Species=virginica y Sepal.Length&gt;7 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 103 7.1 3.0 5.9 2.1 virginica ## 106 7.6 3.0 6.6 2.1 virginica ## 108 7.3 2.9 6.3 1.8 virginica ## 110 7.2 3.6 6.1 2.5 virginica ## 118 7.7 3.8 6.7 2.2 virginica ## 119 7.7 2.6 6.9 2.3 virginica ## 123 7.7 2.8 6.7 2.0 virginica ## 126 7.2 3.2 6.0 1.8 virginica ## 130 7.2 3.0 5.8 1.6 virginica ## 131 7.4 2.8 6.1 1.9 virginica ## 132 7.9 3.8 6.4 2.0 virginica ## 136 7.7 3.0 6.1 2.3 virginica d.f[d.f$Species==&quot;virginica&quot; &amp; d.f$Sepal.Length&gt;7, ][1:4,] #La subtabla de las 4 primeras filas de la anterior ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 103 7.1 3.0 5.9 2.1 virginica ## 106 7.6 3.0 6.6 2.1 virginica ## 108 7.3 2.9 6.3 1.8 virginica ## 110 7.2 3.6 6.1 2.5 virginica En todos los casos, obtenemos subtablas del data frame d.f con sus filas y columnas determinadas por las expresiones entre corchetes. 6.2 Cómo importar y exportar data frames R dispone de varias instrucciones que permiten importar ficheros externos como objetos de datos; por ejemplo, ya vimos en la Lección 4 la función scan, que permitía definir un vector con el contenido de un fichero. En esta sección explicaremos cómo podemos definir un data frame a partir de una tabla de datos contenida en un fichero externo. Para ello, usaremos la función read.table o el menú &lt;&lt;Import Dataset&gt;&gt; de la pestaña Environment de la ventana superior derecha de RStudio. En ambos casos, el fichero a importar ha de ser de texto simple: nada de ficheros en formato doc o xls, cuya lectura requiere funciones específicas (página ). Empecemos con la función read.table. Para crear un data frame a partir de un fichero de texto simple que contenga una tabla de datos, podemos aplicar esta función al nombre del fichero, si está en el directorio de trabajo de R, o a su url , si está en Internet; en ambos casos, entre comillas. Esta función read.table tiene algunos parámetros que evitan errores en la creación del data frame: sep. Como ya ocurría con la función scan, la función read.table entiende por defecto que las separaciones entre columnas en el fichero están marcadas por espacios en blanco. Si esta separación está marcada por comas, signos de punto y coma, tabuladores o de cualquier otra manera, hay que especificarlo con este parámetro. Por ejemplo, tenemos que especificar sep=&quot;,&quot; para indicar que las separaciones entre columnas son comas, sep=&quot;;&quot; para indicar que las separaciones entre columnas son signos de punto y coma, y sep=&quot;\\t&quot; para indicar que las separaciones entre columnas son tabuladores. header. Si la tabla que importamos tiene una primera fila con los nombres de las columnas, es conveniente especificarlo con el parámetro header=TRUE; en caso contrario, y según cómo esté formateado el fichero, puede que R entienda la fila de los nombres de las variables como la primera fila de observaciones. Si, en cambio, las columnas de la tabla que importamos no tienen nombre, no hace falta especificar el parámetro header (o usar header=FALSE, que es su valor por defecto), y después ya pondremos nombres a las variables con la función names (véase la Sección 6.4). dec. Como ya explicamos en la función scan, podemos usar el parámetro dec para especificar el separador decimal, si no es un punto. stringsAsFactors. Por defecto, read.table transforma en factores las columnas de palabras de la tabla que importa. Para impedir esta transformación, de manera que los vectores de palabras se importen como tales, podemos usar stringsAsFactors=FALSE. encoding. Como también ya explicamos en la función scan (página ), este parámetro sirve para indicar la codificación de alfabeto del fichero que se va a importar, y se ha de usar si dicho fichero contiene palabras con letras acentuadas o caracteres especiales y su codificación no coincide con la que espera nuestro ordenador: lo notaremos porque si importamos el fichero sin especificar este parámetro, los acentos se importan mal. Como los ficheros externos que usamos en este curso están codificados en utf8, los usuarios de Windows de vez en cuando tendrán que usar encoding=&quot;latin1&quot;. Avisaremos cada vez que sea necesario. Para otros parámetros, podéis consultar la Ayuda de read.table. Vamos a ilustrar el uso de esta función. Descargad en vuestro directorio de trabajo de R los dos ficheros siguientes, manteniendo sus nombres y extensiones: http://aprender.uib.es/Rdir/NotaHermanos.txt http://aprender.uib.es/Rdir/NotaHermanosc.txt Ambos ficheros son básicamente la misma tabla de datos, que recoge, para algunos estudiantes de primer curso de la UIB de hace unos años, el grado en el que estaban matriculados (Biología, &lt;&gt;, o Bioquímica, &lt;&gt;), su número de hermanos y la nota que obtuvieron en un determinado examen; la diferencia es que, en el primero, las columnas están separadas por espacios en blanco, y en el segundo, por comas. Ambos ficheros contienen una primera fila con los nombres de las variables. Están codificados en utf8, pero como no contienen letras acentuadas ni caracteres especiales, no tenéis que preocuparos por su codificación. Para crear un data frame llamado NH1 a partir de la copia local del fichero NotaHermanos.txt, basta aplicar la función read.table a su nombre entre comillas y especificar header=TRUE. NH1=read.table(&quot;NotaHermanos.txt&quot;, header=TRUE) Es una buena costumbre, una vez definido un data frame a partir de un fichero externo, comprobar que se ha importado bien. Como una tabla de datos puede tener muchas filas, verla entera en la consola puede ser poco práctico; lo mejor es usar las funciones str y View o head. Os aconsejamos que, siempre que vayáis a trabajar con un data frame, le echéis antes un vistazo con estas funciones para comprobar su estructura, los nombres de sus variables, los tipos de sus datos, etc. Esto es especialmente importante cuando se trata de data frames importados, porque si no hemos especificado los parámetros adecuados, puede que en el proceso de lectura y definición del data frame se hayan perdido los nombres de las variables o la estructura de columnas. head(NH1) ## Grado Hermanos Nota ## 1 BQ 1 93 ## 2 BL 1 35 ## 3 BL 1 55 ## 4 BL 1 77 ## 5 BL 2 81 ## 6 BQ 0 86 str(NH1) ## &#39;data.frame&#39;: 87 obs. of 3 variables: ## $ Grado : Factor w/ 2 levels &quot;BL&quot;,&quot;BQ&quot;: 2 1 1 1 1 2 2 1 1 1 ... ## $ Hermanos: int 1 1 1 1 2 0 1 1 1 1 ... ## $ Nota : int 93 35 55 77 81 86 97 40 16 31 ... Si no hubiéramos especificado header=TRUE, el formato del data frame resultante no habría sido el adecuado. NH1.mal=read.table(&quot;NotaHermanos.txt&quot;) str(NH1.mal) ## &#39;data.frame&#39;: 88 obs. of 3 variables: ## $ V1: Factor w/ 3 levels &quot;BL&quot;,&quot;BQ&quot;,&quot;Grado&quot;: 3 2 1 1 1 1 2 2 1 1 ... ## $ V2: Factor w/ 6 levels &quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,..: 6 2 2 2 2 3 1 2 2 2 ... ## $ V3: Factor w/ 50 levels &quot;10&quot;,&quot;100&quot;,&quot;11&quot;,..: 50 48 13 26 38 41 45 49 17 4 ... Sin el parámetro header=TRUE, R ha entendido que Grado, Hermanos y Nota son elementos de sus columnas respectivas, y no sus nombres; en consecuencia, por un lado, ha llamado por defecto V1, V2 y V3 a las columnas del data frame, y por otro, como Grado, Hermanos y Nota son palabras y los datos de cada variable de un data frame han de ser del mismo tipo, ha considerado que todas las entradas de cada columna eran palabras. Finalmente, como, al crear un data frame, R interpreta los vectores de palabras como factores si no especificamos lo contrario, hemos obtenido un data frame formado por tres factores, y hemos perdido la información numérica que contenían las columnas con el número de hermanos y la nota. Para importar el fichero NotaHermanosc.txt, donde las columnas están separadas por comas, hay que usar el parámetro sep=&quot;,&quot;. NH2=read.table(&quot;NotaHermanosc.txt&quot;, header=TRUE, sep=&quot;,&quot;) str(NH2) ## &#39;data.frame&#39;: 87 obs. of 3 variables: ## $ Grado : Factor w/ 2 levels &quot;BL&quot;,&quot;BQ&quot;: 2 1 1 1 1 2 2 1 1 1 ... ## $ Hermanos: int 1 1 1 1 2 0 1 1 1 1 ... ## $ Nota : int 93 35 55 77 81 86 97 40 16 31 ... Sin este parámetro, R hubiera entendido cada fila como una sola palabra. NH2.mal=read.table(&quot;NotaHermanosc.txt&quot;, header=TRUE) str(NH2.mal) ## &#39;data.frame&#39;: 87 obs. of 1 variable: ## $ Grado.Hermanos.Nota: Factor w/ 71 levels &quot;BL,0,20&quot;,&quot;BL,0,40&quot;,..: 62 12 18 24 38 47 63 15 9 11 ... Veamos el efecto de stringsAsFactors=FALSE: NH3=read.table(&quot;NotaHermanosc.txt&quot;, header=TRUE, sep=&quot;,&quot;, stringsAsFactors=FALSE) str(NH3) ## &#39;data.frame&#39;: 87 obs. of 3 variables: ## $ Grado : chr &quot;BQ&quot; &quot;BL&quot; &quot;BL&quot; &quot;BL&quot; ... ## $ Hermanos: int 1 1 1 1 2 0 1 1 1 1 ... ## $ Nota : int 93 35 55 77 81 86 97 40 16 31 ... La variable Grado se ha importado como un vector de palabras: lo indica el chr, de character, en la fila correspondiente del resultado de str. Para importar las versiones de Internet de estos ficheros, tendríamos que usar las mismas instrucciones, cambiando el nombre del fichero por su url , siempre entre comillas. Por ejemplo: NH4=read.table(&quot;http://aprender.uib.es/Rdir/NotaHermanos.txt&quot;, header=TRUE) str(NH4) ## &#39;data.frame&#39;: 87 obs. of 3 variables: ## $ Grado : Factor w/ 2 levels &quot;BL&quot;,&quot;BQ&quot;: 2 1 1 1 1 2 2 1 1 1 ... ## $ Hermanos: int 1 1 1 1 2 0 1 1 1 1 ... ## $ Nota : int 93 35 55 77 81 86 97 40 16 31 ... Naturalmente, para poder importar un fichero de Internet, hay que estar conectados a Internet, el servidor que aloja el fichero tiene que funcionar, y además no tiene que requerir una palabra clave para acceder. Figura 6.2: Importador de tablas de datos del Rstudio. El menú &lt;&lt;Import Dataset&gt;&gt;, de la pestaña Environment o del menú &lt;&lt;Tools&gt;&gt;, es equivalente a la función read.table para ficheros que contengan tablas de datos de formatos sencillos. Al seleccionar dicho menú, se nos permite entrar un url o navegar por el ordenador para escoger el fichero. Al hacerlo, se abre una ventana como la de la Figura 6.2 donde, entre otras acciones: Podemos poner nombre al data frame (en el campo Name ). Podemos especificar la codificación de alfabeto del fichero (en el campo Encoding ). Podemos indicar si tiene una primera fila con los nombres de las variables (en el campo Heading ). Podemos especificar el signo que separa las columnas (en el campo Separator ) y el signo que separa la parte entera de la decimal (en el campo Decimal ). Podemos indicar si los vectores de palabras se han de convertir en factores (marcándolo en Strings as factors ). La ventaja de este menú es que en su campo superior derecho vemos el fichero original, lo que nos ayuda a rellenar los campos anteriores, y en el inferior derecho vemos el aspecto del data frame que creamos con nuestras elecciones. Su inconveniente es que, si queremos que nuestro análisis de datos sea reproducible por otras personas, es necesario incluir en el guión que publiquemos la función read.table con los parámetros exactos que hemos usado. Además de read.table, que sólo sirve para importar tablas en formato texto simple, R dispone de otras instrucciones similares para importar otros tipos de ficheros. Las más útiles son: read.csv, para importar ficheros en formato CSV. read.xls y read.xlsx, del paquete xlsx, para importar hojas de cálculo tipo Excel u OpenOffice en formato XLS o XLSX, respectivamente. Estas funciones usan Java; si no lo tenéis instalado y no lo queréis instalar, lo mejor es que guardéis la hoja de cálculo en formato CSV (tanto Excel como OpenOffice o Numbers ofrecen esta posibilidad) y uséis read.csv. read.mtb y read.spss, del paquete foreign, para importar tablas de datos de Minitab y SPSS, respectivamente. Si necesitáis otras funciones de este tipo, entrad help.search(read), buscad la función que os convenga y consultad su Ayuda. Podemos exportar un data frame a un fichero usando la función write.table. Su sintaxis básica es write.table(, file=&quot;nombre del fichero&quot;). Esta función crea un fichero, en el directorio de trabajo de R, que contiene el data frame que hemos especificado en el argumento, y lo llama el nombre que hemos especificado en file. Además, podemos usar el parámetro sep para indicar el signo de separación de columnas en el fichero que creemos y el parámetro dec para indicar el separador decimal; por ejemplo, A=iris[1:5, 1:4] A ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 1 5.1 3.5 1.4 0.2 ## 2 4.9 3.0 1.4 0.2 ## 3 4.7 3.2 1.3 0.2 ## 4 4.6 3.1 1.5 0.2 ## 5 5.0 3.6 1.4 0.2 write.table(A, file=&quot;trozoiris.txt&quot;) guarda el data frame \\(A\\) en un fichero llamado trozoiris.txt. Ahora podemos volver a importar este fichero. B=read.table(&quot;trozoiris.txt&quot;, header=TRUE) #Importamos la tabla B ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 1 5.1 3.5 1.4 0.2 ## 2 4.9 3.0 1.4 0.2 ## 3 4.7 3.2 1.3 0.2 ## 4 4.6 3.1 1.5 0.2 ## 5 5.0 3.6 1.4 0.2 6.3 Cómo crear data frames Además de trabajar con data frames importados o predefinidos, también podemos crearlos; para ello, organizaremos en forma de tabla algunos vectores, cada uno de los cuales contendrá las observaciones de una variable para un conjunto de individuos o casos, y de manera que los datos en todos estos vectores estén en el mismo orden de los individuos: es decir, que la primera entrada de cada vector corresponda a un mismo individuo, la segunda entrada de cada vector corresponda a otro mismo individuo, y así sucesivamente. Para construir un data frame a partir de unos vectores, se usa la función data.frame aplicada a los vectores en el orden en el que queramos disponer las columnas de la tabla; de esta manera, las variables tomarán los nombres de los vectores. Estos nombres también se pueden especificar en el argumento de la función data.frame, entrando cada columna con una construcción de la forma Nombre de la variable=Vector con el contenido de la variable. Vamos a ilustrar esta función con un ejemplo sencillo, que arrastraremos durante buena parte de lo que queda de lección. Vamos a construir un data frame que contenga algunos datos sobre estudiantes; concretamente, este data frame tendrá tres variables: una primera columna con el sexo del estudiante, la segunda columna con su edad en años y la tercera con su número de hermanos. Sexo=c(&quot;Hombre&quot;,&quot;Hombre&quot;,&quot;Mujer&quot;,&quot;Hombre&quot;,&quot;Hombre&quot;, &quot;Hombre&quot;,&quot;Mujer&quot;) Edad=c(17,18,20,18,18,18,19) Hermanos=c(2,0,0,1,1,1,0) d.f1=data.frame(Sexo, Edad, Hermanos) d.f1 ## Sexo Edad Hermanos ## 1 Hombre 17 2 ## 2 Hombre 18 0 ## 3 Mujer 20 0 ## 4 Hombre 18 1 ## 5 Hombre 18 1 ## 6 Hombre 18 1 ## 7 Mujer 19 0 Puesto que iremos modificando este data frame, vamos a guardar una copia de seguridad (un backup) en d.f1bk para poder recuperar su estado original si lo necesitamos. d.f1bk=d.f1 Es muy prudente y recomendable que guardéis siempre copias de seguridad de los data frames que generéis si vais a manipularlos, porque hay cambios en un data frame que son irreversibles y, por lo tanto, si os arrepentís de haber hecho algún cambio, bien podría ser que no lo pudierais deshacer. Vamos a consultar algunas características del data frame d.f1. str(d.f1) ## &#39;data.frame&#39;: 7 obs. of 3 variables: ## $ Sexo : Factor w/ 2 levels &quot;Hombre&quot;,&quot;Mujer&quot;: 1 1 2 1 1 1 2 ## $ Edad : num 17 18 20 18 18 18 19 ## $ Hermanos: num 2 0 0 1 1 1 0 rownames(d.f1) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; Vemos que la primera variable es un factor con dos niveles, y las otras dos son vectores numéricos (num). Vemos también que R ha asignado como identificadores de las filas los números del 1 al 7, pero los considera palabras. La función data.frame dispone de algunos parámetros que permiten ajustar a nuestras necesidades el data frame que creamos. Los más útiles son los siguientes: row.names. Sirve para especificar los identificadores de las filas. stringsAsFactors. Por defecto, data.frame convierte los vectores de palabras en factores. Con stringsAsFactors=FALSE, imponemos que los vectores de palabras se mantengan como tales en el data frame Veamos un ejemplo de aplicación de estos dos parámetros. d.f2=data.frame(Sexo, Edad, Hermanos, stringsAsFactors=FALSE, row.names=c(&quot;E1&quot;,&quot;E2&quot;,&quot;E3&quot;,&quot;E4&quot;,&quot;E5&quot;,&quot;E6&quot;,&quot;E7&quot;)) d.f2 ## Sexo Edad Hermanos ## E1 Hombre 17 2 ## E2 Hombre 18 0 ## E3 Mujer 20 0 ## E4 Hombre 18 1 ## E5 Hombre 18 1 ## E6 Hombre 18 1 ## E7 Mujer 19 0 str(d.f2) ## &#39;data.frame&#39;: 7 obs. of 3 variables: ## $ Sexo : chr &quot;Hombre&quot; &quot;Hombre&quot; &quot;Mujer&quot; &quot;Hombre&quot; ... ## $ Edad : num 17 18 20 18 18 18 19 ## $ Hermanos: num 2 0 0 1 1 1 0 d.f2$Sexo ## [1] &quot;Hombre&quot; &quot;Hombre&quot; &quot;Mujer&quot; &quot;Hombre&quot; &quot;Hombre&quot; &quot;Hombre&quot; &quot;Mujer&quot; Como vemos, el efecto de stringsAsFactors=FALSE ha sido que la variable sexo es ahora un vector de palabras, y el del parámetro row.names ha sido llamar E1,E2,...,E7 a las filas. Si hemos asignado identificadores a las filas, podemos usarlos para extraer subtablas del data frame (aunque también podemos seguir usando los números de las filas). Recordad que, si usáis los identificadores, como son palabras, hay que escribirlos entre comillas. d.f2[c(&quot;E1&quot;,&quot;E2&quot;), ] #Subtabla con las filas E1 y E2 ## Sexo Edad Hermanos ## E1 Hombre 17 2 ## E2 Hombre 18 0 Otra manera de crear un data frame con R es usando el editor de datos del que ya hemos hablado en la Lección 4.28 Recordaréis que, para abrir un objeto de datos con este editor, se le aplica la función fix. R abre entonces el objeto en una nueva ventana de edición. Los cambios que realicemos en un objeto con el editor de datos se guardarán cuando cerremos esta ventana. Para crear un data frame con el editor de datos, lo primero que hay que hacer es crear un data frame con la primera fila, y luego abrirlo con el editor para ir añadiendo filas (y columnas, si se desea). La apariencia exacta de esta ventana y la manera de editar el data frame dependen de la interfaz de R que se use; por ejemplo, en el Rstudio de Mac OS X, entraríamos d.f3=data.frame(Sexo=c(&quot;Hombre&quot;), Edad=c(17), Hermanos=c(2)) fix(d.f3) y se abriría la ventana que muestra la Figura 6.3. Figura 6.3: Editor de data frames de Rstudio en Mac OS X. 6.4 Cómo modificar un data frame En esta sección veremos la manera de modificar un data frame una vez creado o importado. Para cambiar los nombres de las variables, podemos usar la instrucción names(data frame)=vector con los nombres de las variables. Volvamos al d.f1. Tras recordar su estructura, cambiaremos los nombres de sus variables, sustituyéndolos por sus iniciales, y volveremos a consultar su estructura para ver cómo han cambiado estos nombres. str(d.f1) ## &#39;data.frame&#39;: 7 obs. of 3 variables: ## $ Sexo : Factor w/ 2 levels &quot;Hombre&quot;,&quot;Mujer&quot;: 1 1 2 1 1 1 2 ## $ Edad : num 17 18 20 18 18 18 19 ## $ Hermanos: num 2 0 0 1 1 1 0 names(d.f1)=c(&quot;S&quot;,&quot;E&quot;,&quot;H&quot;) str(d.f1) ## &#39;data.frame&#39;: 7 obs. of 3 variables: ## $ S: Factor w/ 2 levels &quot;Hombre&quot;,&quot;Mujer&quot;: 1 1 2 1 1 1 2 ## $ E: num 17 18 20 18 18 18 19 ## $ H: num 2 0 0 1 1 1 0 Si sólo queremos cambiar el nombre de algunas variables, basta redefinir el trozo correspondiente del vector names. Así, si en la nueva copia de d.f1 queremos volver a cambiar el nombre de la variable E por Edad, podríamos usar una de las dos instrucciones siguientes: names(d.f1)[2]=&quot;Edad&quot; o names(d.f1)[names(d.f1)==&quot;E&quot;]=&quot;Edad&quot;. Con la primera, cambiaríamos el nombre de la segunda variable por Edad; con la segunda, cambiaríamos el nombre de la variable llamada E por Edad. Para modificar los identificadores de las filas, podemos usar la instrucción rownames(data frame)=vector con los nombres de las filas. Como cada identificador ha de determinar el individuo al que corresponde la fila, conviene que estos identificadores sean todos diferentes. rownames(d.f1)=paste(&quot;Alumno&quot;, 1:7, sep=&quot; &quot;) d.f1 ## S E H ## Alumno 1 Hombre 17 2 ## Alumno 2 Hombre 18 0 ## Alumno 3 Mujer 20 0 ## Alumno 4 Hombre 18 1 ## Alumno 5 Hombre 18 1 ## Alumno 6 Hombre 18 1 ## Alumno 7 Mujer 19 0 Como podéis deducir de su efecto, la función paste pega vectores, entrada a entrada, usando como separador el valor del parámetro sep; el separador por defecto es un espacio en blanco, por lo que no hubiera hecho falta especificarlo, lo hemos hecho sólo para mostrar el parámetro. Si en lugar de pegar un vector pegamos un elemento, éste se entiende como un vector constante formado por el número adecuado de copias. Podemos modificar los nombres de las filas y de las columnas simultáneamente con la instrucción dimnames(dataframe)=list(vector con los nombres de las filas, vector con los nombres de las columnas). Por ejemplo, vamos a cambiar de golpe en d.f1 los identificadores de las filas, para que ahora sean números romanos, y los nombres de las variables, para que pasen a ser V1,V2,V3: dimnames(d.f1)=list(c(&quot;I&quot;,&quot;II&quot;,&quot;III&quot;,&quot;IV&quot;,&quot;V&quot;,&quot;VI&quot;,&quot;VII&quot;), c(&quot;V1&quot;,&quot;V2&quot;,&quot;V3&quot;)) d.f1 ## V1 V2 V3 ## I Hombre 17 2 ## II Hombre 18 0 ## III Mujer 20 0 ## IV Hombre 18 1 ## V Hombre 18 1 ## VI Hombre 18 1 ## VII Mujer 19 0 Para modificar entradas concretas de un data frame, podemos usar el editor de datos que se abre con fix, o podemos usar instrucciones similares a las que usábamos en los vectores y las matrices para modificar entradas. d.f1=d.f1bk #Volvemos a la copia guardada d.f1[1,2]=&quot;Joven&quot; #Sustituimos la entrada (1,2) por la palabra &quot;Joven&quot; str(d.f1) ## &#39;data.frame&#39;: 7 obs. of 3 variables: ## $ Sexo : Factor w/ 2 levels &quot;Hombre&quot;,&quot;Mujer&quot;: 1 1 2 1 1 1 2 ## $ Edad : chr &quot;Joven&quot; &quot;18&quot; &quot;20&quot; &quot;18&quot; ... ## $ Hermanos: num 2 0 0 1 1 1 0 ¡Vaya! Al introducir un dato de tipo palabra en la variable Edad, toda la columna ha pasado a ser un vector de palabras: recordemos que R considera del mismo tipo de datos todas las entradas de una columna de un data frame; y ahora ya no lo podemos arreglar volviendo a poner un número: d.f1[1,2]=17 str(d.f1) ## &#39;data.frame&#39;: 7 obs. of 3 variables: ## $ Sexo : Factor w/ 2 levels &quot;Hombre&quot;,&quot;Mujer&quot;: 1 1 2 1 1 1 2 ## $ Edad : chr &quot;17&quot; &quot;18&quot; &quot;20&quot; &quot;18&quot; ... ## $ Hermanos: num 2 0 0 1 1 1 0 Parece que hemos estropeado definitivamente el data frame d.f1. Pero no es así: simplemente tenemos que volver a redefinir la variable Edad como un vector numérico. Para modificar una columna entera, hay que igualar su nombre (que, recordemos, se especifica añadiendo al nombre del data frame el sufijo formado por el signo $ seguido del nombre de la variable dentro del data frame) a su nuevo valor: data frame$variable=nuevo valor`. Este nuevo valor puede ser el resultado de un cambio de tipo de datos aplicado a la variable. R dispone de una serie de funciones de la forma as.tipo_de_objeto, que convierten el objeto al tipo que expresa el nombre de la función. Ya hemos visto en la Sección 4.4 la función as.factor, que transforma un vector en un factor. Otras funciones de este estilo son as.character, as.integer o as.numeric, que transforman todos los datos de un objeto en palabras, números enteros o números reales, respectivamente. Así, para transformar la variable Edad de la última versión estropeada de d.f1 en un vector numérico, basta entrar lo siguiente: d.f1$Edad=as.numeric(d.f1$Edad) str(d.f1) ## &#39;data.frame&#39;: 7 obs. of 3 variables: ## $ Sexo : Factor w/ 2 levels &quot;Hombre&quot;,&quot;Mujer&quot;: 1 1 2 1 1 1 2 ## $ Edad : num 17 18 20 18 18 18 19 ## $ Hermanos: num 2 0 0 1 1 1 0 Un error típico al intentar modificar la variable Edad es entrar sólo as.numeric(d.f1$Edad); con esta instrucción, obtenemos como resultado el vector \\(17,18, 20, 18, 18, 18, 19\\), pero no se modifica la variable Edad del data frame Tampoco sirve entrar Edad=as.numeric(d.f1$Edad), porque esto define un vector llamado Edad de entradas \\(17,18, 20, 18, 18, 18, 19\\), pero sigue sin modificar la variable Edad del data frame La manera correcta de hacerlo es mediante data frame$variable =nuevo valor . Veamos otros ejemplos. Vamos a convertir la variable Sexo en un vector de palabras: d.f1$Sexo=as.character(d.f1$Sexo) str(d.f1) ## &#39;data.frame&#39;: 7 obs. of 3 variables: ## $ Sexo : chr &quot;Hombre&quot; &quot;Hombre&quot; &quot;Mujer&quot; &quot;Hombre&quot; ... ## $ Edad : num 17 18 20 18 18 18 19 ## $ Hermanos: num 2 0 0 1 1 1 0 Y ahora vamos a convertir la variable Hermanos en un factor ordenado: d.f1$Hermanos=ordered(d.f1$Hermanos, levels=c(0,1,2)) str(d.f1) ## &#39;data.frame&#39;: 7 obs. of 3 variables: ## $ Sexo : chr &quot;Hombre&quot; &quot;Hombre&quot; &quot;Mujer&quot; &quot;Hombre&quot; ... ## $ Edad : num 17 18 20 18 18 18 19 ## $ Hermanos: Ord.factor w/ 3 levels &quot;0&quot;&lt;&quot;1&quot;&lt;&quot;2&quot;: 3 1 1 2 2 2 1 Naturalmente, podemos cambiar el contenido de toda una variable de otras maneras que no sea sólo modificar su tipo de datos: basta igualarla a su nuevo valor. d.f1$Edad=&quot;Joven&quot; d.f1 ## Sexo Edad Hermanos ## 1 Hombre Joven 2 ## 2 Hombre Joven 0 ## 3 Mujer Joven 0 ## 4 Hombre Joven 1 ## 5 Hombre Joven 1 ## 6 Hombre Joven 1 ## 7 Mujer Joven 0 Al igualar la variable Edad a la palabra &lt;&gt;, la ha substituido por el correspondiente vector constante. 6.5 Cómo añadir filas y columnas a un data frame Podemos añadir filas a un data frame definiéndolas con data frame[fila, ]=c(...); pero esta construcción no es muy recomendable, porque si no vamos con cuidado puede provocar resultados no deseados: Las filas que añadimos de esta manera son vectores, y por lo tanto sus entradas han de ser todas del mismo tipo. Por consiguiente, esta opción sólo se puede usar en data frames cuyas variables contengan todas el mismo tipo de datos. Si no añadimos las filas inmediatamente siguientes a la última del data frame, los valores entre su última fila y las que añadimos quedarán no definidos, y aparecerán como NA; esto puede ser un problema a la hora de aplicar funciones al data frame y además estropea los factores. La mejor manera de añadir filas a un data frame es organizándolas en un nuevo data frame con los mismos nombres de las variables, y a continuación concatenarlas al data frame usando la función rbind que ya usábamos para matrices. d.f1=d.f1bk #Volvemos a la copia original d.f1 ## Sexo Edad Hermanos ## 1 Hombre 17 2 ## 2 Hombre 18 0 ## 3 Mujer 20 0 ## 4 Hombre 18 1 ## 5 Hombre 18 1 ## 6 Hombre 18 1 ## 7 Mujer 19 0 nuevas.filas=data.frame(Sexo=c(&quot;Hombre&quot;,&quot;Hombre&quot;), Edad=c(18,18), Hermanos=c(1,2)) d.f1=rbind(d.f1, nuevas.filas) d.f1 ## Sexo Edad Hermanos ## 1 Hombre 17 2 ## 2 Hombre 18 0 ## 3 Mujer 20 0 ## 4 Hombre 18 1 ## 5 Hombre 18 1 ## 6 Hombre 18 1 ## 7 Mujer 19 0 ## 8 Hombre 18 1 ## 9 Hombre 18 2 str(d.f1) #Los tipos de las variables no han cambiado ## &#39;data.frame&#39;: 9 obs. of 3 variables: ## $ Sexo : Factor w/ 2 levels &quot;Hombre&quot;,&quot;Mujer&quot;: 1 1 2 1 1 1 2 1 1 ## $ Edad : num 17 18 20 18 18 18 19 18 18 ## $ Hermanos: num 2 0 0 1 1 1 0 1 2 Para añadir una variable, basta especificar el valor de la columna correspondiente; por ejemplo, vamos a añadir a d.f1 una nueva variable llamada Nueva con el producto de la edad por el número de hermanos: d.f1$Nueva=d.f1$Edad*d.f1$Hermanos d.f1 ## Sexo Edad Hermanos Nueva ## 1 Hombre 17 2 34 ## 2 Hombre 18 0 0 ## 3 Mujer 20 0 0 ## 4 Hombre 18 1 18 ## 5 Hombre 18 1 18 ## 6 Hombre 18 1 18 ## 7 Mujer 19 0 0 ## 8 Hombre 18 1 18 ## 9 Hombre 18 2 36 También podemos concatenar columnas a un data frame usando la función cbind; en este caso, se puede añadir directamente la columna, sin necesidad de convertirla previamente en un data frame La variable añadida ha de tener la misma longitud que las variables del data frame original; en caso contrario, se añadirán valores NA a las variables del data frame original o a la variable que añadimos hasta completar la misma longitud. d.f1=cbind(d.f1, Grado=rep(&quot;Biología&quot;,9)) d.f1 ## Sexo Edad Hermanos Nueva Grado ## 1 Hombre 17 2 34 Biología ## 2 Hombre 18 0 0 Biología ## 3 Mujer 20 0 0 Biología ## 4 Hombre 18 1 18 Biología ## 5 Hombre 18 1 18 Biología ## 6 Hombre 18 1 18 Biología ## 7 Mujer 19 0 0 Biología ## 8 Hombre 18 1 18 Biología ## 9 Hombre 18 2 36 Biología str(d.f1) ## &#39;data.frame&#39;: 9 obs. of 5 variables: ## $ Sexo : Factor w/ 2 levels &quot;Hombre&quot;,&quot;Mujer&quot;: 1 1 2 1 1 1 2 1 1 ## $ Edad : num 17 18 20 18 18 18 19 18 18 ## $ Hermanos: num 2 0 0 1 1 1 0 1 2 ## $ Nueva : num 34 0 0 18 18 18 0 18 36 ## $ Grado : Factor w/ 1 level &quot;Biología&quot;: 1 1 1 1 1 1 1 1 1 Finalmente, hay que recordar que también podemos usar el editor de datos para añadir (o eliminar) filas o columnas a un data frame 6.6 Cómo seleccionar trozos de un data frame Veamos ahora con más detalle cómo podemos extraer trozos de un data frame; el método básico es similar al que usábamos en las matrices. De hecho, para seleccionar un trozo de un data frame, podemos hacerlo exactamente como en las matrices, especificando los índices de las filas y columnas que nos interesen dentro de corchetes [ , ]. Pero como los individuos y las variables tienen nombres, también podemos usarlos para especificar filas y columnas. Por ejemplo, supongamos que queremos crear un nuevo data frame formado por las dos primeras filas de d.f1; podríamos hacerlo, al menos, de las tres maneras siguientes: d.f1=d.f1bk #Volvemos a la copia original d.f1[1:2, ] #Con los índices de las filas ## Sexo Edad Hermanos ## 1 Hombre 17 2 ## 2 Hombre 18 0 d.f1[c(&quot;1&quot;,&quot;2&quot;), ] #Con los identificadores de las filas ## Sexo Edad Hermanos ## 1 Hombre 17 2 ## 2 Hombre 18 0 d.f1[rownames(d.f1)[1:2], ] #Con un subvector del vector de identificadores de las filas ## Sexo Edad Hermanos ## 1 Hombre 17 2 ## 2 Hombre 18 0 Podemos usar este tipo de instrucciones para obtener las filas en un orden diferente del que presentan en el data frame original. d.f1[c(2,3,1), ] ## Sexo Edad Hermanos ## 2 Hombre 18 0 ## 3 Mujer 20 0 ## 1 Hombre 17 2 También podemos seleccionar filas de un data frame mediante una condición lógica; en este caso, nos quedaremos sólo con los individuos que satisfagan esta condición. Por ejemplo, si queremos seleccionar los estudiantes de d.f1 de menos de 19 años, podemos usar la construcción siguiente: d.f1[d.f1$Edad&lt;19, ] ## Sexo Edad Hermanos ## 1 Hombre 17 2 ## 2 Hombre 18 0 ## 4 Hombre 18 1 ## 5 Hombre 18 1 ## 6 Hombre 18 1 Esta condición lógica puede involucrar más de una variable. d.f1[d.f1$Edad&lt;19 &amp; d.f1$Hermanos==1, ] ## Sexo Edad Hermanos ## 4 Hombre 18 1 ## 5 Hombre 18 1 ## 6 Hombre 18 1 En cada caso, hemos obtenido un data frame Vamos a llamar d.f.18 al primero. d.f.18=d.f1[d.f1$Edad&lt;19, ] d.f.18 ## Sexo Edad Hermanos ## 1 Hombre 17 2 ## 2 Hombre 18 0 ## 4 Hombre 18 1 ## 5 Hombre 18 1 ## 6 Hombre 18 1 str(d.f.18) ## &#39;data.frame&#39;: 5 obs. of 3 variables: ## $ Sexo : Factor w/ 2 levels &quot;Hombre&quot;,&quot;Mujer&quot;: 1 1 1 1 1 ## $ Edad : num 17 18 18 18 18 ## $ Hermanos: num 2 0 1 1 1 Como vemos, las columnas que son factores heredan en estos sub data frames todos los niveles del factor original, aunque no aparezcan en el trozo que hemos extraído. Podemos borrar los niveles sobrantes de todos los factores redefiniendo el data frame como el resultado de aplicarle la función droplevels. d.f.18=droplevels(d.f.18) str(d.f.18) ## &#39;data.frame&#39;: 5 obs. of 3 variables: ## $ Sexo : Factor w/ 1 level &quot;Hombre&quot;: 1 1 1 1 1 ## $ Edad : num 17 18 18 18 18 ## $ Hermanos: num 2 0 1 1 1 Naturalmente, el mismo tipo de construcción se puede utilizar para definir un data frame formado sólo por algunas variables de la tabla original, o incluso por sólo algunas filas y columnas. Si sólo queremos definir la subtabla quedándonos con algunas variables, basta aplicar el nombre del data frame al vector de variables (sin necesidad de dejar el espacio en blanco seguido de una coma que serviría para indicar que nos referimos a columnas y no a filas); por ejemplo, con las cuatro instrucciones siguientes obtenemos cada vez el mismo resultado, un data frame formado por las dos primeras variables de d.f1: d.f1[ , c(1,2)] #Con la coma ## Sexo Edad ## 1 Hombre 17 ## 2 Hombre 18 ## 3 Mujer 20 ## 4 Hombre 18 ## 5 Hombre 18 ## 6 Hombre 18 ## 7 Mujer 19 d.f1[c(1,2)] #Sin la coma ## Sexo Edad ## 1 Hombre 17 ## 2 Hombre 18 ## 3 Mujer 20 ## 4 Hombre 18 ## 5 Hombre 18 ## 6 Hombre 18 ## 7 Mujer 19 d.f1[-3] #Eliminamos la tercera columna ## Sexo Edad ## 1 Hombre 17 ## 2 Hombre 18 ## 3 Mujer 20 ## 4 Hombre 18 ## 5 Hombre 18 ## 6 Hombre 18 ## 7 Mujer 19 d.f1[c(&quot;Sexo&quot;,&quot;Edad&quot;)] #Especificamos los nombres ## Sexo Edad ## 1 Hombre 17 ## 2 Hombre 18 ## 3 Mujer 20 ## 4 Hombre 18 ## 5 Hombre 18 ## 6 Hombre 18 ## 7 Mujer 19 Esta construcción se puede usar también para reordenar las columnas de un data frame ; por ejemplo: d.f1=d.f1[c(&quot;Edad&quot;,&quot;Hermanos&quot;,&quot;Sexo&quot;)] d.f1 ## Edad Hermanos Sexo ## 1 17 2 Hombre ## 2 18 0 Hombre ## 3 20 0 Mujer ## 4 18 1 Hombre ## 5 18 1 Hombre ## 6 18 1 Hombre ## 7 19 0 Mujer El paquete dplyr incluye la función select que amplía las posibilidades para especificar las variables que queremos extraer de un data frame; por ejemplo: select(data frame, starts_with(&quot;x&quot;)) extrae del data frame las variables cuyo nombre empieza con la palabra x. select(data frame, ends_with(&quot;x&quot;)) extrae del data frame las variables cuyo nombre termina con la palabra x. select(data frame, contains(&quot;x&quot;)) extrae del data frame las variables cuyo nombre contiene en algún sitio la palabra x. #Instalamos y cargamos el paquete &quot;dplyr&quot; #... library(dplyr) iris_Petal=select(iris, starts_with(&quot;Petal&quot;)) head(iris_Petal, 4) ## Petal.Length Petal.Width ## 1 1.4 0.2 ## 2 1.4 0.2 ## 3 1.3 0.2 ## 4 1.5 0.2 iris_Length=select(iris, ends_with(&quot;Length&quot;)) head(iris_Length, 4) ## Sepal.Length Petal.Length ## 1 5.1 1.4 ## 2 4.9 1.4 ## 3 4.7 1.3 ## 4 4.6 1.5 Para más información sobre otras habilidades de la función select, podéis consultar su Ayuda. Como podéis constatar, hay muchas maneras de extraer una misma subtabla de un data frame dado; veamos una última posibilidad, usando la función subset. La instrucción subset(dta frame, condición , select= columnas ) extrae del data frame las filas que cumplen la condición y las columnas especificadas en el select; si queremos todas las filas, no hay que especificar ninguna condición, y si queremos todas las columnas, no hace falta especificar el parámetro select. Así, si del data frame iris queremos extraer un data frame formado sólo por las plantas de especie virginica, podemos usar la instrucción siguiente: iris.vir=subset(iris, Species==&quot;virginica&quot;) head(iris.vir, 5) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 101 6.3 3.3 6.0 2.5 virginica ## 102 5.8 2.7 5.1 1.9 virginica ## 103 7.1 3.0 5.9 2.1 virginica ## 104 6.3 2.9 5.6 1.8 virginica ## 105 6.5 3.0 5.8 2.2 virginica Fijaos en que las variables en la condición se especifican con su nombre, sin añadir antes el nombre del data frame En este data frame, la variable Species es redundante, porque todos los individuos toman el mismo valor; por lo tanto, podríamos haberla eliminado al construirlo. iris.vir=subset(iris, Species==&quot;virginica&quot;, select=1:4) head(iris.vir, 5) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 101 6.3 3.3 6.0 2.5 ## 102 5.8 2.7 5.1 1.9 ## 103 7.1 3.0 5.9 2.1 ## 104 6.3 2.9 5.6 1.8 ## 105 6.5 3.0 5.8 2.2 Las filas de este data frame han heredado los identificadores del data frame iris. Si esto nos molesta, los podemos cambiar. rownames(iris.vir)=1:length(rownames(iris.vir)) head(iris.vir, 5) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 1 6.3 3.3 6.0 2.5 ## 2 5.8 2.7 5.1 1.9 ## 3 7.1 3.0 5.9 2.1 ## 4 6.3 2.9 5.6 1.8 ## 5 6.5 3.0 5.8 2.2 6.7 Cómo aplicar una función a las variables de un data frame La mejor manera de aplicar una función a todas las columnas de un data frame en un solo paso es por medio de la instrucción sapply(data frame, FUN=función ). A modo de ejemplo, vamos a aplicar algunas funciones a las columnas numéricas del data frame iris: str(iris) ## &#39;data.frame&#39;: 150 obs. of 5 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... sapply(iris[ ,1:4], FUN=mean) #Medias de las variables numéricas ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 5.843333 3.057333 3.758000 1.199333 sapply(iris[ ,1:4], FUN=sum) #Sumas de las variables numéricas ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 876.5 458.6 563.7 179.9 f=function(x){sqrt(sum(x^2))} sapply(iris[ ,1:4], FUN=f) #Normas euclídeas de las variables numéricas ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 72.27621 37.82063 50.82037 17.38764 Es conveniente añadir en el argumento de sapply el parámetro na.rm=TRUE, sin el cual el valor que devolverá la función para las columnas que contengan algún NA será NA. D=data.frame(V1=c(1,2,NA,3), V2=c(2,5,2,NA)) D ## V1 V2 ## 1 1 2 ## 2 2 5 ## 3 NA 2 ## 4 3 NA sapply(D, FUN=mean) ## V1 V2 ## NA NA sapply(D, FUN=mean, na.rm=TRUE) ## V1 V2 ## 2 3 A menudo querremos aplicar una función a variables de un data frame clasificadas por los niveles de un, o más de un, factor; esto se puede hacer con la instrucción aggregate, cuya sintaxis básica es aggregate(variable(s)~factor(es), data=data frame, FUN=función). El resultado será un data frame Por ejemplo, si queremos calcular las medias de las longitudes de los pétalos de las flores de cada una de las tres especies representadas en la tabla iris, podemos entrar la instrucción siguiente: aggregate(Petal.Length~Species, data=iris, FUN=mean, na.rm=TRUE) ## Species Petal.Length ## 1 setosa 1.462 ## 2 versicolor 4.260 ## 3 virginica 5.552 Hemos añadido na.rm=TRUE dentro del aggregate para que no tenga en cuenta los NA al calcular la media, por si acaso. Observad que el resultado es un data frame con variables Species y Petal.Length. Cada fila corresponde a un nivel del factor Species. Si queremos aplicar la función a más de una variable, tenemos que agruparlas a la izquierda de la tilde con cbind. aggregate(cbind(Petal.Length, Petal.Width)~Species, data=iris, FUN=mean) ## Species Petal.Length Petal.Width ## 1 setosa 1.462 0.246 ## 2 versicolor 4.260 1.326 ## 3 virginica 5.552 2.026 Si queremos separar las variables mediante más de un factor, tenemos que agruparlos a la derecha de la tilde con signos +: factor1+factor2+… . Veamos un ejemplo. El paquete alr4 contiene la tabla de datos Rateprof, con los resultados globales de la evaluación de un grupo de profesores universitarios por parte de sus estudiantes. Algunas de sus variables son: gender, el sexo del profesor; pepper, que indica si en las encuestas se le ha considerado mayoritariamente atractivo o no; y clarity y easiness, que valoran, entre 1 y 5, la claridad de exposición y la accesibilidad del profesor, respectivamente. Vamos a calcular las medias de estas dos últimas variables agrupándolas por sexo y atractivo. #Instalamos y cargamos el paquete &quot;alr4&quot; #... library(alr4) aggregate(cbind(clarity,easiness)~gender+pepper, data=Rateprof, FUN=mean) ## gender pepper clarity easiness ## 1 female no 3.341391 3.147606 ## 2 male no 3.451456 2.999056 ## 3 female yes 4.345082 3.599128 ## 4 male yes 4.371824 3.689741 Observamos que tanto la claridad como la accesibilidad medias de los profesores atractivos de ambos sexos son considerablemente mayores que las de sus colegas considerados no atractivos. Además, en promedio, se considera a los profesores no atractivos menos accesibles que a las profesoras no atractivas, y a los profesores atractivos más accesibles que a las profesoras atractivas. 6.8 Cómo añadir las variables de un data frame al entorno global Hasta ahora, cada vez que queríamos referirnos a una variable de un data frame, teníamos que escribir el nombre del data frame seguido de $ y el nombre de la variable. Aplicando attach a un data frame, hacemos que R entienda sus variables como globales y que las podamos usar por su nombre, sin necesidad de añadir delante el nombre del data frame y el signo $; esto puede ser útil para no tener que escribir mucho. A modo de ejemplo, vamos a añadir las variables del data frame iris al entorno global de R: &gt; Petal.Length Error: objeto &#39;Petal.Length&#39; no encontrado attach(iris) Petal.Length[1:30] ## [1] 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 1.5 1.6 1.4 1.1 1.2 1.5 1.3 ## [18] 1.4 1.7 1.5 1.7 1.5 1.0 1.7 1.9 1.6 1.6 1.5 1.4 1.6 Si ya hubiera existido una variable definida con el mismo nombre que una variable del data frame al que aplicamos attach, hubiéramos obtenido un mensaje de error al ejecutar esta función, y no se hubiera reescrito la variable global original. La función detach devuelve la situación original, eliminando del entorno global las variables del data frame &gt; detach(iris) &gt; Petal.Length Error: object &#39;Petal.Length&#39; not found 6.9 &lt;&lt;Big data&gt;&gt; frames con data.table (opcional). Aunque la manera usual de trabajar en R con tablas de datos es en forma de data frame, su estructura interna los hace poco eficientes a la hora de manejar las tablas de datos de millones de entradas que empiezan a ser habituales en estos tiempos de proyectos big data. Una solución es usar la clase de objetos para definir tablas de datos que incorpora el paquete data.table; para distinguirlos de los data frame, llamaremos a estos objetos data tables. Un data table vendría a ser un data frame enriquecido, con la particularidad de que sus filas no tienen identificadores; en particular se pueden usar con ellos todas las construcciones y funciones para data frames , pero esto no es lo recomendable, puesto que entonces no se gana nada usándolos. Los data tables ofrecen unas construcciones específicas para extraer subtablas, añadir, borrar o modificar variables, y aplicar operaciones a variables, que son mucho más eficientes que las propias de los data frames ; su sintaxis es muy diferente de la usada en matrices o data frames , pero vale la pena &lt;&gt; si necesitáis trabajar con tablas realmente grandes. Se puede crear un data table de varias maneras: Aplicando la función data.table a un conjunto de vectores, exactamente igual como si usáramos data.frame. Aplicando la función data.table a un data frame Como hemos comentado, las filas de los data tables no tienen identificadores; si las del data frame tenían identificadores que no fueran números correlativos, se copian como una variable extra llamada rn (de rownames). Importando un fichero externo con la función fread, exactamente igual como si usáramos read.table. Algunas ventajas de fread son que detecta automáticamente los separadores de columnas y si el fichero contiene o no una primera fila con los nombres de las variables, aunque su ventaja principal es la rapidez: tablas de varios Gb, que con read.table tardan varias horas en importarse, con fread tardan pocos minutos. Es importante tener en cuenta que, al contrario que read.table, la función fread importa por defecto las columnas de palabras como tales, y no como factores: esto se puede cambiar añadiendo stringsAsFactors=TRUE. Vamos a crear un data table para ilustrar su manejo básico. #Instalamos y cargamos el paquete &quot;data.table&quot; #... library(data.table) Letras=c(&quot;A&quot;,&quot;B&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;A&quot;,&quot;C&quot;,&quot;C&quot;,&quot;A&quot;,&quot;A&quot;) Var1=c(3,7,5,9,3,6,5,2,4,9) Var2=c(2.3,5.2,6.4,-2.2,1.6,7.1,3.2,-3.5,-2.7,1.8) Var3=c(6.8,6.4,5.5,6.2,5.3,7.8,6.3,6.3,6.3,7.5) DT=data.table(Letras,Var1,Var2,Var3) DT ## Letras Var1 Var2 Var3 ## 1: A 3 2.3 6.8 ## 2: B 7 5.2 6.4 ## 3: A 5 6.4 5.5 ## 4: A 9 -2.2 6.2 ## 5: B 3 1.6 5.3 ## 6: A 6 7.1 7.8 ## 7: C 5 3.2 6.3 ## 8: C 2 -3.5 6.3 ## 9: A 4 -2.7 6.3 ## 10: A 9 1.8 7.5 str(DT) ## Classes &#39;data.table&#39; and &#39;data.frame&#39;: 10 obs. of 4 variables: ## $ Letras: chr &quot;A&quot; &quot;B&quot; &quot;A&quot; &quot;A&quot; ... ## $ Var1 : num 3 7 5 9 3 6 5 2 4 9 ## $ Var2 : num 2.3 5.2 6.4 -2.2 1.6 7.1 3.2 -3.5 -2.7 1.8 ## $ Var3 : num 6.8 6.4 5.5 6.2 5.3 7.8 6.3 6.3 6.3 7.5 ## - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt; Una de las operaciones específicas más útiles para data tables es la creación de índices (keys) a partir de una o varias variables; estos índices sirven para identificar las filas y agilizan las búsquedas y extracciones de filas. La manera de indexar un data table es mediante la instrucción setkey(data table,variable1,variable2, ...). El resultado visible de esta instrucción es que R reordena las filas del data table en orden creciente de la variable1 y, en caso de empate, de la variable2, y así sucesivamente; las variables se han de entrar con su nombre sin entrecomillar. Fijaos también en que no igualamos el data table al resultado de setkey, simplemente le aplicamos esta función. setkey(DT,Letras,Var3) DT ## Letras Var1 Var2 Var3 ## 1: A 5 6.4 5.5 ## 2: A 9 -2.2 6.2 ## 3: A 4 -2.7 6.3 ## 4: A 3 2.3 6.8 ## 5: A 9 1.8 7.5 ## 6: A 6 7.1 7.8 ## 7: B 3 1.6 5.3 ## 8: B 7 5.2 6.4 ## 9: C 5 3.2 6.3 ## 10: C 2 -3.5 6.3 Vemos que las filas se han ordenado según su entrada en la variable Letras y, en los empates, según su entrada en Var3. A partir de ahora, las búsquedas de filas con valores concretos en estas variables se realizaría mediante búsqueda binaria usando esta ordenación. Este método es mucho más eficiente que el que usaría un data frame : visitaría toda la primera variable y generaría un vector de valores lógicos que indicara, para cada entrada, si cumple o no la condición; visitaría toda la segunda variable y generaría un segundo vector de valores lógicos que indicara, para cada entrada, si cumple o no la condición; generaría un tercer vector que tuviera un TRUE en aquellas entradas que lo tuvieran en cada uno de los vectores anteriores; finalmente, daría las filas correspondientes a los TRUE en este último vector. Una vez hemos indexado un data table, podemos usar las variables que hemos definido como índices para extraer filas. La conjunción de varias condiciones se indica con la función J; veamos varios ejemplos, observad la sintaxis: DT[&quot;B&quot;] #Filas con una B en Letras ## Letras Var1 Var2 Var3 ## 1: B 3 1.6 5.3 ## 2: B 7 5.2 6.4 DT[c(&quot;B&quot;,&quot;C&quot;)] #Filas con una B o una C en Letras ## Letras Var1 Var2 Var3 ## 1: B 3 1.6 5.3 ## 2: B 7 5.2 6.4 ## 3: C 5 3.2 6.3 ## 4: C 2 -3.5 6.3 DT[Letras&gt;&quot;A&quot;] #Filas con entrada mayor que A en Letras ## Letras Var1 Var2 Var3 ## 1: B 3 1.6 5.3 ## 2: B 7 5.2 6.4 ## 3: C 5 3.2 6.3 ## 4: C 2 -3.5 6.3 DT[J(&quot;A&quot;,c(6.2,6.3))] #Filas con A en Letras y 6.2 o 6.3 en Var3 ## Letras Var1 Var2 Var3 ## 1: A 9 -2.2 6.2 ## 2: A 4 -2.7 6.3 La construcción [\\ ] en los data tables tiene un significado, y, por lo tanto, un uso diferente que en los data frames ; en general, el argumento dentro de los corchetes aplicados a un data table tiene tres partes, separadas por comas: La primera indica las filas, como ya hemos visto. Normalmente, para que el proceso sea eficiente, impondremos condiciones sobre las filas usando las variables definidas para indexar la tabla. Si dejamos esta posición vacía, se toman todas las filas. La segunda parte indica columnas, o, más en general, expresiones aplicadas a columnas, incluyendo operaciones u otro tipo de funciones: plot, lm Podemos usar los nombres de las variables, sin entrecomillar, o su número de orden: en este último caso, se ha de añadir with=FALSE en la tercera posición. Si queremos extraer varias columnas de un data table o efectuar varias operaciones, hay que especificarlas en esta segunda posición dentro de una list. Si queremos sólo la primera o la última fila de una subtabla, se ha de especificar en esta segunda posición con o , respectivamente. La tercera precisa la expresión en la segunda posición: por ejemplo, si se ha de aplicar agrupando los datos (con el parámetro by) o cómo se han indicado las variables (con el parámetro with). Si queremos agrupar según una combinación de variables, tenemos que especificarlas en esta tercera posición dentro de una list. En resumen, DT[X, Y, by=Z] equivale a: &lt;&gt;. Veamos varios ejemplos: DT[ ,Var1] #El contenido de Var1 ## [1] 5 9 4 3 9 6 3 7 5 2 DT[ ,2] #Esto no es la segunda variable ## Var1 ## 1: 5 ## 2: 9 ## 3: 4 ## 4: 3 ## 5: 9 ## 6: 6 ## 7: 3 ## 8: 7 ## 9: 5 ## 10: 2 DT[ ,2,with=FALSE] #Esto sí ## Var1 ## 1: 5 ## 2: 9 ## 3: 4 ## 4: 3 ## 5: 9 ## 6: 6 ## 7: 3 ## 8: 7 ## 9: 5 ## 10: 2 DT[ ,list(Var1,Var2)] #Un data table con las variables Var1 y Var2 ## Var1 Var2 ## 1: 5 6.4 ## 2: 9 -2.2 ## 3: 4 -2.7 ## 4: 3 2.3 ## 5: 9 1.8 ## 6: 6 7.1 ## 7: 3 1.6 ## 8: 7 5.2 ## 9: 5 3.2 ## 10: 2 -3.5 DT[&quot;A&quot;,mult=&quot;first&quot;] #La primera fila con A en Letras ## Letras Var1 Var2 Var3 ## 1: A 5 6.4 5.5 DT[&quot;A&quot;,mult=&quot;last&quot;] #La última fila con A en Letras ## Letras Var1 Var2 Var3 ## 1: A 6 7.1 7.8 DT[&quot;A&quot;,sum(Var1)] #Suma de Var1 de las filas con una A en Letras ## [1] 36 DT[ ,sum(Var1),by=Letras] #Suma de Var1 agrupando según el valor de Letras ## Letras V1 ## 1: A 36 ## 2: B 10 ## 3: C 7 DT[ ,list(sumas1=sum(Var1),medias1=mean(Var2)), by=list(Letras,Var3)] #Suma de Var1 y media de Var2, agrupando según Letras y Var3 ## Letras Var3 sumas1 medias1 ## 1: A 5.5 5 6.40 ## 2: A 6.2 9 -2.20 ## 3: A 6.3 4 -2.70 ## 4: A 6.8 3 2.30 ## 5: A 7.5 9 1.80 ## 6: A 7.8 6 7.10 ## 7: B 5.3 3 1.60 ## 8: B 6.4 7 5.20 ## 9: C 6.3 7 -0.15 Para más ejemplos, consultad example(data.table). Para modificar una variable, o añadir una variable, podemos usar la construcción nombre :=``valor en la segunda posición dentro de los corchetes; esta construcción sirve también para eliminar una variable, igualándola a NULL. DT[ ,Var4:=2*Var1+Var2] #Añadimos esta nueva columna Var4 DT ## Letras Var1 Var2 Var3 Var4 ## 1: A 5 6.4 5.5 16.4 ## 2: A 9 -2.2 6.2 15.8 ## 3: A 4 -2.7 6.3 5.3 ## 4: A 3 2.3 6.8 8.3 ## 5: A 9 1.8 7.5 19.8 ## 6: A 6 7.1 7.8 19.1 ## 7: B 3 1.6 5.3 7.6 ## 8: B 7 5.2 6.4 19.2 ## 9: C 5 3.2 6.3 13.2 ## 10: C 2 -3.5 6.3 0.5 DT[&quot;A&quot;,Var5:=3*Var4] #Añadimos esta nueva columna Var5, sólo en las filas con una A en Letras DT ## Letras Var1 Var2 Var3 Var4 Var5 ## 1: A 5 6.4 5.5 16.4 49.2 ## 2: A 9 -2.2 6.2 15.8 47.4 ## 3: A 4 -2.7 6.3 5.3 15.9 ## 4: A 3 2.3 6.8 8.3 24.9 ## 5: A 9 1.8 7.5 19.8 59.4 ## 6: A 6 7.1 7.8 19.1 57.3 ## 7: B 3 1.6 5.3 7.6 NA ## 8: B 7 5.2 6.4 19.2 NA ## 9: C 5 3.2 6.3 13.2 NA ## 10: C 2 -3.5 6.3 0.5 NA 6.10 Guía rápida de funciones data() produce una lista con los objetos de datos a los que tenemos acceso. View muestra el data frame al que se aplica en la ventana superior izquierda de Rstudio. head aplicado a un data frame y un número \\(n\\), nos muestra las primeras \\(n\\) filas del data frame (por defecto, 6). tail aplicado a un data frame y un número \\(n\\), nos muestra las \\(n\\) últimas filas del data frame (por defecto, 6). str da la estructura global de un objeto de datos. names sirve para obtener un vector con los nombres de las columnas de un data frame, y también para modificar estos nombres. rownames sirve para obtener un vector con los identificadores de las filas de un data frame, y también para modificar estos identificadores. dimnames sirve para obtener una list formada por el vector de los identificadores de las filas y el vector de los nombres de las columnas de un data frame, y también para modificar estos vectores simultáneamente. dim da el número de filas y el número de columnas de un data frame data frame \\$``variable indica la variable del data frame read.table permite importar un fichero externo en formato texto simple en un data frame Algunos parámetros importantes: sep: sirve para indicar los separadores de las columnas. header: sirve para indicar si el fichero a importar tiene una primera fila con los nombres de las variables o no. dec: sirve para especificar el separador decimal. stringsAsFactors: igualado a FALSE, impone que las columnas de palabras se importen como tales, y no como factores. encoding: indica la codificación de alfabeto del fichero externo. read.csv, read.xls, read.xlsx (ambas del paquete xlsx), read.mtb y read.spss (ambas del paquete foreign) permiten importar en un data frame una tabla de datos en formato CSV, XLS, XLSX, Minitab o SPSS, respectivamente. write.table(data frame ,file=&quot;fichero&quot;) exporta el data frame al fichero externo. data.frame crea un data frame con los vectores a los que se aplica. Algunos parámetros importantes: rownames: sirve para especificar los identificadores de las filas. stringsAsFactors: como en read.table. fix abre un objeto de datos en el editor de datos. paste(\\(x_1\\),\\(x_2\\),...., sep=&quot;*separador*&quot;) pega los vectores \\(x_1\\), \\(x_2\\), , entrada a entrada, usando como separador el valor del parámetro sep. as.character, as.integer y as.numeric transforman todos los datos de un objeto en palabras, números enteros o números reales, respectivamente. droplevels borra todos los niveles sobrantes de todos los factores de un data frame select, del paquete dplyr, permite definir un data frame con todas las variables de un data frame que empiecen por una secuencia de letras dada (con el parámetro starts_with), que terminen por una secuencia de letras dada (con el parámetro ends_with), o que contengan una secuencia de letras dada (con el parámetro contains). subset(data frame , ``condición , select=``columnas ) define un data frame con las filas del data frame que cumplen la condición y las columnas especificadas en el parámetro select. sapply(data frame , FUN=``función ) aplica la función a las columnas de un data frame aggregate sirve para aplicar una función a una o varias variables de un data frame agrupando sus entradas por los niveles de uno o varios factores. attach añade las variables de un data frame al entorno global de R. detach deshace el efecto de attach. data.table, del paquete data.table, crea un data table a partir de vectores o de un data frame fread, del paquete data.table, permite importar un fichero externo en un data table. setkey, del paquete data.table, indexa un data table. [1, 2, by=3], aplicado a un data.table, extrae las filas especificadas en la posición 1 y ejecuta la expresión 2 sobre sus columnas, agrupando las filas según la condición 3. 6.11 Ejercicio La tabla de datos pulse.txt que encontraréis en http://aprender.uib.es/Rdir/pulse.txt recoge una serie de informaciones de tipo general (altura, peso, sexo, si corren, si fuman y su nivel de actividad física: 1 si es bajo, 2 si es moderado y 3 si es alto) sobre algunos estudiantes matriculados en un curso de estadística de la Universidad Estatal de Pensilvania hace unos años. A estos estudiantes se les pidió que lanzasen una moneda al aire: a los que sacaron cara, se les hizo correr un minuto sin moverse del sitio, y los que sacaron cruz, descansaron un minuto. Todos los estudiantes (tanto los que corrieron como los que no) midieron sus pulsaciones por minuto antes y después de este minuto de ejercicio o descanso, y estas medidas también aparecen en esta tabla (en las variables PuBefor y PuAfter, respectivamente). ¿Cuántos estudiantes tomaron parte en este estudio? ¿Cuántos son hombres y cuántas mujeres? Calculad el porcentaje medio de variación en el número de pulsaciones tras el minuto de ejercicio o descanso de los estudiantes que corrieron (se indica con el valor yes en la variable Ran.) y de los que no. ¿Hay mucha diferencia? Calculad el porcentaje medio de incremento en el número de pulsaciones tras el minuto de ejercicio sólo para los estudiantes que corrieron, pero ahora distinguiendo los hombres de las mujeres. ¿Cuál de los dos incrementos medios es mayor? Calculad el porcentaje medio de incremento en el número de pulsaciones tras el minuto de ejercicio para los estudiantes que corrieron, pero ahora distinguiendo los estudiantes que fuman de los que no. ¿Cuál de los dos incrementos medios es mayor? Calculad el número medio de pulsaciones antes del minuto de ejercicio o descanso de todos los estudiantes, separados según su nivel de actividad física. ¿Se observa alguna diferencia significativa? Se puede descargar de http://digital.library.adelaide.edu.au/coll/special//fisher/138.pdf .↩ http://en.wikipedia.org/wiki/Iris_flower_data_set .↩ El uso del editor de Rstudio para manipular data frames posiblemente requiera la instalación de algún programa auxiliar; por ejemplo, en el caso del Mac OS X, se tiene que tener instalada la última versión de XQuartz, que será el programa en el que se abrirá el editor. El instalador de XQuartz se puede descargar de http://xquartz.macosforge.org.↩ "],
["chap-plot.html", "Lección 7 Gráficos I 7.1 La función plot 7.2 Parámetros de plot 7.3 Cómo añadir elementos a un gráfico 7.4 Guía rápida", " Lección 7 Gráficos I El objetivo de esta lección es introducir los aspectos básicos de los gráficos que se obtienen por medio de la función plot. Muchos de los parámetros y funciones auxiliares que explicamos en esta lección se podrán usar más adelante en otras funciones que producen tipos específicos de gráficos en estadística descriptiva. 7.1 La función plot Dada una familia de puntos \\[ (x_1, y_1), \\ldots, (x_n, y_n), \\] podemos usar la función plot para dibujar su gráfico. La construcción básica para hacerlo es plot(\\(x\\),\\(y\\)), donde \\(x=(x_1, \\ldots, x_n)\\) es el vector de sus primeras coordenadas e \\((y_1, \\ldots, y_n)\\) el vector de sus segundas coordenadas. Por ejemplo, para dibujar el gráfico de los puntos \\[ (2,1), (5, 7), (6, 3), (3, 2), (4, 1), \\] basta entrar x=c(2,5,6,3,4) y=c(1,7,3,2,1) plot(x,y) Figura 7.1: Gráfico básico de los puntos \\((2, 1)\\), \\((5, 7)\\), \\((6, 3)\\), \\((3, 2)\\), \\((4, 1)\\). y obtenemos la Figura 7.1. Cuando aplicamos plot a un solo vector \\((x_1, \\ldots, x_n)\\), R produce el gráfico de los puntos \\[ (1, x_1), \\ldots, (n, x_n). \\] Es decir, si el vector tiene longitud \\(n\\), plot(x) es una abreviatura de plot(1:n, x). Así, la Figura 7.2 se obtiene con la siguiente instrucción: plot(2^(1:5)) Figura 7.2: Gráfico básico de los valores \\((2^n)_{n=1, \\ldots, 5}\\). La función plot también sirve para dibujar el gráfico de una función definida mediante function. Por ejemplo, la gráfica de la función \\(y=x^2\\) entre \\(x=0\\) y \\(x=1\\) de la Figura 7.3 se obtiene con el código siguiente: f=function(x){x^2} plot(f) Figura 7.3: Gráfico básico de la función \\(y=x^2\\). 7.2 Parámetros de plot El aspecto de los gráficos que produce plot se puede modificar especificando parámetros en su argumento. Por ejemplo, ya vimos en la Lección 3 el parámetro log, que sirve para indicar si queremos algún eje en escala logarítmica. Un primer grupo de parámetros permiten modificar el aspecto &lt;&gt; del gráfico: Para poner un título al gráfico, tenemos que emplear main=&quot;título&quot;. Para modificar las etiquetas de los ejes de coordenadas, tenemos que usar xlab=&quot;etiqueta&quot; e ylab=&quot;etiqueta&quot;. Los valores de estos parámetros se tienen que entrar entre comillas o, si son fórmulas matemáticas, aplicarles la función expression( ), para que aparezcan en un formato matemático más adecuado. Por ejemplo, suponemos que conocéis la sucesión \\((F_n)_{n\\geq 0}\\) de los números de Fibonacci \\[ 1, 1, 2, 3, 5, 8, 13, 21, \\ldots, \\] que empieza con \\(F_0=F_1=1\\) y a partir de aquí cada término es la suma de los dos anteriores. Esta sucesión está definida por la fórmula \\[ F_n=\\frac{1}{\\sqrt{5}}\\cdot \\Bigl(\\frac{1+\\sqrt{5}}{2}\\Bigr)^{n+1}-\\frac{1}{\\sqrt{5}}\\cdot \\Bigl(\\frac{1-\\sqrt{5}}{2}\\Bigr)^{n+1}\\quad \\mbox{para todo $n\\geq 0$}. \\] Para comprobarlo para algunos valores, vamos a generar la parte inicial \\((F_n)_{n=0, \\ldots, 30}\\) de la sucesión definida por esta fórmula. n=0:30 Fib=(1/sqrt(5))*((1+sqrt(5))/2)^(n+1)- (1/sqrt(5))*((1-sqrt(5))/2)^(n+1) Fib ## [1] 1 1 2 3 5 8 13 21 ## [9] 34 55 89 144 233 377 610 987 ## [17] 1597 2584 4181 6765 10946 17711 28657 46368 ## [25] 75025 121393 196418 317811 514229 832040 1346269 Para dibujar los pares \\((n, F_n)_{n=0, \\ldots, 30}\\) en un gráfico titulado &lt;&gt;, con el eje de abscisas etiquetado con \\(n\\) y el eje de ordenadas etiquetado con \\(F_n\\) igualado a su fórmula explícita, podemos entrar la instrucción siguiente: plot(n, Fib, xlab=&quot;n&quot;, main=&quot;Números de Fibonacci&quot;, ylab=expression(F[n]==(1/sqrt(5))*((1+sqrt(5))/2)^(n+1) -(1/sqrt(5))*((1-sqrt(5))/2)^(n+1))) Figura 7.4: Gráfico de los 31 valores iniciales \\(F_n\\) de la sucesión de Fibonacci. El resultado es la Figura @ref(fig:F402}. Si os interesa información sobre cómo escribir las fórmulas dentro de expression, podéis consultar la Ayuda de plotmath Vale, hemos hecho trampa. Si habéis ejecutado la instrucción anterior tal cual, la etiqueta del eje de ordenadas os habrá quedado demasiado cerca del borde, y, por ejemplo, no se verá la línea horizontal superior de las raíces cuadradas. Para solucionarlo, hemos modificado los márgenes de la figura. Estos márgenes, especificados en números de líneas, se controlan con el parámetro mar, pero este parámetro no se puede especificar dentro de plot, sino antes, como argumento de la función par, que sirve para modificar el aspecto general de los gráficos. Así que en realidad, las instrucciones que han producido el gráfico han sido: viejo.par=par() #Guardamos los valores antiguos de par par(mar=c(5,4.5,4,2)+0.1) #Modificamos los márgenes plot(n, Fib, xlab=&quot;n&quot;, main=&quot;Números de Fibonacci&quot;, ylab=expression(F[n]==(1/sqrt(5))*((1+sqrt(5))/2)^(n+1) -(1/sqrt(5))*((1-sqrt(5))/2)^(n+1))) par=viejo.par #Volvemos a los valores anteriores de par Consultad la Ayuda de par para conocer cómo modificar otros parámetros gráficos. Cómo podéis ver, por defecto plot dibuja los puntos como círculos vacíos. Esto se puede cambiar especificando el signo con el parámetro pch, que puede tomar como valor cualquier número natural entre 0 y 25. Con pch=0 obtenemos cuadrados, pch=1 produce los círculos que ya habéis visto (es el valor por defecto), pch=2 produce triángulos, etc. La Figura 7.5 muestra los signos correspondientes a los valores de pch. También se pueden usar letras para representar los puntos: hay que especificarlo igualando el parámetro pch a la letra entre comillas. knitr::include_graphics(&quot;images/pchh.png&quot;,) Figura 7.5: Signos correspondientes a los diferentes valores de pch. El tamaño de estos signos se puede modificar mediante el parámetro cex igualado al factor de escalado: cex=2 produce signos el doble de grandes que los que obtenemos por defecto, cex=0.5 produce signos de la mitad de tamaño, etc. Por ejemplo, el siguiente código produce la Figura 7.6. x=c(2,5,6,3,4); y=c(1,7,3,2,1) plot(x, y, pch=20, cex=3) Figura 7.6: Gráfico de los puntos \\((2, 1)\\), \\((5, 7)\\), \\((6, 3)\\), \\((3, 2)\\), \\((4, 1)\\) con puntos de tamaño triple. El color de los puntos se puede especificar mediante el parámetro col igualado al nombre del color en inglés. La paleta de colores de R consta de 502 colores diferentes. Podéis encontrar una presentación muy clara de esta paleta en el documento Rcolor.pdf que encontraréis en el repositorio del curso o en su url original http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf Así, por ejemplo, #Con los últimos valores de x e y plot(x, y, col=&quot;red&quot;, pch=15) produce el gráfico de la izquierda de la Figura 7.7. knitr::include_graphics(c(&quot;images/Plotcol1.png&quot;,&quot;images/Plotbg.png&quot;)) Figura 7.7: Dos gráficos de los puntos \\((2, 1)\\), \\((5, 7)\\), \\((6, 3)\\), \\((3, 2)\\), \\((4, 1)\\). Los puntos que se obtienen con pch de 21 a 25 admiten un color para el borde (que se especifica con col) y uno de diferente para el relleno, que se especifica con bg. A modo de ejemplo, el gráfico de la derecha de la Figura 7.7 se obtiene con el código siguiente: &gt; #Con los últimos valores de x e y &gt; plot(x, y, pch=21, col=&quot;blue&quot;, bg=&quot;red&quot;, cex=2) El parámetro type permite indicar el tipo de gráfico que queremos producir. El valor del parámetro se tiene que entrar entre comillas y puede ser: &quot;p&quot;, para dibujar los puntos como simples puntos, como hasta ahora; es el valor por defecto.¡ &quot;{l“}, para dibujar los puntos unidos por líneas rectas sin que se vean los puntos. &quot;b&quot;, para dibujar los puntos unidos por líneas rectas de manera que se vean los puntos (los dibuja ambos, both: rectas y puntos), pero sin que las rectas entren dentro de los signos que representan los puntos. &quot;{o“}, que es como &quot;b&quot;, pero ahora las rectas sí que entran dentro de los puntos. &quot;h&quot;, para dibujar líneas verticales desde el eje de abscisas a cada punto (un histograma de líneas ). &quot;s&quot;, para dibujar un diagrama de escalones. &quot;n&quot;, para no dibujar los puntos, sólo el exterior del gráfico (ejes, título, etc.). Veamos un ejemplo sencillo. Con el código se obtienen los gráficos de la Figura 7.8. x=c(1,3,5,7,11) y=c(2,8,4,6,3) par(mfrow=c(3,2)) plot(x, y, main=&quot;con p&quot;) plot(x, y, type=&quot;l&quot;, main=&quot;con l&quot;) plot(x, y, type=&quot;b&quot;, main=&quot;con b&quot;) plot(x, y, type=&quot;o&quot;, main=&quot;con o&quot;) plot(x, y, type=&quot;h&quot;, main=&quot;con h&quot;) plot(x, y, type=&quot;s&quot;, main=&quot;con s&quot;) plot(x, y, type=&quot;n&quot;, main=&quot;con n&quot;) par(mfrow=c(1,1)) Figura 7.8: Gráficos de los puntos \\((1,2)\\), \\((3,8)\\), \\((5,4)\\), \\((7,6)\\), \\((11,3)\\) con los distintos valores del parámetro type. La función plot aplicada a una función \\(f\\) en realidad produce el gráfico de tipo &quot;l&quot; de una familia de puntos \\((x, f(x))\\) (por defecto, 101 puntos distribuidos uniformemente a lo largo del dominio; este valor se puede modificar con el parámetro n). El estilo de las líneas usadas por plot se puede modificar con los parámetros siguientes: El parámetro col especifica el color tanto de los puntos como de las líneas. El tipo de línea se puede especificar con el parámetro lty igualado a uno de los valores siguientes: &quot;solid&quot;, o 1, (el valor por defecto, que produce una línea continua); &quot;dashed&quot;, o 2, (que produce una línea discontinua); &quot;dotted&quot;, o 3, (que produce una línea de puntos); &quot;dotdash&quot;, o 4, (que produce una línea que alterna puntos y rayas). El grosor se puede especificar con el parámetro lwd. Con lwd=\\(x\\) imponemos que el grosor de las líneas sea \\(x\\) veces su valor por defecto. Así, los dos gráficos de la Figura 7.9 se obtienen con el código siguiente: par(mfrow=c(1,2)) x=c(1,3,5,7,11) y=c(2,8,4,6,3) plot(x, y, type=&quot;o&quot;, pch=19, lty=&quot;dotted&quot;) plot(x, y, type=&quot;o&quot;, pch=19, lty=&quot;dashed&quot;, lwd=2) par(mfrow=c(1,1)) Figura 7.9: Gráficos de los puntos \\((1,2)\\), \\((3,8)\\), \\((5,4)\\), \\((7,6)\\), \\((11,3)\\) con distintos valores de los parámetros lty y lwd Si el argumento de plot son dos vectores, por norma general los rangos de los ejes de coordenadas van, por defecto, del mínimo al máximo de los vectores correspondientes. Si su argumento es una función \\(f\\), por defecto el rango del eje de abscisas es el intervalo \\([0,1]\\) y el rango del eje de ordenadas va del valor mínimo de \\(f\\) sobre el rango de las abscisas al máximo. Si queremos modificar estos rangos, tenemos que usar los parámetros xlim e ylim, igualados cada uno a un vector de entradas los extremos del rango. Veamos un ejemplo de uso de estos parámetros: par(mfrow=c(1,3)) f=function(x){x*log(x)} plot(f) #Rangos por defecto plot(f, xlim=c(1,10)) #Fijamos el rango de x plot(f, xlim=c(1,10), ylim=c(0,50)) #Fijamos los rangos de x e y par(mfrow=c(1,1)) Figura 7.10: Gráficas de la función \\(f(x)=x\\log{x}\\) con diferentes rangos de coordenadas de los ejes. Estas instrucciones producen, respectivamente, los tres gráficos de la Figura 7.10. Para modificar las posiciones de las marcas en los ejes de abscisas y ordenadas podemos usar los parámetros xaxp e yaxp, respectivamente. Mediante la expresión xaxp=c(\\(n_1\\),\\(n_2\\),\\(m\\)), imponemos que R dibuje \\(m+1\\) marcas igualmente espaciadas entre los puntos \\(n_1\\) y \\(n_2\\) del eje de abscisas. La sintaxis para yaxp es la misma. Estas instrucciones no definen los rangos de los ejes de coordenadas, que se han de especificar con xlim e ylim si se quieren modificar. Por ejemplo, par(mfrow=c(1,3)) f=function(x){x*log(x)} plot(f, xlim=c(1,10)) plot(f, xlim=c(1,10), xaxp=c(1,10,9)) plot(f, xlim=c(1,10), xaxp=c(1,10,9), ylim=c(0,25), yaxp=c(0,25,10)) par(mfrow=c(1,1)) Figura 7.11: Gráficas de la función \\(f(x)=x\\log{x}\\) con diferentes posiciones de las marcas en los ejes. producen, respectivamente, los tres gráficos de la Figura 7.11. La función plot dispone de muchos otros parámetros, que podéis consultar en la Ayuda de plot y las de las funciones que se citan en su sección See Also. Son especialmente útiles los parámetros que se explican en la Ayuda de par. 7.3 Cómo añadir elementos a un gráfico La función plot permite dibujar una sola cosa (una familia de puntos o una función) con un único estilo. Si queremos dibujar varios objetos en un gráfico, los tenemos que añadir uno a uno, usando las funciones adecuadas. En esta sección veremos algunas funciones que permiten añadir elementos a un gráfico. Antes de empezar, queremos avisaros de algo muy importante. Cuando añadimos objetos a un gráfico, ya no podemos modificar su diseño general. Por ejemplo, los rangos de coordenadas de los ejes del gráfico final o sus etiquetas serán los del primer gráfico, aunque especifiquemos valores nuevos en el argumento de las funciones que usemos para añadir objetos. La instrucción points(\\(x\\),\\(y\\)) añade un punto de coordenadas \\((x, y)\\) al gráfico activo. Podemos declarar el color, el signo etc., de este punto mediante los parámetros usuales. (¡Atención! La instrucción es points, no point.) Por ejemplo, f=function(x){x^2} plot(f, xlim=c(-3,3)) points(0,0, pch=19) Figura 7.12: Gráfica de la función \\(f(x)=x^2\\) con su vértice marcado. produce la Figura 7.12, en la que hemos dibujado la parábola \\(y=x^2\\) y hemos marcado su vértice con un punto. La función points también sirve para añadir una familia de puntos. En este caso, hay que entrar en el argumento de points(\\(x\\),\\(y\\)) la lista \\(x\\) de sus primeras coordenadas y la lista \\(y\\) de sus segundas coordenadas, como lo haríamos en plot. Veamos algunos ejemplos: f=function(x){x^2} plot(f, xlim=c(0,10)) points(0:10,(0:10)^2, pch=19) dibuja un trozo de la parábola \\(y=x^2\\) y añade los puntos \\((n, n^2)_{n=0, \\ldots, 10}\\), produciendo la Figura 7.13.(a), y el código &gt; n=0:20 &gt; x=1.3^n-2*0.8^n &gt; y=0.2*1.3^n+1.7*0.8^n &gt; plot(n,x, col=&quot;blue&quot;) &gt; points(n,y, pch=19, col=&quot;red&quot;) primero dibuja los puntos \\((n, 1.3^n-2\\cdot 0.8^n)_{n=0, \\ldots, 20}\\) como circulitos azules vacíos, y después añade los puntos \\((n, 0.2\\cdot 1.3^n+1.7 \\cdot 0.8^n)_{n=0, \\ldots, 20}\\) como circulitos rojos llenos, produciendo la Figura 7.13.(b). Figura 7.13: (a) Gráfico de la función \\(y=x^2\\) y los puntos \\((n,n^2)_{n=0, \\ldots, 10}\\); (b) Gráfico de las familias de puntos \\((n, 1.3^n-2\\cdot 0.8^n)_{n=0, \\ldots, 20}\\) y \\((n, 0.2\\cdot 1.3^n+1.7 \\cdot 0.8^n)_{n=0, \\ldots, 20}\\) usando diferentes signos para cada familia. La función abline sirve para añadir una recta; ya la usamos en la Lección 3 para añadir a un gráfico una recta de regresión calculada con lm. Esta función tiene tres variantes: abline(\\(a\\),\\(b\\)) añade la recta \\(y=a+bx\\). abline(v=\\(x_0\\)) añade la recta vertical \\(x=x_0\\). abline(h=\\(y_0\\)) añade la recta horizontal \\(y=y_0\\). Podemos especificar las características de estas rectas, como su grosor, su estilo o su color, mediante los parámetros pertinentes. Por ejemplo, f=function(x){x^2} plot(f, xlim=c(-3,3), col=&quot;red&quot;) points(0,0, pch=19, col=&quot;blue&quot;) points(1,1, pch=19, col=&quot;blue&quot;) abline(v=1, lty=&quot;dashed&quot;) abline(h=0, lty=&quot;dotted&quot;) abline(-1,2, lty=&quot;dotdash&quot;) Figura 7.14: Gráfica de la función \\(f(x)=x^2\\), los puntos \\((0, 0)\\) y \\((1, 1)\\) y las rectas \\(x=1\\), \\(y=0\\) e \\(y=2x-1\\). produce la Figura 7.14. En este caso, hemos añadido a la gráfica de la parábola \\(y=x^2\\), dos puntos en \\((0, 0)\\) y \\((1, 1)\\), la recta horizontal \\(y=0\\) de puntos, la recta vertical \\(x=1\\) discontinua y la recta \\(y=-1+2x\\) de puntos y rayas. Los parámetros v y h de abline se pueden igualar a vectores numéricos, en cuyo caso la instrucción añade en un solo paso todas las rectas verticales u horizontales correspondientes, todas del mismo estilo. Incluso se pueden combinar los parámetros v y h en una misma función: f=function(x){x^2} plot(f, xlim=c(-3,3), col=&quot;red&quot;) abline(h=0:9, v=-3:3, lty=&quot;dotted&quot;) Figura 7.15: Gráfica de la función \\(f(x)=x^2\\) y una rejilla de rectas horizontales y verticales. produce la Figura 7.15. La instrucción text(\\(x\\),\\(y\\), labels=…) añade en el punto de coordenadas \\((x, y)\\) el texto especificado como argumento de labels. El texto se puede entrar entre comillas o en una expression. Esta instrucción admite un parámetro opcional, pos, que puede tomar valores 1, 2, 3 o 4 y permite indicar la posición del texto alrededor de las coordenadas \\((x, y)\\): 1 significa abajo, 2 a la izquierda, 3 arriba y 4 a la derecha. Sin especificar pos (o, equivalentemente, especificando pos=NULL, que es su valor por defecto), el texto se sitúa centrado en el punto \\((x, y)\\). El efecto de pos se ilustra en la Figura 7.16, producida con el código siguiente: plot(0,0, pch=19, xlab=&quot;&quot;, ylab=&quot;&quot;) text(0,0, labels=&quot;pos 1&quot;, pos=1) text(0,0, labels=&quot;pos 2&quot;, pos=2) text(0,0, labels=&quot;pos 3&quot;, pos=3) text(0,0, labels=&quot;pos 4&quot;, pos=4) points(0,0.5, pch=19) text(0,0.5, labels=&quot;no pos&quot;) Figura 7.16: Significado del parámetro pos de la función text. La función text se puede usar para añadir varios textos en un solo paso. En este caso, \\(x\\) e \\(y\\) han de ser los vectores de abscisas y ordenadas de los puntos donde se añadirán los textos, labels el vector de textos, y pos el vector de sus posiciones; en este vector, los textos que queremos centrados en su posición se han de indicar con NULL. Así, la Figura 7.16 también se hubiera podido obtener con el código siguiente, como podréis comprobar si lo ejecutáis: plot(0,0, pch=19, xlab=&quot;&quot;, ylab=&quot;&quot;) points(0,0.5, pch=19) text(rep(0,5),c(rep(0,4),0.5), pos=c(1,2,3,4,NULL), labels=c(&quot;pos 1&quot;,&quot;pos 2&quot;,&quot;pos 3&quot;,&quot;pos 4&quot;,&quot;no pos&quot;)) La instrucción lines(\\(x\\),\\(y\\)), donde \\(x=(x_i)_{i=1, \\ldots, n}\\) e \\(y=(y_i)_{i=1, \\ldots, n}\\) son dos vectores numéricos de la misma longitud, añade al gráfico una línea poligonal que une los puntos \\((x_i, y_i)\\) sucesivos. El efecto es como si añadiéramos un plot(\\(x\\),\\(y\\), type=l). Naturalmente, la apariencia de las líneas la podemos modificar con los parámetros usuales de grosor, color, estilo, etc. A modo de ejemplo, la Figura 7.17 se obtiene con el código: f=function(x){x^2} plot(f, xlim=c(0,10)) lines(3.33*(0:3), (3.33*(0:3))^2, lwd=2, lty=&quot;dashed&quot;) Figura 7.17: Gráfica de la función \\(f(x)=x^2\\) junto a la línea poligonal que une los puntos \\((3.33n, (3.33n)^2)_{n=0, \\ldots, 3}\\) La instrucción curve con el parámetro add=TRUE permite añadir la gráfica de una curva a un gráfico anterior. La curva se puede especificar mediante una expresión algebraica con variable \\(x\\), o mediante su nombre si la hemos definido antes. Por ejemplo, así podemos producir el gráfico de la Figura 7.18. f=function(x){x^2} plot(f, xlim=c(-10,10), xlab=&quot;x&quot;, ylab=&quot;y&quot;, main=&quot;monomios&quot;) curve(x^3, lty=&quot;dashed&quot;, add=TRUE) curve(x^4, lty=&quot;dotted&quot;, add=TRUE) Figura 7.18: Gráficas de diferentes monomios. produce el gráfico de la Figura 7.18. Las funciones points, abline, lines o text sólo sirven para añadir elementos a un gráfico. En cambio, la función curve también se puede usar para producir la gráfica de una función, como plot, con la ventaja sobre esta última que no sólo se puede aplicar a una función definida con function, sino también a una expresión algebraica. Además, la función curve admite todos los parámetros de plot. Así, el gráfico de la Figura 7.18 también se obtiene con curve(x^2, xlim=c(-10,10), xlab=&quot;x&quot;, ylab=&quot;y&quot;, main=&quot;monomios&quot;) curve(x^3, lty=&quot;dashed&quot;, add=TRUE) curve(x^4, lty=&quot;dotted&quot;, add=TRUE) Cuando dibujamos varias funciones en un gráfico, como el de la Figura 7.18, es conveniente usar una leyenda para distinguirlas. Para añadirla, se ha de usar la instrucción legend(posición, legend=c(vector de nombres de las curvas), parámetro=c( vector de valores del parámetro), …, parámetro =c( vector de valores del parámetro )), donde: La posición indica donde queremos situar la leyenda, y puede ser o bien dos números para especificar las coordenadas de su esquina superior izquierda, o bien una de las palabras siguientes: &quot;bottomright&quot; (esquina inferior derecha), &quot;bottom&quot; (centrada abajo), &quot;bottomleft&quot; (esquina inferior izquierda), &quot;left&quot; (centrada a la izquierda), &quot;topleft&quot; (esquina superior izquierda), &quot;top&quot; (centrada arriba), &quot;topright&quot; (esquina superior derecha), &quot;right&quot; (centrada a la derecha) o &quot;center&quot; (en el centro del gráfico). El vector legend contiene los nombres (entre comillas o aplicándoles expression) con los que queremos identificar las curvas dentro de la leyenda. Cada parámetro se usará para especificar el vector de sus valores sobre las diferentes curvas, en el orden en el que aparecen en el vector legend e incluyendo los valores por defecto. Se pueden usar varios parámetros. Si se quieren distinguir las curvas por su color, obligatoriamente también se ha de especificar algún otro parámetro (si sólo se distinguen por el color, se ha de añadir lty igualado al tipo de línea; por defecto, &quot;solid&quot;). Por ejemplo, &gt; curve(x^2, xlim=c(-10,10), xlab=&quot;x&quot;, ylab=&quot;y&quot;, main=&quot;monomios&quot;) &gt; curve(x^3, lty=&quot;dashed&quot;, add=TRUE) &gt; curve(x^4, lty=&quot;dotted&quot;, add=TRUE) &gt; legend(&quot;bottomleft&quot;, legend=c(expression(x^2), expression(x^3), expression(x^4)), lty=c(&quot;solid&quot;, &quot;dashed&quot;, &quot;dotted&quot;)) produce el gráfico de la izquierda de la Figura 7.19. Observad que, aunque en el primer curve no hemos especificado el parámetro lty, y ha tomado su valor por defecto, en el parámetro lty del legend sí que hemos especificado su valor para la primera función. Veamos otro ejemplo: &gt; curve(2*x+3, xlim=c(-10,10), ylab=&quot;&quot;) &gt; curve(2*x^2+3, col=&quot;red&quot;, lwd=2, add=TRUE) &gt; curve(2*x^3+3, col=&quot;blue&quot;, lwd=3, add=TRUE) &gt; legend(&quot;topleft&quot;, legend=c(expression(2*x+3),expression(2*x^2+3), expression(2*x^3+3)), lwd=c(1,2,3), col=c(&quot;black&quot;,&quot;red&quot;,&quot;blue&quot;)) produce el gráfico de la derecha de la Figura 7.19. knitr::include_graphics(c(&quot;images/monomis2.png&quot;,&quot;images/legcol.png&quot;)) Figura 7.19: Gráficas de diferentes funciones usando como leyenda el tipo de línea (izquierda) o el color y el grosor (derecha). El código siguiente produce la Figura 7.20; en ella podemos observar que si el único parámetro que especificamos dentro del legend es el color, no se ven las líneas dentro de la leyenda. curve(2*x+3, -10, 10, ylab=&quot;&quot;) curve(2*x^2+3, col=&quot;red&quot;, add=TRUE) curve(2*x^3+3, col=&quot;blue&quot;, add=TRUE) legend(&quot;topleft&quot;, legend=c(expression(2*x+3),expression(2*x^2+3), expression(2*x^3+3)), col=c(&quot;black&quot;,&quot;red&quot;,&quot;blue&quot;)) Figura 7.20: Gráficas de diferentes monomios usando como leyenda el color y su expresión, pero no el tipo de línea. Si os interesan, también disponéis de las funciones segments (para añadir segmentos), arrows (para añadir flechas), symbols (para añadir signos, como estrellas, termómetros, …), polygon (para añadir polígonos cerrados especificando sus vértices), etc. Consultad las Ayudas de estas instrucciones para los detalles sobre cómo se usan. 7.4 Guía rápida expression sirve para producir textos matemáticamente bien formateados. par sirve para modificar el aspecto general de los gráficos. Consultad su Ayuda para conocer todos los parámetros que se pueden especificar en esta función. plot es la función genérica para producir gráficos. Sus dos usos principales (por el momento) son: plot(\\(x\\),\\(y\\)), que dibuja el gráfico de los puntos \\((x_n, y_n)\\). plot(``función ), que dibuja la gráfica de la función . Algunos parámetros importantes: main: sirve para especificar el título. xlab e ylab: sirven para especificar las etiquetas de los ejes de coordenadas. xlim e ylim: sirven para especificar los rangos de los ejes de coordenadas. xaxp e yaxp: sirven para especificar las marcas en los ejes de coordenadas. log: sirve para especificar los ejes de coordenadas que estarán en escala logarítmica. type: sirve para especificar el tipo de gráfico. pch: sirve para especificar el estilo de los puntos. cex: sirve para especificar el tamaño de los puntos. col: sirve para especificar el color del gráfico. bg: sirve para especificar el color de relleno de los puntos de estilos pch de 21 a 25. lty: sirve para especificar el tipo de las líneas. lwd: sirve para especificar el grosor de la líneas. Los parámetros pch, cex, col, bg, type, lty y lwd también se pueden usar en las funciones que siguen. points añade puntos al gráfico activo. abline añade una recta al gráfico activo. Algunos parámetros específicos importantes: v: la abscisa de una recta vertical. h: la ordenada de una recta horizontal. lines añade una línea poligonal al gráfico activo. text añade un texto al gráfico activo. Algunos parámetros específicos importantes: pos: la posición del texto con respecto a sus coordenadas. labels: el texto. legend añade una leyenda al gráfico activo. curve, con el parámetro add=TRUE, sirve para añadir la gráfica de una función al gráfico activo. Esta función admite todos los parámetros de plot. 7.4.1 Ejercicio La función de Gompertz es \\(G(t)=ae^{-be^{-ct}}\\), con \\(a, b, c\\in \\mathbb{R}\\) estrictamente positivos, y se usa para modelar el crecimiento de tumores o de poblaciones con recursos limitados. Vamos a analizar gráficamente el efecto de los parámetros \\(a, b, c\\). La recta \\(y=a\\) es una asíntota horizontal de \\(G(t)\\). Comprobadlo dibujando en un mismo gráfico dos funciones de Gompertz con los mismos valores de \\(b\\) y \\(c\\) y diferentes valores de \\(a\\), y las rectas horizontales definidas por estos valores de \\(a\\). Usad colores, tipos de líneas, textos, leyenda, todo lo que consideréis necesario para ayudar a que el gráfico muestre la información que se desea. Para estudiar el efecto de \\(b\\), dibujad en un mismo gráfico tres funciones de Gompertz con los mismos valores de \\(a\\) y \\(c\\) y diferentes valores de \\(b\\). De nuevo, usad todo lo que consideréis necesario para mejorar la comprensión del gráfico. A partir de este gráfico, ¿qué efecto diríais que tiene el parámetro \\(b\\) sobre la gráfica de la función? Para estudiar el efecto de \\(c\\), dibujad en un mismo gráfico tres funciones de Gompertz con los mismos valores de \\(a\\) y \\(b\\) y diferentes valores de \\(c\\). De nuevo, usad todo lo que consideréis necesario para mejorar la comprensión del gráfico. A partir de este gráfico, ¿qué efecto diríais que tiene el parámetro \\(c\\) sobre la gráfica de la función? "],
["chap-edqual.html", "Lección 8 Descripción de datos cualitativos 8.1 Frecuencias 8.2 Tablas unidimensionales de frecuencias 8.3 Tablas bidimensionales de frecuencias 8.4 Tablas multidimensionales de frecuencias 8.5 Tablas a partir de dta frames de de variables cualitativas 8.6 Diagramas de barras 8.7 Otros gráficos para datos cualitativos 8.8 Guía rápida de funciones 8.9 Ejercicio", " Lección 8 Descripción de datos cualitativos Los datos cualitativo corresponden a observaciones sobre cualidades de un objeto o individuo, tales como su especie o su sexo, que pueden ser iguales o diferentes, pero que no admiten ningún otro tipo de comparación significativa: por ejemplo, para los que no tenga ningún sentido preguntarse si uno es más grande que otro, ni efectuar operaciones aritméticas con ellos, aunque estén representados por números. Llamaremos variable cualitativa a una lista de observaciones de un tipo de datos cualitativos sobre un conjunto concreto de objetos, y niveles, como en los factores, a los diferentes valores que pueden tomar estos datos; por ejemplo, los dos niveles de una variable Sexo serían &lt;&gt; y &lt;&gt;, o sinónimos. Con R, usaremos vectores y factores para representar variables cualitativas. Los factores nos servirán para agrupar las observaciones según los niveles de la variable. De esta manera podremos segmentar la población que representa la variable en grupos o subpoblaciones, asignando un grupo a cada nivel, y podremos comparar el comportamiento de otras variables sobre estos grupos. 8.1 Frecuencias Los estadísticos básicos para datos cualitativos son sencillos: dada una variable cualitativa, para cada uno de sus niveles podemos contar cuántos datos hay en ese nivel (la frecuencia absoluta del nivel) y qué fracción del total representan (la frecuencia relativa del nivel) y nada más. Ejemplo 8.1 Supongamos que se ha realizado un seguimiento a 20 personas ingresadas en un geriátrico. Uno de los datos que se han recogido sobre estas personas ha sido su sexo. El resultado ha sido una variable cualitativa formada por las 20 observaciones siguientes: Mujer, Mujer, Hombre, Mujer, Mujer, Mujer, Mujer, Mujer, Hombre, Mujer, Hombre, Hombre, Mujer, Mujer, Hombre, Mujer, Mujer, Mujer, Mujer, Hombre. Sus dos niveles son &lt;&lt;{Hombre}&gt;&gt; y &lt;&lt;{Mujer}&gt;&gt;. En esta variable hay 14 mujeres y 6 hombres. Por lo tanto, éstas son las frecuencias absolutas de estos niveles. Puesto que en total hay 20 individuos, sus frecuencias relativas son \\[ \\mbox{Hombre: }\\frac{6}{20}=0.3, \\qquad \\mbox{Mujer: } \\frac{14}{20}=0.7. \\] En general, supongamos que tenemos un tipo de datos cualitativos con niveles \\[ l_1, l_2, \\ldots, l_k. \\] Efectuamos \\(n\\) observaciones de este tipo de datos, y sean \\[ x_1, x_2, \\ldots, x_n \\] los resultados que obtenemos. Cada una de estas observaciones \\(x_j\\) toma como valor alguno de los niveles \\(l_i\\). Estas observaciones forman una variable cualitativa. Así, en el ejemplo anterior tendríamos que \\(l_1=\\mbox{Hombre}\\) y \\(l_2=\\mbox{Mujer}\\), que \\(n=20\\) (el número de observaciones efectuadas), y \\(x_1, \\ldots, x_{20}\\) formarían la muestra de sexos. Con estas notaciones: La frecuencia absoluta* del nivel \\(l_j\\) en esta variable cualitativa, que denotaremos por \\(n_j\\), es el número de observaciones en las que el resultado \\(x_i\\) es igual al nivel \\(l_j\\). La frecuencia relativa del nivel \\(l_j\\) en esta variable cualitativa es la fracción \\(f_j={n_j}/{n}\\). Es decir, la fracción (en tanto por uno) de observaciones que corresponden a este nivel. El tanto por ciento de observaciones del nivel \\(l_j\\) es entonces \\(f_j\\cdot 100\\%\\). La moda de esta variable cualitativa es su nivel, o niveles, de mayor frecuencia (absoluta o relativa, tanto da). La Tabla ?? resume las frecuencias absolutas y relativas de la variable cualitativa del Ejemplo~8.1, con las notaciones que acabamos de introducir. Su moda es el nivel Mujer . AAAAAA Ajustar tabla o cita 8.2 Tablas unidimensionales de frecuencias Supongamos que tenemos una variable cualitativa guardada en un vector o un factor,29 como por ejemplo:30 . x=c(3,2,5,1,3,1,5,6,2,2,2,1,3,5,2) x ## [1] 3 2 5 1 3 1 5 6 2 2 2 1 3 5 2 Respuestas=factor(c(&quot;No&quot;,&quot;No&quot;,&quot;Si&quot;,&quot;No&quot;,&quot;Si&quot;,&quot;No&quot;,&quot;No&quot;,&quot;Si&quot;)) Respuestas ## [1] No No Si No Si No No Si ## Levels: No Si Con R, la tabla de frecuencias absolutas de un vector que representa una variable cualitativa se calcula con la función table. table(x) ## x ## 1 2 3 5 6 ## 3 5 3 3 1 table(Respuestas) ## Respuestas ## No Si ## 5 3 El resultado de una función table es un objeto de datos de un tipo nuevo: una tabla de contingencia, una table en el argot de R. Como vemos, al aplicar table a un vector obtenemos una tabla unidimensional formada por una fila con los niveles de la variable y una segunda fila donde, debajo de cada nivel, aparece su frecuencia absoluta en el vector. Los nombres de las columnas de una tabla unidimensional se obtienen con la función names. names(table(x)) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;5&quot; &quot;6&quot; names(table(Respuestas)) ## [1] &quot;No&quot; &quot;Si&quot; Habréis observado que en la table de un vector sólo aparecen los nombres de los niveles presentes en el vector. Si el tipo de datos cualitativos usado tenía más niveles y queremos que aparezcan explícitamente en la tabla (con frecuencia 0), hay que transformar el vector en un factor con los niveles deseados. z=factor(x, levels=1:7) #Los niveles serán 1,2,3,4,5,6,7 z ## [1] 3 2 5 1 3 1 5 6 2 2 2 1 3 5 2 ## Levels: 1 2 3 4 5 6 7 table(z) ## z ## 1 2 3 4 5 6 7 ## 3 5 3 0 3 1 0 A efectos prácticos, podemos pensar que una tabla unidimensional es como un vector de números donde cada entrada está identificada por un nombre: el de su columna. Para referirnos a una entrada de una tabla unidimensional, podemos usar tanto su posición como su nombre (entre comillas, aunque sea un número). table(x)[4] #La cuarta columna de table(x) ## 5 ## 3 table(x)[&quot;4&quot;] #¿La columna de table(x) con nombre 4? ## &lt;NA&gt; ## NA table(x)[&quot;5&quot;] #La columna de table(x) con nombre 5 ## 5 ## 3 3*table(x)[2] #El triple de la segunda columna de table(x) ## 2 ## 15 Las tablas de contingencia aceptan la mayoría de las funciones explicadas para vectores. sum(table(x)) #Suma de las entradas de table(x) ## [1] 15 sqrt(table(Respuestas)) #Raíces cuadradas de las entradas de table(Respuestas) ## Respuestas ## No Si ## 2.236068 1.732051 La tabla de frecuencias relativas de un vector se puede calcular aplicando la función prop.table a su table. El resultado vuelve a ser una tabla de contingencia unidimensional. prop.table(table(x)) ## x ## 1 2 3 5 6 ## 0.20000000 0.33333333 0.20000000 0.20000000 0.06666667 prop.table(table(Respuestas)) ## Respuestas ## No Si ## 0.625 0.375 ¡Atención! La función prop.table se tiene que aplicar al resultado de table, no al vector original. Si aplicamos prop.table a un vector de palabras o a un factor, dará un error, pero si la aplicamos a un vector de números, nos dará una tabla. Esta tabla no es la tabla de frecuencias relativas de la variable cualitativa representada por el vector, sino la de una variable que tuviera como tabla de frecuencias absolutas este vector de números, entendiendo que cada entrada del vector representa la frecuencia de un nivel diferente. prop.table(x) ## [1] 0.06976744 0.04651163 0.11627907 0.02325581 0.06976744 0.02325581 ## [7] 0.11627907 0.13953488 0.04651163 0.04651163 0.04651163 0.02325581 ## [13] 0.06976744 0.11627907 0.04651163 X=c(1,1,1) prop.table(table(X)) ## X ## 1 ## 1 prop.table(X) ## [1] 0.3333333 0.3333333 0.3333333 También podemos calcular la tabla de frecuencias relativas de un vector dividiendo el resultado de table por el número de observaciones. table(x)/length(x) ## x ## 1 2 3 5 6 ## 0.20000000 0.33333333 0.20000000 0.20000000 0.06666667 Dados un vector \\(x\\) y un número natural \\(n\\), la instrucción names(which(table(\\(x\\))==\\(n\\))) nos da los niveles que tienen frecuencia absoluta \\(n\\) en \\(x\\). table(x) ## x ## 1 2 3 5 6 ## 3 5 3 3 1 names(which(table(x)==3)) ## [1] &quot;1&quot; &quot;3&quot; &quot;5&quot; names(which(table(x)==2)) ## character(0) En particular, por lo tanto, names(which(table(\\(x\\))==max(table(\\(x\\))))) nos da los niveles de frecuencia máxima en \\(x\\): su moda. names(which(table(x)==max(table(x)))) ## [1] &quot;2&quot; names(which(table(Respuestas)==max(table(Respuestas)))) ## [1] &quot;No&quot; Ejemplo 8.2 Continuamos en la situación del Ejemplo~??. Para calcular las frecuencias y la moda con R, haríamos lo siguiente: Sexo_Ger=c(&quot;Mujer&quot;,&quot;Mujer&quot;,&quot;Hombre&quot;,&quot;Mujer&quot;,&quot;Mujer&quot;,&quot;Mujer&quot;, &quot;Mujer&quot;,&quot;Mujer&quot;,&quot;Hombre&quot;,&quot;Mujer&quot;,&quot;Hombre&quot;,&quot;Hombre&quot;,&quot;Mujer&quot;, &quot;Mujer&quot;,&quot;Hombre&quot;,&quot;Mujer&quot;,&quot;Mujer&quot;,&quot;Mujer&quot;,&quot;Mujer&quot;,&quot;Hombre&quot;) t0=table(Sexo_Ger) t0 ## Sexo_Ger ## Hombre Mujer ## 6 14 Sexo_Ger ## [1] &quot;Mujer&quot; &quot;Mujer&quot; &quot;Hombre&quot; &quot;Mujer&quot; &quot;Mujer&quot; &quot;Mujer&quot; &quot;Mujer&quot; ## [8] &quot;Mujer&quot; &quot;Hombre&quot; &quot;Mujer&quot; &quot;Hombre&quot; &quot;Hombre&quot; &quot;Mujer&quot; &quot;Mujer&quot; ## [15] &quot;Hombre&quot; &quot;Mujer&quot; &quot;Mujer&quot; &quot;Mujer&quot; &quot;Mujer&quot; &quot;Hombre&quot; prop.table(t0) ## Sexo_Ger ## Hombre Mujer ## 0.3 0.7 Sexo_Ger ## [1] &quot;Mujer&quot; &quot;Mujer&quot; &quot;Hombre&quot; &quot;Mujer&quot; &quot;Mujer&quot; &quot;Mujer&quot; &quot;Mujer&quot; ## [8] &quot;Mujer&quot; &quot;Hombre&quot; &quot;Mujer&quot; &quot;Hombre&quot; &quot;Hombre&quot; &quot;Mujer&quot; &quot;Mujer&quot; ## [15] &quot;Hombre&quot; &quot;Mujer&quot; &quot;Mujer&quot; &quot;Mujer&quot; &quot;Mujer&quot; &quot;Hombre&quot; names(which(t0==max(t0))) ## [1] &quot;Mujer&quot; 8.3 Tablas bidimensionales de frecuencias La función table también permite construir tablas de frecuencias conjuntas de dos o más variables. A modo de ejemplo, supongamos que el vector Respuestas, de la sección anterior, contiene las respuestas a una pregunta dadas por unos individuos cuyos sexos tenemos almacenados en un vector Sexo, en el mismo orden que sus respuestas. En este caso, podemos construir una tabla que nos diga cuántos individuos de cada sexo han dado cada respuesta. Respuestas=c(&quot;No&quot;,&quot;No&quot;,&quot;Si&quot;,&quot;No&quot;,&quot;Si&quot;,&quot;No&quot;,&quot;No&quot;,&quot;Si&quot;) Sexo=c(&quot;M&quot;,&quot;M&quot;,&quot;M&quot;,&quot;H&quot;,&quot;H&quot;,&quot;H&quot;,&quot;H&quot;,&quot;H&quot;) #H es hombre, M es mujer table(Respuestas,Sexo) ## Sexo ## Respuestas H M ## No 3 2 ## Si 2 1 table(Sexo,Respuestas) ## Respuestas ## Sexo No Si ## H 3 2 ## M 2 1 El resultado es, en ambos casos, una tabla de contingencia como antes, pero ahora bidimensional , puesto que cada entrada tiene dos dimensiones, una por cada variable, como en una matriz. Como podemos ver, en una tabla bidimensional producida aplicando table a dos vectores, los niveles del primer vector en el argumento definen las filas, y los del segundo, las columnas. Así, en table(Respuestas,Sexo), las filas corresponden a las respuestas y las columnas a los sexos. Para intercambiar filas por columnas, es decir, para &lt;&gt; la tabla sin tener que recalcularla, podemos usar la misma función t que usamos para trasponer matrices: t(table(Respuestas,Sexo)) ## Respuestas ## Sexo No Si ## H 3 2 ## M 2 1 En la práctica, tenéis que decidir si alguna de las asignaciones de variables a dimensiones es más conveniente que la otra. Por ejemplo, y teniendo en cuenta que nuestra manera natural de leer una tabla es por filas, si lo que nos interesa son las frecuencias de las respuestas entre las personas de cada sexo, seguramente lo más adecuado será elegir el sexo como variable para las filas. Para referirnos a una entrada de una tabla bidimensional podemos usar la construcción [ , ] como si estuviéramos en una matriz o un data frame Dentro de los corchetes, tanto podemos usar los índices como los nombres (entre comillas) de los niveles. table(Respuestas,Sexo)[1,2] ## [1] 2 table(Respuestas,Sexo)[&quot;No&quot;,&quot;M&quot;] ## [1] 2 table(Sexo,Respuestas)[1,2] ## [1] 2 table(Sexo,Respuestas)[&quot;H&quot;,&quot;Si&quot;] ## [1] 2 Como en el caso unidimensional, la función prop.table sirve para calcular tablas bidimensionales de frecuencias relativas conjuntas de pares de variables. Pero en el caso bidimensional tenemos dos tipos de frecuencias relativas, que definen, para cada par de variables, tres tablas diferentes: Las frecuencias relativas globales : para cada par de niveles, uno de cada variable, la fracción de individuos que pertenecen a ambos niveles respecto del total de la muestra; por ejemplo, la fracción de mujeres que han contestado que sí respecto del total de la muestra sería la frecuencia relativa global del par (mujer, sí). Las frecuencias relativas marginales : dentro de cada nivel de una variable, y para cada nivel de la otra, la fracción de individuos que pertenecen al segundo nivel respecto del total de la subpoblación definida por el primer nivel; por ejemplo, la fracción de mujeres que han contestado que sí respecto del total de mujeres sería una frecuencia relativa marginal. Dadas dos variables, se pueden calcular dos familias de frecuencias relativas marginales, según cuál sea la variable que defina las subpoblaciones en las que calculemos las frecuencias relativas de los niveles de la otra variable; no es lo mismo la fracción de mujeres que han contestado que sí respecto del total de mujeres, que la fracción de mujeres que han contestado que sí respecto del total de personas que han dado esta misma respuesta. La tabla de frecuencias relativas globales se calcula aplicando sin más la función prop.table a la table. Por lo que se refiere a las frecuencias relativas marginales, la variable que define las subpoblaciones en las que las calculamos se indica con el parámetro margin. Así, con margin=1 especificamos que la variable que define las subpoblaciones es la primera, y que, por lo tanto, las frecuencias relativas se calculan dentro de las filas; en cambio, con margin=2 especificamos que la variable que define las subpoblaciones es la segunda, por lo que las frecuencias relativas se calculan por columnas; margin=NULL es su valor por defecto y, por lo tanto, equivalente a no especificar este parámetro. prop.table(table(Sexo,Respuestas)) #Global ## Respuestas ## Sexo No Si ## H 0.375 0.250 ## M 0.250 0.125 prop.table(table(Sexo,Respuestas), margin=1) #Por sexo ## Respuestas ## Sexo No Si ## H 0.6000000 0.4000000 ## M 0.6666667 0.3333333 prop.table(table(Sexo,Respuestas), margin=2) #Por respuesta ## Respuestas ## Sexo No Si ## H 0.6000000 0.6666667 ## M 0.4000000 0.3333333 De esta manera: La tabla prop.table(table(Sexo,Respuestas)) nos da la fracción del total que representa cada pareja (sexo, respuesta): por ejemplo, un \\(25\\%\\) del total de la muestra son mujeres que han contestado que no. La tabla prop.table(table(Sexo,Respuestas), margin=1) nos da la fracción que representa cada respuesta dentro de cada sexo: por ejemplo, un 66.67% de las mujeres han contestado que no. La tabla prop.table(table(Sexo,Respuestas), margin=2) nos da la fracción que representa cada sexo dentro de cada respuesta: por ejemplo, las mujeres representan el \\(40\\%\\) del total de las personas que han contestado que no. La función CrossTable del paquete gmodels permite producir (especificando el parámetro prop.chisq=FALSE) un resumen de la tabla de frecuencias absolutas y las tres tablas de frecuencias relativas de dos variables en un formato adecuado para su visualización: #Instalamos y cargamos el paquete &quot;gmodels&quot; library(gmodels) CrossTable(Sexo,Respuestas,prop.chisq=FALSE) ## ## ## Cell Contents ## |-------------------------| ## | N | ## | N / Row Total | ## | N / Col Total | ## | N / Table Total | ## |-------------------------| ## ## ## Total Observations in Table: 8 ## ## ## | Respuestas ## Sexo | No | Si | Row Total | ## -------------|-----------|-----------|-----------| ## H | 3 | 2 | 5 | ## | 0.600 | 0.400 | 0.625 | ## | 0.600 | 0.667 | | ## | 0.375 | 0.250 | | ## -------------|-----------|-----------|-----------| ## M | 2 | 1 | 3 | ## | 0.667 | 0.333 | 0.375 | ## | 0.400 | 0.333 | | ## | 0.250 | 0.125 | | ## -------------|-----------|-----------|-----------| ## Column Total | 5 | 3 | 8 | ## | 0.625 | 0.375 | | ## -------------|-----------|-----------|-----------| ## ## La leyenda Cell Contents explica los contenidos de cada celda de la tabla: en este caso, y en orden descendente, la frecuencia absoluta N, la frecuencia relativa por filas, la frecuencia relativa por columnas, y la frecuencia relativa global. Asimismo, se muestran las celdas de los márgenes, con las frecuencias absolutas y relativas de cada fila (en la columna &lt;&lt;Row Total&gt;&gt;) y cada columna (en la fila &lt;&lt;Column Total&gt;&gt;). Esta función dispone de muchos parámetros que permiten modificar el contenido de las celdas y que podéis consultar en su Ayuda. Una tabla de contingencia bidimensional es, básicamente, una matriz con algunos atributos extra. En particular, podemos usar sobre estas tablas la mayoría de las funciones para matrices que tengan sentido para tablas; por ejemplo, rowSums y colSums se pueden aplicar a una tabla y suman sus filas y sus columnas, respectivamente: table(Sexo,Respuestas) ## Respuestas ## Sexo No Si ## H 3 2 ## M 2 1 colSums(table(Sexo,Respuestas)) ## No Si ## 5 3 rowSums(table(Sexo,Respuestas)) ## H M ## 5 3 colSums(prop.table(table(Sexo,Respuestas))) ## No Si ## 0.625 0.375 rowSums(prop.table(table(Sexo,Respuestas))) ## H M ## 0.625 0.375 También podemos usar sobre una tabla bidimensional (o, en general, multidimensional) la función apply con la misma sintaxis que para matrices; véase la próxima sección. 8.4 Tablas multidimensionales de frecuencias En general, podemos calcular tablas de frecuencias de cualquier número de variables, no sólo de una o dos. El manejo de estas tablas multidimensionales es similar al caso bidimensional, simplemente recordando que ahora hay más variables que tener en cuenta a la hora, por ejemplo, de especificar entradas o de calcular frecuencias relativas marginales. Veamos un ejemplo tridimensional. Supongamos que, además de los vectores Respuestas=c(&quot;No&quot;,&quot;No&quot;,&quot;Si&quot;,&quot;No&quot;,&quot;Si&quot;,&quot;No&quot;,&quot;No&quot;,&quot;Si&quot;) Sexo=c(&quot;M&quot;,&quot;M&quot;,&quot;M&quot;,&quot;H&quot;,&quot;H&quot;,&quot;H&quot;,&quot;H&quot;,&quot;H&quot;) tenemos un tercer vector con las nacionalidades de los individuos representados en estos dos vectores: Pais=c(&quot;Francia&quot;,&quot;Alemania&quot;,&quot;Italia&quot;,&quot;Italia&quot;,&quot;Italia&quot;,&quot;Italia&quot;, &quot;Alemania&quot;,&quot;Francia&quot;) Podemos calcular entonces una tabla de frecuencias absolutas para las ternas (sexo, respuesta, país). table(Sexo,Respuestas,Pais) ## , , Pais = Alemania ## ## Respuestas ## Sexo No Si ## H 1 0 ## M 1 0 ## ## , , Pais = Francia ## ## Respuestas ## Sexo No Si ## H 0 1 ## M 1 0 ## ## , , Pais = Italia ## ## Respuestas ## Sexo No Si ## H 2 1 ## M 0 1 R muestra la tabla tridimensional que obtenemos como una lista de tablas bidimensionales table(Sexo,Respuestas), separando la población según los niveles de la tercera variable. Si no os gusta esta manera de visualizar una tabla tridimensional, una alternativa es usar la función ftable, que la mostrará en lo que se llama formato plano: ftable(Sexo,Respuestas,Pais) ## Pais Alemania Francia Italia ## Sexo Respuestas ## H No 1 0 2 ## Si 0 1 1 ## M No 1 1 0 ## Si 0 0 1 Los parámetros row.vars y col.vars de ftable permiten especificar qué variables queremos que aparezcan como filas o como columnas. ftable(Sexo,Respuestas,Pais, col.vars=c(&quot;Sexo&quot;,&quot;Respuestas&quot;)) ## Sexo H M ## Respuestas No Si No Si ## Pais ## Alemania 1 0 1 0 ## Francia 0 1 1 0 ## Italia 2 1 0 1 Para referirnos a una entrada, o a una subtabla, de una tabla podemos usar los corchetes. table(Sexo,Respuestas,Pais)[&quot;H&quot;,&quot;Si&quot;,&quot;Italia&quot;] ## [1] 1 table(Sexo,Respuestas,Pais)[ , ,&quot;Italia&quot;] ## Respuestas ## Sexo No Si ## H 2 1 ## M 0 1 table(Sexo,Respuestas,Pais)[ ,&quot;Si&quot;,&quot;Italia&quot;] ## H M ## 1 1 table(Sexo,Respuestas,Pais)[&quot;M&quot;, ,&quot;Italia&quot;] ## No Si ## 0 1 En una tabla multidimensional, podemos calcular frecuencias relativas marginales respecto de los niveles de una variable o respecto de combinaciones de niveles de varias variables: por ejemplo, las frecuencias relativas marginales de las respuestas en cada combinación (sexo, país). Como en el caso bidimensional, las tablas correspondientes se calculan aplicando prop.table a la tabla de frecuencias absolutas, y especificando con el parámetro margin las dimensiones, o combinaciones de dimensiones, respecto de las que calculamos las frecuencias relativas. Si no se especifica el parámetro margin, se obtiene la tabla de frecuencias relativas globales. prop.table(table(Sexo,Respuestas,Pais)) #Frecuencias relativas globales ## , , Pais = Alemania ## ## Respuestas ## Sexo No Si ## H 0.125 0.000 ## M 0.125 0.000 ## ## , , Pais = Francia ## ## Respuestas ## Sexo No Si ## H 0.000 0.125 ## M 0.125 0.000 ## ## , , Pais = Italia ## ## Respuestas ## Sexo No Si ## H 0.250 0.125 ## M 0.000 0.125 prop.table(ftable(Sexo,Respuestas,Pais)) #Frecuencias relativas globales, en formato plano ## Pais Alemania Francia Italia ## Sexo Respuestas ## H No 0.125 0.000 0.250 ## Si 0.000 0.125 0.125 ## M No 0.125 0.125 0.000 ## Si 0.000 0.000 0.125 prop.table(table(Sexo,Respuestas,Pais), margin=3) #Frecuencias relativas por país ## , , Pais = Alemania ## ## Respuestas ## Sexo No Si ## H 0.50 0.00 ## M 0.50 0.00 ## ## , , Pais = Francia ## ## Respuestas ## Sexo No Si ## H 0.00 0.50 ## M 0.50 0.00 ## ## , , Pais = Italia ## ## Respuestas ## Sexo No Si ## H 0.50 0.25 ## M 0.00 0.25 prop.table(table(Sexo,Respuestas,Pais), margin=c(1,3)) #Frecuencias relativas por sexo y país ## , , Pais = Alemania ## ## Respuestas ## Sexo No Si ## H 1.0000000 0.0000000 ## M 1.0000000 0.0000000 ## ## , , Pais = Francia ## ## Respuestas ## Sexo No Si ## H 0.0000000 1.0000000 ## M 1.0000000 0.0000000 ## ## , , Pais = Italia ## ## Respuestas ## Sexo No Si ## H 0.6666667 0.3333333 ## M 0.0000000 1.0000000 En este caso: La tabla prop.table(table(Sexo,Respuestas,Pais)) nos da la fracción que representa cada terna (sexo, respuesta, país) dentro del total de la muestra: por ejemplo, los hombres españoles que han contestado afirmativamente forman un \\(12.5\\%\\) del total de individuos. La tabla prop.table(table(Sexo,Respuestas,Pais), margin=3) nos da la fracción que representa cada pareja (sexo, respuesta) dentro de cada país: por ejemplo, los hombres que han contestado que sí representan un \\(25\\%\\) del total de individuos españoles. La tabla prop.table(table(Sexo,Respuestas,Pais), margin=c(1,3)) nos da la fracción que representa cada respuesta dentro de cada combinación de (sexo, país): por ejemplo, un \\(33.33\\%\\) del total de hombres españoles ha contestado que sí. Observad, también, que al aplicar prop.table al resultado de una ftable, la tabla resultante sigue en formato plano. Podemos aplicar funciones a filas o columnas de (sub)tablas de una tabla multidimensional con la función apply, especificando en el parámetro FUN la función y en el parámetro MARGIN la variable o combinación de variables a la que aplicamos la función (son las variables que aparecerán en la tabla resultante). Observad las dos instrucciones siguientes y sus resultados: apply(table(Sexo,Respuestas,Pais), MARGIN=c(1,3), FUN=sum) ## Pais ## Sexo Alemania Francia Italia ## H 1 1 3 ## M 1 1 1 apply(table(Sexo,Respuestas,Pais), MARGIN=2, FUN=sum) ## No Si ## 5 3 Hasta ahora hemos manipulado tablas de frecuencias que hemos construido nosotros mismos a partir de variables cualitativas. Todo lo que hemos hecho con estas tablas se puede también hacer con las tablas de frecuencias que lleva R predefinidas o que obtengamos de otra manera. Por ejemplo, el objeto de datos HairEyeColor que lleva predefinido R es una tabla las frecuencias absolutas, en una muestra de personas, de tres variables cualitativas: color de cabello (Hair), color de los ojos (Eye) y sexo (Sex), en este orden. HairEyeColor ## , , Sex = Male ## ## Eye ## Hair Brown Blue Hazel Green ## Black 32 11 10 3 ## Brown 53 50 25 15 ## Red 10 10 7 7 ## Blond 3 30 5 8 ## ## , , Sex = Female ## ## Eye ## Hair Brown Blue Hazel Green ## Black 36 9 5 2 ## Brown 66 34 29 14 ## Red 16 7 7 7 ## Blond 4 64 5 8 ftable(HairEyeColor) ## Sex Male Female ## Hair Eye ## Black Brown 32 36 ## Blue 11 9 ## Hazel 10 5 ## Green 3 2 ## Brown Brown 53 66 ## Blue 50 34 ## Hazel 25 29 ## Green 15 14 ## Red Brown 10 16 ## Blue 10 7 ## Hazel 7 7 ## Green 7 7 ## Blond Brown 3 4 ## Blue 30 64 ## Hazel 5 5 ## Green 8 8 Efectuemos algunas operaciones sobre esta tabla, para ilustrar como podemos trabajar con ella: sum(HairEyeColor) #Número total de individuos en la muestra ## [1] 592 HairEyeColor[ , ,&quot;Male&quot;] #Subtabla de hombres ## Eye ## Hair Brown Blue Hazel Green ## Black 32 11 10 3 ## Brown 53 50 25 15 ## Red 10 10 7 7 ## Blond 3 30 5 8 prop.table(HairEyeColor, margin=3) #Frecuencias relativas de las combinaciones(color de cabello, color de ojos) en cada sexo ## , , Sex = Male ## ## Eye ## Hair Brown Blue Hazel Green ## Black 0.114695341 0.039426523 0.035842294 0.010752688 ## Brown 0.189964158 0.179211470 0.089605735 0.053763441 ## Red 0.035842294 0.035842294 0.025089606 0.025089606 ## Blond 0.010752688 0.107526882 0.017921147 0.028673835 ## ## , , Sex = Female ## ## Eye ## Hair Brown Blue Hazel Green ## Black 0.115015974 0.028753994 0.015974441 0.006389776 ## Brown 0.210862620 0.108626198 0.092651757 0.044728435 ## Red 0.051118211 0.022364217 0.022364217 0.022364217 ## Blond 0.012779553 0.204472843 0.015974441 0.025559105 prop.table(HairEyeColor, margin=c(1,2)) #Frecuencias relativas de los sexos en cada combinación (color de cabello, color de ojos) ## , , Sex = Male ## ## Eye ## Hair Brown Blue Hazel Green ## Black 0.4705882 0.5500000 0.6666667 0.6000000 ## Brown 0.4453782 0.5952381 0.4629630 0.5172414 ## Red 0.3846154 0.5882353 0.5000000 0.5000000 ## Blond 0.4285714 0.3191489 0.5000000 0.5000000 ## ## , , Sex = Female ## ## Eye ## Hair Brown Blue Hazel Green ## Black 0.5294118 0.4500000 0.3333333 0.4000000 ## Brown 0.5546218 0.4047619 0.5370370 0.4827586 ## Red 0.6153846 0.4117647 0.5000000 0.5000000 ## Blond 0.5714286 0.6808511 0.5000000 0.5000000 Para cambiar el orden de las variables en una tabla multidimensional, se puede usar la instrucción aperm( tabla , perm=…), igualando el parámetro perm a la lista de las variables en el orden deseado. Por ejemplo, si queremos una tabla equivalente a HairEyeColor, pero con primera variable Sex, segunda variable Hair y tercera variable Eye, podemos hacer: aperm(HairEyeColor, perm=c(&quot;Sex&quot;, &quot;Hair&quot;, &quot;Eye&quot;)) ## , , Eye = Brown ## ## Hair ## Sex Black Brown Red Blond ## Male 32 53 10 3 ## Female 36 66 16 4 ## ## , , Eye = Blue ## ## Hair ## Sex Black Brown Red Blond ## Male 11 50 10 30 ## Female 9 34 7 64 ## ## , , Eye = Hazel ## ## Hair ## Sex Black Brown Red Blond ## Male 10 25 7 5 ## Female 5 29 7 5 ## ## , , Eye = Green ## ## Hair ## Sex Black Brown Red Blond ## Male 3 15 7 8 ## Female 2 14 7 8 8.5 Tablas a partir de dta frames de de variables cualitativas Como ya hemos comentado en varias ocasiones, la manera natural de organizar datos multidimensionales en R es en forma de data frame En esta sección explicaremos algunas instrucciones para calcular tablas de frecuencias absolutas a partir de un data frame de variables cualitativas. Para ilustrarla, usaremos el fichero que se encuentra en el url http://aprender.uib.es/Rdir/bebenerg.txt . Este fichero consiste en una tabla de datos con la siguiente información sobre 122 estudiantes de la Escuela Politécnica Superior de la UIB: su sexo (variable sexo), el grado en el que están matriculados (variable estudio) y si consumen habitualmente bebidas energéticas (variable bebe). Como contiene letras acentuadas, conviene que uséis el parámetro encoding. Beb_Energ=read.table(&quot;http://aprender.uib.es/Rdir/bebenerg.txt&quot;, header=TRUE, encoding=&quot;UTF-8&quot;) str(Beb_Energ) ## &#39;data.frame&#39;: 122 obs. of 3 variables: ## $ estudio: Factor w/ 4 levels &quot;Informática&quot;,..: 1 3 2 1 2 3 1 2 1 1 ... ## $ bebe : Factor w/ 2 levels &quot;No&quot;,&quot;Sí&quot;: 1 1 2 2 1 1 2 1 1 1 ... ## $ sexo : Factor w/ 2 levels &quot;Hombre&quot;,&quot;Mujer&quot;: 2 1 2 1 2 2 1 1 1 1 ... head(Beb_Energ) ## estudio bebe sexo ## 1 Informática No Mujer ## 2 Matemáticas No Hombre ## 3 Ing.Industrial Sí Mujer ## 4 Informática Sí Hombre ## 5 Ing.Industrial No Mujer ## 6 Matemáticas No Mujer Aplicando la función summary a un data frame de variables cualitativas, obtenemos, a modo de resumen, una tabla con las frecuencias absolutas de cada variable. summary(Beb_Energ) ## estudio bebe sexo ## Informática :53 No:97 Hombre:83 ## Ing.Industrial:37 Sí:25 Mujer :39 ## Matemáticas :16 ## Telemática :16 Esta tabla sólo sirve para ver la información, porque sus entradas son palabras. summary(Beb_Energ)[,2] ## ## &quot;No:97 &quot; &quot;Sí:25 &quot; NA NA Para calcular en un solo paso la table de cada variable, podemos usar la función sapply de la manera siguiente: sapply(Beb_Energ, FUN=table) ## $estudio ## ## Informática Ing.Industrial Matemáticas Telemática ## 53 37 16 16 ## ## $bebe ## ## No Sí ## 97 25 ## ## $sexo ## ## Hombre Mujer ## 83 39 De esta manera, obtenemos una list cuyas componentes son las tablas que queríamos. sapply(Beb_Energ, FUN=table)$sexo ## ## Hombre Mujer ## 83 39 table(Beb_Energ$sexo) ## ## Hombre Mujer ## 83 39 Si aplicamos la función table a un data frame de variables cualitativas, obtenemos su tabla de frecuencias absolutas, con las variables ordenadas tal y como aparecen en el data frame table(Beb_Energ) ## , , sexo = Hombre ## ## bebe ## estudio No Sí ## Informática 30 7 ## Ing.Industrial 19 6 ## Matemáticas 8 1 ## Telemática 10 2 ## ## , , sexo = Mujer ## ## bebe ## estudio No Sí ## Informática 11 5 ## Ing.Industrial 10 2 ## Matemáticas 6 1 ## Telemática 3 1 table(Beb_Energ[c(1,3)]) ## sexo ## estudio Hombre Mujer ## Informática 37 16 ## Ing.Industrial 25 12 ## Matemáticas 9 7 ## Telemática 12 4 Otra opción es usar la función ftable, que produce la misma tabla de frecuencias pero en formato plano. ftable(Beb_Energ) ## sexo Hombre Mujer ## estudio bebe ## Informática No 30 11 ## Sí 7 5 ## Ing.Industrial No 19 10 ## Sí 6 2 ## Matemáticas No 8 6 ## Sí 1 1 ## Telemática No 10 3 ## Sí 2 1 8.6 Diagramas de barras El tipo de gráfico más usado para representar variables cualitativas son los diagramas de barras (bar plots). Como su nombre indica, un diagrama de barras contiene, para cada nivel de la variable cualitativa, una barra de altura su frecuencia; por ejemplo, la Figura8.1 es un diagrama de barras de las frecuencias absolutas de los dos niveles de la muestra de sexos del Ejemplo ??. El código que lo ha producido, y que explicaremos en esta sección, es el siguiente: barplot(table(Sexo_Ger), col=c(&quot;lightblue&quot;,&quot;pink&quot;), main=&quot;Diagrama de barras de las frecuencias absolutas\\n de la variable \\&quot;Sexo_Ger\\&quot;&quot;) Figura 8.1: Diagrama de barras de las frecuencias absolutas de los datos del Ejemplo ??. La función \\n dentro de una frase entrada entre comillas introduce un cambio de línea. El mismo efecto se obtiene con un cambio de línea. Id con cuidado, porque ambos efectos se acumulan, así que si cambiáis de línea después del \\n, obtendréis una línea en blanco. Por otro lado, \\\\&quot; escribe unas comillas en el texto entrado entre comillas. La manera más sencilla de dibujar un diagrama de barras de las frecuencias absolutas o relativas de una variable cualitativa es usando la instrucción barplot aplicada a la tabla correspondiente. Así, x=c(3,2,5,1,3,1,5,6,2,2,2,1,3,5,2) Respuestas=c(&quot;No&quot;,&quot;No&quot;,&quot;Si&quot;,&quot;No&quot;,&quot;Si&quot;,&quot;No&quot;,&quot;No&quot;,&quot;Si&quot;) par(mfrow=c(1,2))# dos figuras en un plot barplot(table(x), main=&quot;Diagrama de barras de frecuencias absolutas de la variable \\&quot;x\\&quot;&quot;) barplot(prop.table(table(Respuestas)), main=&quot;Diagrama de barras de frecuencias relativas\\n de la variable \\&quot;Respuestas\\&quot;&quot;) par(mfrow=c(1,1))# volvemos a una figura por plot Figura 8.2: Diagramas de barras. produce los diagramas de la Figura 8.2. ¡Atención! Como pasaba con prop.table, el argumento de barplot ha de ser una tabla, y, por consiguiente, se ha de aplicar al resultado de table o de prop.table, nunca al vector de datos original. Habréis observado que en las funciones barplot anteriores hemos usado el parámetro main para poner título a los diagramas; en general, la función barplot admite los parámetros de plot que tienen sentido en el contexto de los diagramas de barras: xlab, ylab, main, etc. Los parámetros disponibles se pueden consultar en la Ayuda de barplot. Aquí sólo vamos a comentar algunos. Se pueden especificar los colores de las barras usando el parámetro col. Si se iguala a un solo color, todas las barras serán de este color, pero también se puede especificar un color para cada barra, igualando col a un vector de colores. Por ejemplo, barplot(table(Respuestas), col=c(&quot;green&quot;)) barplot(table(Respuestas), col=c(&quot;red&quot;,&quot;blue&quot;)) producen, respectivamente, los dos diagramas de la Figura~8.3. En un diagrama con muchas barras, es conveniente usar un esquema adecuado de colores para ellas. Para ello se puede usar el paquete RColorBrewer, del que hablaremos en detalle en la Sección (sec:grmulti). knitr::include_graphics(c(&quot;images/barplotyverd.png&quot;,&quot;images/barploty2col.png&quot;)) Figura 8.3: Ejemplos de diagramas de barras de colores. Una opción interesante es dibujar las barras horizontales en vez de verticales: para hacerlo, se tiene que añadir el parámetro horiz=TRUE. Así, la Figura~@ref(fig:F1606} se obtiene con la siguiente instrucción: barplot(table(x), horiz=TRUE) Figura 8.4: Un diagrama de barras horizontales. Si se aplica barplot a una tabla bidimensional, por defecto dibuja las barras de la segunda variable cortadas por la frecuencia de la primera variable: se le llama un diagrama de barras apiladas . Por ejemplo, las instrucciones siguientes producen la Figura~??. Respuestas=c(&quot;No&quot;,&quot;No&quot;,&quot;Si&quot;,&quot;No&quot;,&quot;Si&quot;,&quot;No&quot;,&quot;No&quot;,&quot;Si&quot;) Sexo=c(&quot;M&quot;,&quot;M&quot;,&quot;M&quot;,&quot;H&quot;,&quot;H&quot;,&quot;H&quot;,&quot;H&quot;,&quot;H&quot;) table(Sexo,Respuestas) ## Respuestas ## Sexo No Si ## H 3 2 ## M 2 1 barplot(table(Sexo,Respuestas)) Figura 8.5: Diagrama de barras apiladas. En un diagrama de barras apiladas, las barras globales corresponden a los niveles de la variable que definen las columnas de la tabla, es decir, la segunda variable especificada dentro de table: en el de la Figura ??, se trata de la variable Respuestas, de niveles No y Si. Cada una de estas barras se divide verticalmente en sectores que representan los niveles de la otra variable, en orden ascendente: en el ejemplo que nos ocupa, la zona inferior de cada barra representa el nivel H de la variable Sexo y la zona superior su nivel M. En vez de organizar las barras de la primera variable en una sola barra vertical, se pueden dibujar una junto a la otra añadiendo el parámetro beside=TRUE, obteniéndose de esta manera un diagrama de barras por bloques . Así, barplot(table(Sexo,Respuestas), beside=TRUE) produce el diagrama de barras de la izquierda de la Figura 8.6. En este diagrama, cada bloque de barras representa un nivel de la variable de las columnas (No y Si), y en cada uno de estos bloques las barras representan los niveles de las filas en su orden (en cada bloque, la barra de la izquierda corresponde a H y la de la derecha a M). Los diagramas de barras tienen que mostrar la información de la manera más adecuada. Por ejemplo, en un diagrama de barras por bloques, si lo que nos interesa es la distribución de las respuestas por sexo, los bloques de barras deberían corresponder a los sexos, y las barras dentro de cada bloque a las respuestas. En este caso, convendría cambiar el orden de los vectores dentro de la table a la que aplicamos barplot, o trasponer la tabla antes de aplicarle barplot. Suele ser conveniente añadir a un diagrama de barras de dos variables una leyenda que indique qué nivel representa cada sector (en los diagramas de barras apiladas) o cada barra (en los diagramas de barras por bloques). Esto se puede realizar entrando el parámetro legend.text igualado a TRUE, si no queremos modificar los nombres de los niveles de las filas, o igualado a un vector con los nombres que les queremos asignar (en el orden que toque). Por ejemplo, barplot(table(Sexo,Respuestas), beside=TRUE, legend.text=TRUE) produce el diagrama de la derecha de la Figura 8.6. knitr::include_graphics(c(&quot;images/barplotSybeside.png&quot;,&quot;images/barplotSYbesidelegend.png&quot;)) Figura 8.6: Diagramas de barras por bloques. La leyenda que genera R se puede modificar usando el parámetro args.legend igualado a una list con los parámetros que usaríamos en la función legend que explicamos en la Lección 7: x, para indicar la posición de la leyenda, cex para indicar el factor por el cual se quiere multiplicar su tamaño, etc. Podéis consultar los parámetros disponibles en la Ayuda de legend. Se pueden cambiar los colores de las barras usando el parámetro col como en los diagramas de barras de tablas unidimensionales. La función legend.text importa estos colores, no hace falta especificarlos en el args.legend. También puede ser conveniente poner nombres más informativos a los niveles de las variables. El parámetro names dentro de barplot permite cambiar los nombres de los niveles que muestra debajo del eje horizontal: en un diagrama de barras de una variable, los de sus niveles, y en un diagrama bidimensional, los de los niveles de la variable de las columnas. Veamos un ejemplo usando col y con los nombres que se muestran de los niveles de ambas variables traducidos al inglés; el resultado es la Figura 8.7: barplot(table(Respuestas,Sexo), beside=TRUE, names=c(&quot;Men&quot;, &quot;Women&quot;), col=c(&quot;red&quot;,&quot;blue&quot;), legend.text=c(&quot;No&quot;,&quot;Yes&quot;)) Figura 8.7: Diagrama de barras para visualizar la distribución de las respuestas por sexo. 8.7 Otros gráficos para datos cualitativos Un tipo muy popular de representación gráfica de variables cualitativas son los {diagramas circulares}. En un diagrama circular (pie chart) se representan los niveles de una variable cualitativa como sectores circulares de un círculo, de manera que el ángulo (o equivalentemente, el área) de cada sector sea proporcional a la frecuencia del nivel al que corresponde. Con R, este tipo de diagramas se producen con la instrucción pie, de nuevo aplicada a una tabla de frecuencias y no al vector original. La función pie admite muchos parámetros para modificar el resultado: se pueden cambiar los colores con col, se pueden cambiar los nombres de los niveles con names, se puede poner un título con main, etc.; podéis consultar la lista completa de parámetros en su Ayuda. Así, por ejemplo, x=c(3,2,5,1,3,1,5,6,2,2,2,1,3,5,2) Respuestas=c(&quot;No&quot;,&quot;No&quot;,&quot;Si&quot;,&quot;No&quot;,&quot;Si&quot;,&quot;No&quot;,&quot;No&quot;,&quot;Si&quot;) pie(table(x), main=&quot;Diagrama circular de la variable \\&quot;x\\&quot;&quot;) pie(table(Respuestas), main=&quot;Diagrama circular de la variable \\&quot;Respuestas\\&quot;&quot;) produce los diagramas de la Figura 8.8. knitr::include_graphics(c(&quot;images/piex2.png&quot;,&quot;images/piey2.png&quot;)) Figura 8.8: Diagramas circulares. Pese a su popularidad, es poco recomendable usar diagramas circulares cuando manejamos más de dos niveles, porque a veces es difícil, a simple vista, comprender las relaciones entre las frecuencias que representan. Para convencerse, basta comparar los diagramas de barras y los diagramas circulares de la Figura 8.9.31 knitr::include_graphics(&quot;images/wikipc.png&quot;) Figura 8.9: Diagramas de barras vs diagramas circulares. Otra representación de las tablas multidimensionales de frecuencias son los gráficos de mosaico . Estos gráficos se obtienen sustituyendo cada entrada de la tabla de frecuencias por una región rectangular de área proporcional a su valor. En concreto, para obtener el gráfico de mosaico de una tabla bidimensional, se parte de un cuadrado de lado 1, primero se divide en barras verticales de amplitudes iguales a las frecuencias relativas de una variable, y luego cada barra se divide, a lo alto, en regiones de alturas proporcionales a las frecuencias relativas marginales de cada nivel de la otra variable dentro del nivel correspondiente de la primera variable. Un gráfico de mosaico de una tabla se obtiene con R aplicando la función plot a la tabla, o también la función mosaicplot; esta última también se puede aplicar a matrices. Por ejemplo, Respuestas=c(&quot;No&quot;,&quot;No&quot;,&quot;Si&quot;,&quot;No&quot;,&quot;Si&quot;,&quot;No&quot;,&quot;No&quot;,&quot;Si&quot;) Sexo=c(&quot;M&quot;,&quot;M&quot;,&quot;M&quot;,&quot;H&quot;,&quot;H&quot;,&quot;H&quot;,&quot;H&quot;,&quot;H&quot;) plot(table(Sexo,Respuestas), main=&quot;Gráfico de mosaico de las variables \\&quot;Sexo\\&quot; y \\&quot;Respuestas\\&quot;&quot;) produce el gráfico de mosaico de la izquierda en la Figura ??. En el gráfico de mosaico de una tabla tridimensional, primero se divide el cuadrado en barras verticales de amplitudes iguales a las frecuencias relativas de una variable; luego, cada barra se divide, a lo alto, en regiones de alturas proporcionales a las frecuencias relativas marginales de cada nivel de una segunda variable dentro del nivel correspondiente de la primera variable; y, finalmente, cada sector rectangular se vuelve a dividir a lo ancho en regiones de amplitudes proporcionales a las frecuencias relativas marginales de cada nivel de la tercera variable dentro de la combinación correspondiente de niveles de las otras dos. Por ejemplo, plot(HairEyeColor, main=&quot;Gráfico de mosaico de la tabla \\&quot;HairEyeColor\\&quot;&quot;, col=c(&quot;pink&quot;,&quot;lightblue&quot;)) produce el gráfico de la derecha en la Figura ??. knitr::include_graphics(c(&quot;images/mosaic1.png&quot;,&quot;images/mosaic2.png&quot;)) Además de sus parámetros usuales, la función plot admite algunos parámetros específicos cuando se usa para producir el gráfico de mosaico de una tabla. Los más interesantes son: col, que ya hemos usado en el gráfico de mosaico anterior, asigna colores a los niveles de la última variable (en ese ejemplo, los sexos). dir, igualado a un vector de direcciones &quot;v&quot; (vertical) y &quot;h&quot; (horizontal), sirve para especificar la dirección de las barras de cada variable (por defecto, como hemos comentado, alternan vertical y horizontal, empezando por vertical). Estos y otros parámetros se pueden consultar en la Ayuda de mosaicplot. El paquete vcd incorpora una función, mosaic, que sirve para producir gráficos de mosaico con algunos aspectos gráficos diferentes. Por ejemplo, la Figura 8.10 se obtiene con #Instalamos y cargamos el paquete &quot;vcd&quot; library(vcd) mosaic(HairEyeColor, dir=c(&quot;v&quot;,&quot;h&quot;,&quot;v&quot;), highlighting=&quot;Sex&quot;, highlighting_fill=c(&quot;pink&quot;,&quot;lightblue&quot;), main=&quot;Gráfico de mosaico de la tabla HairEyeColor&quot;) Figura 8.10: Gràfico de mosaico de obtenido con mosaic. El parámetro dir es el equivalente del parámetro homónimo en mosaicplot (y lo hemos especificado para obtener el gráfico equivalente al de la derecha de la Figura @ref(fig:mosaic1}; por defecto, mosaic toma la primera variable en horizontal); el parámetro highlighting sirve para destacar una variable; y el parámetro highlighting_fill para asignar colores a los niveles de la variable destacada. Para más parámetros, podéis consultar su Ayuda. Los paquetes vcd y vcdExtra incluyen otras funciones que producen representaciones gráficas interesantes de tablas tridimensionales. Por ejemplo: La función cotabplot de vcd produce un diagrama de mosaico para cada nivel de la tercera variable. La función mosaic3d de vcdExtra produce un diagrama de mosaico tridimensional en una ventana de una aplicación para gráficos 3D interactivos. Por ejemplo, con #Ya tenemos cargado el paquete &quot;vcd&quot; cotabplot(table(Sexo,Respuestas,Pais)) #Instalamos y cargamos el paquete vcdExtra library(vcdExtra) mosaic3d(HairEyeColor, type=&quot;expected&quot;, box=TRUE, col=c(&quot;pink&quot;,&quot;lightblue&quot;)) obtenemos los dos gráficos de la Figura 8.11 . knitr::include_graphics(c(&quot;images/cotabplot.png&quot;,&quot;images/exmosaic3d.png&quot;)) Figura 8.11: Ejemplos de gráficos obtenido con cotabplot (izquierda) y mosaic3d (derecha). 8.7.1 Un ejemplo completo Vamos a llevar a cabo un análisis completo de un ejemplo con lo que hemos aprendido en esta lección. Como ya hemos comentado, el objeto de datos HairEyeColor que lleva predefinido R es una tabla de frecuencias absolutas de tres variables cualitativas: color de cabello (Hair), color de los ojos (Eye) y sexo (Sex). Vamos a extraer de esta tabla una tabla bidimensional de frecuencias absolutas de las variables Eye y Hair, sin distinguir según el sexo. La manera más sencilla de obtener esta tabla es combinando la función apply con as.table, para que el resultado final sea una tabla de contingencia (sin esta instrucción, el resultado sería una matriz), de la manera siguiente: HEC=as.table(apply(HairEyeColor, MARGIN=c(1,2), FUN=sum)) HEC ## Eye ## Hair Brown Blue Hazel Green ## Black 68 20 15 5 ## Brown 119 84 54 29 ## Red 26 17 14 14 ## Blond 7 94 10 16 Vamos a traducir al castellano los nombres de las variables de esta tabla y de sus niveles. Esto lo podemos llevar a cabo en un solo paso con la función dimnames que ya usamos sobre data frames. El resultado de aplicar esta función a una table es una list cuyas componentes son los niveles de cada variable. dimnames(HEC) ## $Hair ## [1] &quot;Black&quot; &quot;Brown&quot; &quot;Red&quot; &quot;Blond&quot; ## ## $Eye ## [1] &quot;Brown&quot; &quot;Blue&quot; &quot;Hazel&quot; &quot;Green&quot; Por lo tanto, para reescribir los nombres de las variables y sus niveles, basta redefinir esta list de la manera siguiente: dimnames(HEC)=list(Cabello=c(&quot;Negro&quot;,&quot;Castaño&quot;,&quot;Rojo&quot;,&quot;Rubio&quot;), Ojos=c(&quot;Marrones&quot;,&quot;Azules&quot;,&quot;Pardos&quot;,&quot;Verdes&quot;)) HEC ## Ojos ## Cabello Marrones Azules Pardos Verdes ## Negro 68 20 15 5 ## Castaño 119 84 54 29 ## Rojo 26 17 14 14 ## Rubio 7 94 10 16 Vamos a dibujar un diagrama de mosaico de esta tabla, para visualizar gráficamente sus entradas. plot(HEC,col=c(&quot;lightblue&quot;),main=&quot;Diagrama de mosaico de la tabla bidimensional de frecuencias\\n de colores de cabellos y ojos&quot;) Figura 8.12: Diagrama de mosaico de las frecuencias conjuntas de colores de ojos y de cabellos en HairEyeColor. Obtenemos la Figura 8.12. A simple vista, vemos que las combinaciones de colores de cabellos y ojos más frecuentes son los cabellos castaños con los ojos marrones, y los cabellos rubios con los ojos azules. A continuación, vamos a calcular el número total de individuos representados en esta tabla, así como las tablas de frecuencias absolutas y relativas de cada variable, y representaremos estas últimas en sendos diagramas de barras. sum(HEC) #Número total de individuos ## [1] 592 colSums(HEC) #Frec. abs. de Ojos ## Marrones Azules Pardos Verdes ## 220 215 93 64 rowSums(HEC) #Frec. abs. de Cabello ## Negro Castaño Rojo Rubio ## 108 286 71 127 round(prop.table(colSums(HEC)),3) #Frec. rel. de Ojos ## Marrones Azules Pardos Verdes ## 0.372 0.363 0.157 0.108 round(prop.table(rowSums(HEC)),3) #Frec. rel. de Cabello ## Negro Castaño Rojo Rubio ## 0.182 0.483 0.120 0.215 barplot(prop.table(colSums(HEC)), ylim=c(0,0.4), col=c(&quot;burlywood4&quot;,&quot;lightblue&quot;,&quot;orange3&quot;,&quot;lightgreen&quot;), main=&quot;Frecuencias relativas de colores de ojos&quot;) barplot(prop.table(rowSums(HEC)), col=c(&quot;black&quot;,&quot;brown&quot;,&quot;red&quot;,&quot;gold&quot;), ylim=c(0,0.5), main=&quot;Frecuencias relativas de colores de cabello&quot;) Los diagramas de barras producidos con la dos últimas instrucciones son los de la Figura 8.13. Vemos que el color dominante de cabellos es el castaño, mientras que en el color de ojos el marrón y el azul están prácticamente empatados. knitr::include_graphics(c(&quot;images/HECEye.png&quot;,&quot;images/HEChair.png&quot;)) Figura 8.13: Diagrama de barras de frecuencias relativas de colores de ojos y de cabellos en HairEyeColor. Pasamos ahora a calcular las tablas de frecuencias relativas y dibujar los dos diagramas de barras de las frecuencias relativas marginales. round(prop.table(HEC), 3) #Frec. rel. globales ## Ojos ## Cabello Marrones Azules Pardos Verdes ## Negro 0.115 0.034 0.025 0.008 ## Castaño 0.201 0.142 0.091 0.049 ## Rojo 0.044 0.029 0.024 0.024 ## Rubio 0.012 0.159 0.017 0.027 round(prop.table(HEC, margin=1), 3) #Frec. rel. por filas ## Ojos ## Cabello Marrones Azules Pardos Verdes ## Negro 0.630 0.185 0.139 0.046 ## Castaño 0.416 0.294 0.189 0.101 ## Rojo 0.366 0.239 0.197 0.197 ## Rubio 0.055 0.740 0.079 0.126 round(prop.table(HEC, margin=2), 3) #Frec. rel. por columnas ## Ojos ## Cabello Marrones Azules Pardos Verdes ## Negro 0.309 0.093 0.161 0.078 ## Castaño 0.541 0.391 0.581 0.453 ## Rojo 0.118 0.079 0.151 0.219 ## Rubio 0.032 0.437 0.108 0.250 barplot(prop.table(HEC, margin=1), beside=TRUE, legend.text=TRUE, col=c(&quot;black&quot;,&quot;brown&quot;,&quot;red&quot;,&quot;gold&quot;), ylim=c(0,0.8), main=&quot;Frecuencias relativas de colores de cabello\\n en cada color de ojos&quot;) barplot(t(prop.table(HEC, margin=2)), beside=TRUE, legend.text=TRUE, ylim=c(0,0.6), col=c(&quot;burlywood4&quot;,&quot;lightblue&quot;,&quot;orange3&quot;,&quot;lightgreen&quot;), main=&quot;Frecuencias relativas de colores de ojos\\n en cada color de cabellos&quot;) Los diagramas de barras producidos con la dos últimas instrucciones son los de la Figura 8.14. Vemos, por ejemplo, que entre las personas de ojos azules, los cabellos rubios son los más frecuentes, y que entre las personas castañas el color de ojos más frecuente es el pardo. knitr::include_graphics(c(&quot;images/HECmargin1.png&quot;,&quot;images/HECmargin2.png&quot;)) Figura 8.14: Diagrama de barras de frecuencias relativas marginales de colores de ojos y de cabellos en HairEyeColor. 8.8 Guía rápida de funciones table calcula la tabla de frecuencias absolutas de un vector o un factor. as.table convierte un objeto (por ejemplo, una matriz) en una tabla de contingencia. ftable muestra una tabla multidimensional en formato plano. t sirve para trasponer una tabla bidimensional. aperm sirve para permutar las variables de una tabla multidimensional. prop.table calcula la tabla de frecuencias relativas de un vector o un factor a partir de su tabla de frecuencias absolutas. Tiene el parámetro siguiente: margin: sirve para especificar las dimensiones en cuyos niveles se calcularán las frecuencias relativas marginales. Si no se especifica, se calculan las frecuencias relativas globales. CrossTable, del paquete gmodels, produce, en el caso bidimensional, una tabla conjunta de frecuencias absolutas y de frecuencias relativas globales y marginales. names da los nombres de las columnas de una tabla unidimensional, y sirve también para modificar estos nombres. dimnames da una list con los vectores de los nombres de los niveles de las diferentes variables de una tabla multidimensional, y sirve también para modificar los nombres tanto de las variables como de sus niveles. tabla [...] se usa para especificar un elemento, una fila, una columna o una subtabla de la tabla . barplot dibuja el diagrama de barras de un vector o un factor a partir de una tabla de frecuencias. Algunos parámetros importantes: col: sirve para especificar los colores de las barras. horiz=TRUE: sirve para dibujar el diagrama horizontal. beside=TRUE: sirve para especificar que el diagrama sea por bloques. legend.text: sirve para añadir una leyenda que explique qué barras corresponden a cada uno de los niveles de la primera variable. args.legend: sirve para modificar las características de esta leyenda, igualándolo a una list con los valores de los parámetros de la función legend que queramos especificar. names: sirve para cambiar en el diagrama los nombres de los niveles de la segunda variable. main, xlab, ylab y el resto de parámetros de plot que tengan sentido para diagramas de barras. pie dibuja el diagrama circular de un vector o un factor a partir de una tabla de frecuencias. Algunos parámetros importantes: col: sirve para especificar los colores de los sectores. names: sirve para cambiar en el diagrama los nombres de los niveles. main, xlab, ylab y el resto de parámetros de plot que tengan sentido para diagramas circulares. plot y mosaicplot dibujan el diagrama de mosaico de una tabla de frecuencias. Algunos parámetros relevantes (aparte de los usuales de plot): col: asigna colores a los niveles de la última variable. dir: igualado a un vector de direcciones &quot;v&quot; (vertical) y &quot;h&quot; (horizontal), sirve para especificar la dirección de las barras de cada variable. mosaic, del paquete vcd, también dibuja el diagrama de mosaico de una tabla de frecuencias. Algunos parámetros importantes: dir: como en mosaicplot. highlighting: sirve para destacar una variable. highlighting_fill: sirve para asignar colores a los niveles de la variable destacada. cotabplot, del paquete vcd, produce una tabla con un diagrama de mosaico para cada nivel de la última variable. mosaic3d, del paquete vcdExtra, produce un diagrama de mosaico tridimensional. \\n indica un cambio de línea en un título o etiqueta. \\&quot; escribe unas comillas en el texto de un título o etiqueta. 8.9 Ejercicio Instalad y cargad el paquete MASS. Este paquete lleva una tabla de datos llamada birthwt sobre factores que pueden incidir en el peso de los niños al nacer. Con str y head, explorad su estructura, y en la pestaña de Ayuda, consultad el significado de cada variable. Calculad una tabla bidimensional de frecuencias relativas marginales de los pares (raza de la madre, peso inferior a 2.5 kg o no) que permita ver, fácilmente, si la raza de la madre influye en el peso del bebé. Dibujad un diagrama de mosaico de esta tabla. Asimismo, dibujad un diagrama de barras por bloques que permita visualizar esta información. Poned nombres adecuados a los bloques, colores a las barras, y añadid una leyenda que explique qué representa cada barra. ¿Se puede obtener alguna conclusión de esta tabla y de este diagrama de barras? Repetid el punto anterior para los pares (madre fumadora o no, peso inferior a 2.5 kg o no) y para los pares (madre hipertensa o no, peso inferior a 2.5 kg o no). Calculad una tabla de frecuencias relativas marginales de las ternas (raza de la madre, madre fumadora o no, peso inferior a 2.5 kg o no) que permita ver, fácilmente, si la combinación de la raza de la madre y su condición de fumadora o no fumadora influye en el peso del bebé. Dibujad un diagrama de mosaico de esta tabla tridimensional. Asimismo, dibujad un diagrama de barras por bloques que permita visualizar esta información (pensad cómo pasaréis de la tabla tridimensional a un diagrama de barras bidimensional que muestre la información deseada). Poned nombres adecuados a los bloques, colores a las barras, y añadid una leyenda que explique qué representa cada barra. ¿Se puede obtener alguna conclusión de esta tabla y de este diagrama de barras? Para simplificar, en lo que queda de sección, diremos vector para referirnos genéricamente tanto a un vector como a un factor.↩ Sí, ya sabemos que &lt;&gt; lleva acento ortográfico, pero procuramos evitar acentos y caracteres especiales en los guiones de las lecciones, para que se puedan abrir sin problemas en cualquier ordenador.↩ Extraída de la entrada sobre diagramas circulares de la Wikipedia: http://en.wikipedia.org/wiki/Pie_chart .↩ "],
["chap-ord.html", "Lección 9 Descripción de datos ordinales 9.1 Frecuencias para datos ordinales 9.2 Descripción de datos ordinales con R 9.3 Guía rápida de funciones 9.4 Ejercicio", " Lección 9 Descripción de datos ordinales Los datos ordinales son parecidos a los cualitativos, en el sentido de que son cualidades de objetos o individuos. Su diferencia con los datos cualitativos está en que las características que expresan los datos ordinales tienen un orden natural que permite acumular observaciones, es decir, contar cuántas hay por debajo de cada nivel. Un caso frecuente son las escalas tipo Likert , que se usan para conocer la opinión de un grupo de personas sobre un tema determinado.32 9.1 Frecuencias para datos ordinales Cuando trabajamos con datos ordinales, el orden de los niveles de los datos permite calcular no sólo las frecuencias absolutas y relativas que veíamos en la lección anterior, y que para variables ordinales se definen del mismo modo, sino también frecuencias acumuladas . Es decir, no sólo podemos contar cuántas veces hemos observado un cierto dato, sino también cuántas veces hemos observado un dato menor o igual que él. Ejemplo 9.1 Tenemos una muestra de 20 estudiantes de quienes sabemos la calificación que han sacado en un examen. Clasificamos estas calificaciones en Suspenso (\\(S\\)), Aprobado (\\(A\\)), Notable (\\(N\\)) y Sobresaliente (\\(E\\)) y consideramos su orden natural \\(S&lt;A&lt;N&lt;E\\). Las calificaciones que han obtenido son las siguientes: \\[ A,A,N,S,S,A,N,E,A,A,S,S,S,A,E,N,N,E,S,A. \\] En esta lista hay 6 \\(S\\), 7 \\(A\\), 4 \\(N\\) y 3 \\(E\\): éstas serían las frecuencias absolutas de las calificaciones en esta muestra de estudiantes. Por lo que se refiere a sus frecuencias absolutas acumuladas : Hay 6 estudiantes que han obtenido \\(S\\) o menos: la frecuencia absoluta acumulada de \\(S\\) es 6. Hay 13 estudiantes que han obtenido \\(A\\) o menos (6 \\(S\\) y 7 \\(A\\)): la frecuencia absoluta acumulada de \\(A\\) es 13. Hay 17 estudiantes que han obtenido \\(N\\) o menos (6 \\(S\\), 7 \\(A\\) y 4 \\(N\\)): la frecuencia absoluta acumulada de \\(N\\) es 17. Hay 20 estudiantes que han obtenido \\(E\\) o menos (todos): la frecuencia absoluta acumulada de \\(E\\) es 20. La frecuencia relativa acumulada de cada calificación es la fracción del total de estudiantes que representa su frecuencia absoluta acumulada: por ejemplo, la frecuencia relativa acumulada de notables es la proporción de estudiantes que han sacado un notable o menos, y, por lo tanto, es igual a la frecuencia absoluta acumulada de \\(N\\) dividida por el número total de estudiantes. Así pues, para calcular las frecuencias relativas acumuladas de las calificaciones en esta muestra, tenemos que dividir sus frecuencias absolutas acumuladas entre \\(20\\): \\[ S: \\frac{6}{20}=0.3,\\quad A: \\frac{13}{20}=0.65,\\quad N: \\frac{17}{20}=0.85,\\quad E: \\frac{20}{20}=1. \\] En general, supongamos que efectuamos \\(n\\) observaciones \\[ x_1,x_2,\\ldots,x_n \\] de un cierto tipo de datos ordinales, cuyos posibles niveles ordenados son \\[ l_1&lt;l_2&lt;\\cdots &lt;l_k. \\] Por lo tanto, cada una de estas observaciones \\(x_j\\) es igual a algún \\(l_i\\). Diremos que estas observaciones forman una variable ordinal . En el ejemplo anterior, tendríamos que los niveles son \\[ S&lt;A&lt;N&lt;E, \\] que \\(n=20\\), y que \\(x_1,\\ldots,x_{20}\\) son las calificaciones obtenidas por los estudiantes de la muestra. Con estas notaciones: Las definiciones de frecuencias absolutas \\(n_j\\) y relativas \\(f_j\\), para cada nivel \\(l_j\\), son las mismas que en una variable cualitativa. La frecuencia absoluta acumulada del nivel \\(l_j\\) en esta variable ordinal es el número \\(N_j\\) de observaciones \\(x_i\\) tales que \\(x_i\\leq l_j\\). Es decir, es \\[N_j=\\sum\\limits_{k=1}^j n_k.\\] La frecuencia relativa acumulada del nivel \\(l_j\\) en esta variable ordinal es la fracción (en tanto por uno) \\(F_j\\) de observaciones \\(x_i\\) tales que \\(x_i\\leq l_j\\). Es decir, \\[ F_j=\\dfrac{N_j}{n}=\\sum\\limits_{k=1}^j f_k. \\] 9.2 Descripción de datos ordinales con R Recordemos de la Lección 4 que la función cumsum, aplicada a un vector, calcula el vector de sus sumas acumuladas. Sobre una tabla de contingencia tiene el mismo efecto, y por lo tanto podemos usarla para calcular la tabla de frecuencias acumuladas (absolutas o relativas) de un vector, aplicándola a su tabla de frecuencias (absolutas o relativas, según corresponda). Ejemplo 9.2 Vamos a calcular y representar gráficamente las frecuencias acumuladas de la muestra de calificaciones del Ejemplo 9.1. Entraremos dichas calificaciones como un factor ordenado, porque es la manera natural de guardar una variable ordinal en R. notas=ordered(c(&quot;A&quot;,&quot;A&quot;,&quot;N&quot;,&quot;S&quot;,&quot;S&quot;,&quot;A&quot;,&quot;N&quot;,&quot;E&quot;,&quot;A&quot;,&quot;A&quot;,&quot;S&quot;,&quot;S&quot;, &quot;S&quot;,&quot;A&quot;,&quot;E&quot;,&quot;N&quot;,&quot;N&quot;,&quot;E&quot;,&quot;S&quot;,&quot;A&quot;), levels=c(&quot;S&quot;,&quot;A&quot;,&quot;N&quot;,&quot;E&quot;)) notas ## [1] A A N S S A N E A A S S S A E N N E S A ## Levels: S &lt; A &lt; N &lt; E table(notas) #Frec. absolutas ## notas ## S A N E ## 6 7 4 3 cumsum(table(notas)) #Frec. absolutas acumuladas ## S A N E ## 6 13 17 20 cumsum(prop.table(table(notas))) #Frec. relativas acumuladas ## S A N E ## 0.30 0.65 0.85 1.00 barplot(table(notas), main=&quot;Diagrama de barras de frecuencias absolutas de notas&quot;) barplot(cumsum(table(notas)), main=&quot;Diagrama de barras de frecuencias acumuladas de notas&quot;) Las dos últimas instrucciones producen los diagramas de la Figura ??. {r F1702,fig.cap=&quot;Diagramas de barras de frecuencias absolutas y de frecuencias absolutas acumuladas de las notas del Ejemplo \\@ref(ex:ex1701bis).&quot;} knitr::include_graphics(c(&quot;images/notasnoacum1.png&quot;,&quot;images/notasacum1.png&quot;)) Para calcular las frecuencias relativas acumuladas hemos usado la instrucción cumsum(prop.table(table(notas))), que va sumando las frecuencias relativas. También las podríamos haber calculado dividiendo las frecuencias absolutas acumuladas por el número de datos, usando una de las instrucciones siguientes: cumsum(table(notas))/length(notas) o cumsum(table(notas)/length(notas)). Pero no podíamos usar prop.table(cumsum(table(notas))). cumsum(prop.table(table(notas))) ## S A N E ## 0.30 0.65 0.85 1.00 cumsum(table(notas))/length(notas) ## S A N E ## 0.30 0.65 0.85 1.00 cumsum(table(notas)/length(notas)) ## S A N E ## 0.30 0.65 0.85 1.00 prop.table(cumsum(table(notas))) ## S A N E ## 0.1071429 0.2321429 0.3035714 0.3571429 Pensad qué ha entendido R que queríamos hacer con esta última instrucción. %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Ejemplo 9.3 Los diagramas de barras mostrados en la Figura ?? se han obtenido con el código siguiente. datos=c(4,4,2,1,3,3,4,1,1,3,5,2,5,2,1,2,3,2,1,1,2,2,4,2,1,1,1, 2,4,5,3,4,2,4,4,3,1,3,3,2,1,5,4,1,2,2,3,3,3,1,4,3,5,1,5,1,2,5,5, 2,4,5,1,4,3,1,1,4,3,3,4,4,1,2,1,3,4,1,4,2,2,4,1,3,5,3,3,3,2,2,3, 3,3,2,4,1,1,4,3,2) Nombres.compl=c(&quot;Muy en\\n desacuerdo&quot;,&quot;En\\n desacuerdo&quot;, &quot;Neutro\\n &quot;,&quot;De\\n acuerdo&quot;,&quot;Muy de\\n acuerdo&quot;) barplot(prop.table(table(datos)), ylim=c(0, 0.30), main=&quot;Diagrama de barras de las frecuencias relativas\\n de la variable \\&quot;Encuesta\\&quot;&quot;, names=Nombres.compl, xlab=&quot;Nivel de acuerdo escala Likert&quot;, ylab=&quot;Frec. relativas&quot;) barplot(cumsum(prop.table(table(datos))), ylim=c(0, 1), main=&quot;Diagrama de barras de las frecuencias relativas acumuladas \\n de la variable \\&quot;Encuesta\\&quot;&quot;, names=Nombres.compl, xlab=&quot;Nivel de acuerdo escala Likert&quot;, ylab=&quot;Frec. relativas acumuladas&quot;) En los diagramas de barras, hemos representado los niveles con un texto más descriptivo. Para hacerlo, hemos definido un vector Nombres.compl con sus nuevos nombres en el orden correspondiente (y en dos líneas cada uno para ocupar menos espacio horizontal), y entonces en los barplot hemos especificado names=Nombres.compl. Ejemplo 9.4 Un microbiólogo ha evaluado la semejanza a una cierta comunidad prototipo de los microbiotas intestinales de 40 individuos con síndrome del colon irritable. Los niveles de semejanza que ha usado son los de la Tabla ??, y los considera ordenados de la siguiente manera: Tot.difs \\(&lt;\\) Difs \\(&lt;\\) Pars \\(&lt;\\) Muy.pars \\(&lt;\\) Iguales. data.aux=data.frame(Nivel=c(&quot;Tot.difs&quot;,&quot;Difs&quot;,&quot;Pars&quot;,&quot;Muy.pars&quot;,&quot;Iguales&quot;),Significado=c(&quot;Totalmente diferentes&quot;,&quot;Diferentes&quot;,&quot;Parecidas&quot;,&quot;Muy parecidas&quot;,&quot;Totalmente Iguales&quot;)) kableExtra::kable(data.aux,cap=&quot;Niveles de semejanza de comunidades microbianas.&quot;) Tabla 9.1: Niveles de semejanza de comunidades microbianas. Nivel Significado Tot.difs Totalmente diferentes Difs Diferentes Pars Parecidas Muy.pars Muy parecidas Iguales Totalmente Iguales Los valores obtenidos en el estudio han sido los siguientes: Difs, Pars, Difs, Muy.pars, Muy.pars, Muy.pars, Iguales, Pars, Difs, Tot.difs, Muy.pars, Iguales, Muy.pars, Pars, Pars, Muy.pars, Iguales, Difs, Difs, Pars, Muy.pars, Muy.pars, Muy.pars, Difs, Pars, Pars, Iguales, Iguales, Muy.pars, Iguales, Difs, Tot.difs, Pars, Muy.pars, Iguales, Difs, Muy.pars, Muy.pars, Iguales, Tot.difs Para estudiar las frecuencias acumuladas de los niveles de semejanza en este estudio, entraremos los datos en un factor ordenado con los niveles ordenados de manera adecuada. &gt; datos=scan(sep=&quot;,&quot;, what=&quot;character&quot;) #Vamos a copiar del texto y pegar los valores 1: Difs,Pars,Difs,Muy.pars,Muy.pars,Muy.pars,Iguales,Pars,Difs,Tot.difs,Muy.pars,Iguales,Muy.pars,Pars,Pars,Muy.pars,Iguales,Difs,Difs,Pars,Muy.pars,Muy.pars,Muy.pars,Difs,Pars,Pars,Iguales,Iguales,Muy.pars,Iguales,Difs,Tot.difs,Pars,Muy.pars,Iguales,Difs,Muy.pars,Muy.pars,Iguales,Tot.difs 41: Read 40 items sem.com=ordered(datos, levels=c(&quot;Tot.difs&quot;,&quot;Difs&quot;,&quot;Pars&quot;,&quot;Muy.pars&quot;,&quot;Iguales&quot;)) #Los datos, como factor ordenado AbsFr=table(sem.com) #Ponemos nombre a la tabla de frecuencias absolutas AbsFr ## sem.com ## Tot.difs Difs Pars Muy.pars Iguales ## 3 8 8 13 8 sem.com ## [1] Difs Pars Difs Muy.pars Muy.pars Muy.pars Iguales ## [8] Pars Difs Tot.difs Muy.pars Iguales Muy.pars Pars ## [15] Pars Muy.pars Iguales Difs Difs Pars Muy.pars ## [22] Muy.pars Muy.pars Difs Pars Pars Iguales Iguales ## [29] Muy.pars Iguales Difs Tot.difs Pars Muy.pars Iguales ## [36] Difs Muy.pars Muy.pars Iguales Tot.difs ## Levels: Tot.difs &lt; Difs &lt; Pars &lt; Muy.pars &lt; Iguales prop.table(AbsFr) #Tabla de frecuencias relativas ## sem.com ## Tot.difs Difs Pars Muy.pars Iguales ## 0.075 0.200 0.200 0.325 0.200 sem.com ## [1] Difs Pars Difs Muy.pars Muy.pars Muy.pars Iguales ## [8] Pars Difs Tot.difs Muy.pars Iguales Muy.pars Pars ## [15] Pars Muy.pars Iguales Difs Difs Pars Muy.pars ## [22] Muy.pars Muy.pars Difs Pars Pars Iguales Iguales ## [29] Muy.pars Iguales Difs Tot.difs Pars Muy.pars Iguales ## [36] Difs Muy.pars Muy.pars Iguales Tot.difs ## Levels: Tot.difs &lt; Difs &lt; Pars &lt; Muy.pars &lt; Iguales cumsum(AbsFr) #Tabla de frecuencias absolutas acumuladas ## Tot.difs Difs Pars Muy.pars Iguales ## 3 11 19 32 40 cumsum(prop.table(AbsFr)) #Tabla de frecuencias relativas acumuladas ## Tot.difs Difs Pars Muy.pars Iguales ## 0.075 0.275 0.475 0.800 1.000 Nombres.Completos=c(&quot;Totalmente\\n diferentes&quot;,&quot;Diferentes\\n&quot;, &quot;Parecidas\\n &quot;,&quot;Muy\\n parecidas&quot;,&quot;Totalmente\\n iguales&quot;) barplot(cumsum(prop.table(AbsFr)), names=Nombres.Completos, main=&quot;Diagrama de barras de frecuencias relativas acumuladas&quot;) Figura 9.1: Diagrama de barras de frecuencias relativas acumuladas de semejanzas de microbiotas a una comunidad modelo. La instrucción barplot produce el diagrama de barras de la Figura 9.1. Para calcular frecuencias acumuladas en una tabla multidimensional, hay que aplicar a la tabla la función cumsum mediante la función apply. En este caso concreto, la sintaxis de la instrucción sería apply(tabla, MARGIN=..., FUN=cumsum), donde el valor de MARGIN ha de ser el de la dimensión en la que queremos acumular las frecuencias: 1 si queremos calcular las frecuencias acumuladas por filas, 2 si las queremos calcular por columnas, etc. Esta construcción tiene algunas particularidades, que vamos a ilustrar con un ejemplo. Ejemplo 9.5 Supongamos que las 100 respuestas a la encuesta en el Ejemplo ?? en realidad provienen de técnicos de tres empresas diferentes, A, B y C, de manera que las 30 primeras son de técnicos de A, las 20 siguientes, de técnicos de B, y las 50 últimas, de técnicos de C. Nos interesa estudiar la distribución de las respuestas según la empresa. Vamos a organizar estos datos en un data frame. Para que sea más fácil visualizar la información que nos interesa, es conveniente que las filas de las tablas de frecuencias correspondan a las empresas. Por lo tanto, al definir el data frame, entraremos como primera variable la de las empresas; de esta manera, éstas aparecerán en las filas al aplicarle la función table. respuestas=ordered(c(4,4,2,1,3,3,4,1,1,3,5,2,5,2,1,2,3,2,1,1,2, 2,4,2,1,1,1,2,4,5,3,4,2,4,4,3,1,3,3,2,1,5,4,1,2,2,3,3,3,1,4,3,5, 1,5,1,2,5,5,2,4,5,1,4,3,1,1,4,3,3,4,4,1,2,1,3,4,1,4,2,2,4,1,3,5, 3,3,3,2,2,3,3,3,2,4,1,1,4,3,2), levels=1:5) empresas=rep(c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;), times=c(30,20,50)) df_encuesta=data.frame(empresas,respuestas) str(df_encuesta) ## &#39;data.frame&#39;: 100 obs. of 2 variables: ## $ empresas : Factor w/ 3 levels &quot;A&quot;,&quot;B&quot;,&quot;C&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ respuestas: Ord.factor w/ 5 levels &quot;1&quot;&lt;&quot;2&quot;&lt;&quot;3&quot;&lt;&quot;4&quot;&lt;..: 4 4 2 1 3 3 4 1 1 3 ... head(df_encuesta,5) ## empresas respuestas ## 1 A 4 ## 2 A 4 ## 3 A 2 ## 4 A 1 ## 5 A 3 table(df_encuesta) ## respuestas ## empresas 1 2 3 4 5 ## A 9 9 4 5 3 ## B 4 4 7 4 1 ## C 11 9 13 11 6 Para calcular la tabla de frecuencias absolutas acumuladas de las respuestas por empresa, y como las empresas definen las filas de la tabla anterior, hemos de usar apply con MARGIN=1. apply(table(df_encuesta), MARGIN=1, FUN=cumsum) ## empresas ## respuestas A B C ## 1 9 4 11 ## 2 18 8 20 ## 3 22 15 33 ## 4 27 19 44 ## 5 30 20 50 ¡La tabla se ha traspuesto! Resulta que cuando se aplica apply a una table bidimensional, R intercambia, si es necesario, filas por columnas en el resultado para que la dimensión de la tabla resultante en la que se haya aplicado la función sea la de las columnas. Por lo tanto, para volver a tener las empresas en las filas, hemos de trasponer el resultado de apply. t(apply(table(df_encuesta), MARGIN=1, FUN=cumsum)) ## respuestas ## empresas 1 2 3 4 5 ## A 9 18 22 27 30 ## B 4 8 15 19 20 ## C 11 20 33 44 50 Vamos ahora a calcular la tabla de frecuencias relativas acumuladas de las respuestas por empresa. Para ello, y en una sola instrucción, primero calculamos la tabla de frecuencias relativas por filas; a continuación, las acumulamos por filas con apply y cumsum; y, finalmente, como ya estamos avisados, trasponemos el resultado t(apply(prop.table(table(df_encuesta), margin=1), MARGIN=1, FUN=cumsum)) ## respuestas ## empresas 1 2 3 4 5 ## A 0.30 0.6 0.7333333 0.90 1 ## B 0.20 0.4 0.7500000 0.95 1 ## C 0.22 0.4 0.6600000 0.88 1 Vamos ahora a dibujar el diagrama de barras por bloques de esta tabla. Como queremos que las barras de este diagrama se agrupen por empresas, hemos de aplicar barplot a la tabla sin trasponer. Tabla=apply(prop.table(table(df_encuesta), margin=1), MARGIN=1, FUN=cumsum) barplot(Tabla, beside=TRUE, legend=TRUE, main=&quot;Diagrama de barras de frecuencias relativas acumuladas\\n de respuestas por empresa&quot;) De esta manera obtenemos el diagrama de barras de la izquierda de la Figura 9.2. Como vemos, la leyenda se superpone sobre las barras de la última empresa. Para resolver este problema, situaremos la leyenda en la esquina superior izquierda. Además, vamos a sustituir en la leyenda los valores de las respuestas por sus significados, y para que quepa, reduciremos el tamaño del texto. El resultado será el diagrama de la derecha de la Figura 9.3. barplot(Tabla, beside=TRUE, legend.text=c(&quot;Muy en desacuerdo&quot;, &quot;En desacuerdo&quot;,&quot;Neutro&quot;,&quot;De acuerdo&quot;,&quot;Muy de acuerdo&quot;), main=&quot;Diagrama de barras de frecuencias relativas acumuladas\\n de respuestas por empresa&quot;, args.legend=list(x=&quot;topleft&quot;, cex=0.55)) pppppppppppppppppppppp knitr::include_graphics(c(&quot;images/figenc1.png&quot;,&quot;images/figenc2.png&quot;)) Figura 9.2: Diagramas de barras de frecuencias relativas acumuladas de respuestas por empresa en el Ejemplo @ ref(ex:encuestacum). Ejemplo 9.6 Consideremos el data frame InsectSprays, que viene predefinido en R. Veamos su estructura. head(InsectSprays) ## count spray ## 1 10 A ## 2 7 A ## 3 20 A ## 4 14 A ## 5 14 A ## 6 12 A str(InsectSprays) ## &#39;data.frame&#39;: 72 obs. of 2 variables: ## $ count: num 10 7 20 14 14 12 10 23 17 20 ... ## $ spray: Factor w/ 6 levels &quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... table(InsectSprays$count) ## ## 0 1 2 3 4 5 6 7 9 10 11 12 13 14 15 16 17 19 20 21 22 23 24 26 ## 2 6 4 8 4 7 3 3 1 3 3 2 4 4 2 2 4 1 2 2 1 1 1 2 #help(InsectSprays) Con el help(InsectSprays) nos enteramos de que la variable numérica count contiene los números de insectos que se encontraron en diferentes superficies agrícolas, todas de la misma área, tratadas con el insecticida indicado por el factor spray. Vamos a convertir la variable count en una variable ordinal que agrupe las entradas de la variable original en niveles &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt; y &lt;&lt;20 o más&gt;&gt;. La manera más sencilla de llevarlo a cabo es usando la función cut, que estudiaremos en detalle en la Lección ??. Por ahora es suficiente saber que la instrucción cut(InsectSprays$count, breaks=c(0,5,10,15,20,Inf), right=FALSE, labels=c(&quot;0-4&quot;,&quot;5-9&quot;,&quot;10-14&quot;,&quot;15-19&quot;,&quot;20-...&quot;)) ## [1] 10-14 5-9 20-... 10-14 10-14 10-14 10-14 20-... 15-19 20-... ## [11] 10-14 10-14 10-14 15-19 20-... 10-14 15-19 10-14 15-19 15-19 ## [21] 15-19 20-... 5-9 10-14 0-4 0-4 5-9 0-4 0-4 0-4 ## [31] 0-4 0-4 0-4 0-4 0-4 0-4 0-4 5-9 10-14 5-9 ## [41] 0-4 0-4 5-9 5-9 5-9 5-9 0-4 0-4 0-4 5-9 ## [51] 0-4 5-9 0-4 5-9 0-4 0-4 0-4 0-4 5-9 0-4 ## [61] 10-14 5-9 15-19 20-... 15-19 15-19 10-14 10-14 20-... 20-... ## [71] 20-... 10-14 ## Levels: 0-4 5-9 10-14 15-19 20-... &lt;&gt; el vector numérico InsectSprays$count en intervalos de extremos los puntos especificados en el argumento breaks; el parámetro right=FALSE sirve para indicar que los puntos de corte pertenecen al intervalo a su derecha, e Inf indica \\(\\infty\\). Por tanto, los intervalos en los que esta instrucción agrupa los números de insectos son \\[ [0,5), [5,10), [10,15), [15,20), [20,\\infty). \\] El resultado de la instrucción es un factor que tiene como niveles estos intervalos, identificados con las etiquetas especificadas en el parámetro labels. Como nosotros vamos a usar estos intervalos como niveles de una variable ordinal, además convertiremos este factor en ordenado. Los cambios lo realizaremos en una copia de InsectSprays. IS = InsectSprays IS$count.rank = ordered( cut(IS$count,breaks = c(0, 5, 10, 15, 20, Inf), right = FALSE, labels = c(&quot;0-4&quot;, &quot;5-9&quot;, &quot;10-14&quot;, &quot;15-19&quot;, &quot;20-...&quot;) )) str(IS) ## &#39;data.frame&#39;: 72 obs. of 3 variables: ## $ count : num 10 7 20 14 14 12 10 23 17 20 ... ## $ spray : Factor w/ 6 levels &quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... ## $ count.rank: Ord.factor w/ 5 levels &quot;0-4&quot;&lt;&quot;5-9&quot;&lt;&quot;10-14&quot;&lt;..: 3 2 5 3 3 3 3 5 4 5 ... Nos interesa estudiar la distribución de los números de insectos según el tipo de insecticida. Por lo tanto, vamos a calcular las tablas bidimensionales de frecuencias relativas y relativas acumuladas de los intervalos de números de insectos en cada nivel de Spray, y las representaremos por medio de diagramas de barras. La tabla de frecuencias absolutas de los pares (insecticida, intervalo de números de insectos) se puede obtener aplicando table al data frame formado por las dos últimas columnas de IS. Tab=table(IS[,2:3]) Tab ## count.rank ## spray 0-4 5-9 10-14 15-19 20-... ## A 0 1 7 1 3 ## B 0 1 4 5 2 ## C 11 1 0 0 0 ## D 5 6 1 0 0 ## E 8 4 0 0 0 ## F 0 1 4 3 4 Freq.rel=round(prop.table(Tab, margin=1), 3) #Frecuencias relativas por Spray Freq.rel ## count.rank ## spray 0-4 5-9 10-14 15-19 20-... ## A 0.000 0.083 0.583 0.083 0.250 ## B 0.000 0.083 0.333 0.417 0.167 ## C 0.917 0.083 0.000 0.000 0.000 ## D 0.417 0.500 0.083 0.000 0.000 ## E 0.667 0.333 0.000 0.000 0.000 ## F 0.000 0.083 0.333 0.250 0.333 Freq.rel.acum=round(apply(prop.table(Tab, margin=1), MARGIN=1, FUN=cumsum), 3) #Frecuencias relativas acumuladas Freq.rel.acum ## spray ## count.rank A B C D E F ## 0-4 0.000 0.000 0.917 0.417 0.667 0.000 ## 5-9 0.083 0.083 1.000 0.917 1.000 0.083 ## 10-14 0.667 0.417 1.000 1.000 1.000 0.417 ## 15-19 0.750 0.833 1.000 1.000 1.000 0.667 ## 20-... 1.000 1.000 1.000 1.000 1.000 1.000 t(Freq.rel.acum) ## count.rank ## spray 0-4 5-9 10-14 15-19 20-... ## A 0.000 0.083 0.667 0.750 1 ## B 0.000 0.083 0.417 0.833 1 ## C 0.917 1.000 1.000 1.000 1 ## D 0.417 0.917 1.000 1.000 1 ## E 0.667 1.000 1.000 1.000 1 ## F 0.000 0.083 0.417 0.667 1 cyan.col=c(&quot;cyan4&quot;,&quot;cyan3&quot;,&quot;cyan2&quot;,&quot;cyan1&quot;,&quot;cyan&quot;) #Colores azulones para las barras barplot(t(Freq.rel), beside=TRUE, legend=TRUE, ylim=c(0,1), col=cyan.col, main=&quot;Diagrama de barras de frecuencias relativas\\n de números de insectos por insecticida&quot;) barplot(Freq.rel.acum, beside=TRUE, legend=TRUE,col=cyan.col, main=&quot;Diagrama de barras de frecuencias relativas acumuladas\\n de números de insectos por insecticida&quot;, args.legend = list(x=&quot;topleft&quot;,cex=0.8)) Las dos últimas instrucciones producen los diagramas de barras de la Figura 9.3. Observamos que los insecticidas C, D y E son los más efectivos, porque producen mayores números de campos con pocos insectos, mientras que B y F son poco efectivos. knitr::include_graphics(c(&quot;images/Insect1.png&quot;,&quot;images/Insect2.png&quot;)) Figura 9.3: Diagramas de barras de frecuencias relativas y relativas acumuladas de números de insectos por tipo de insecticida en el data frame InsectSprays. 9.3 Guía rápida de funciones ordered sirve para construir factores ordenados. Sus parámetros principales se pueden consultar en la guía de la Lección 4. table calcula la tabla de frecuencias absolutas de un vector o un factor. t sirve para trasponer una tabla bidimensional. prop.table calcula la tabla de frecuencias relativas de un vector o un factor a partir de su tabla de frecuencias absolutas. Sus parámetros principales se pueden consultar en la guía de la Lección 8. cumsum calcula las sumas acumuladas de un vector. apply(tabla, MARGIN=..., FUN=función) aplica la función a los niveles de las variables de la tabla que se especifican en MARGIN. Para calcular frecuencias acumuladas en tablas multidimensionales, se usa FUN=cumsum. barplot dibuja el diagrama de barras de un vector o un factor a partir de una tabla de frecuencias. Sus parámetros principales se pueden consultar en la guía de la Lección 8. 9.4 Ejercicio La tabla de datos http://aprender.uib.es/Rdir/Notas2011A.txt contiene las notas obtenidas por los estudiantes de los grados de Biología y Bioquímica de la UIB en un examen de la asignatura Matemáticas I del curso 2011-12 (no aparecen los no presentados, por lo que no hay valores NA). Las variables que contiene la tabla para cada estudiante son: su nota numérica (sobre 10), su calificación alfabética (S significa Suspenso, A , Aprobado, N , Notable, y E , Sobresaliente) y su grupo (BLM para el grupo de las mañanas de Biología, BLT para el grupo de las tardes de Biología, y BQ para Bioquímica). Definid un data frame con esta tabla, de manera que su variable NotasLetra sea un factor ordenado, con las calificaciones alfabéticas ordenadas según su orden natural \\(S&lt;A&lt;N&lt;E\\). Comprobad con str y head que el data frame obtenido tiene la estructura deseada. Comprobad que las notas alfabéticas se corresponden con las nota numéricas: \\([0,5[\\) corresponde a S; \\([5,7[\\), a A; \\([7,9[\\), a N; y \\([9,10]\\), a E. Si hay algún error, corregid la nota alfabética. Calculad la tabla bidimensional de frecuencias relativas de las calificaciones alfabéticas por grupo, con las frecuencias relativas calculadas dentro de los grupos. Redondead a 2 cifras decimales. Los grupos tienen que definir las filas, y las notas, las columnas. Calculad la tabla bidimensional de frecuencias relativas acumuladas de las calificaciones alfabéticas por grupo, con las frecuencias relativas calculadas dentro de los grupos. Redondead a 2 cifras decimales. Los grupos tienen que definir las filas, y las notas, las columnas. Dibujad un diagrama de barras por bloques de las frecuencias relativas de las calificaciones alfabéticas dentro de cada grupo: los bloques han de corresponder a los grupos. Poned un título al gráfico y añadid una leyenda que explique cada barra qué calificación representa. Podéis poner colores, cambiar los nombres, etc. para mejorar su aspecto. Dibujad un diagrama de barras por bloques de las frecuencias relativas acumuladas de las calificaciones alfabéticas dentro de cada grupo: los bloques han de corresponder a los grupos. Como antes, poned un título al gráfico y añadid una leyenda que explique cada barra qué calificación representa. Podéis poner colores, cambiar los nombres, etc. para mejorar su aspecto. ¿Podéis extraer alguna conclusión de las tablas y los gráficos anteriores? Para más información, podéis consultar http://es.wikipedia.org/wiki/Escalas_Likert .↩ "]
]
